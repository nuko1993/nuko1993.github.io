

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="nuko">
  <meta name="keywords" content="">
  
    <meta name="description" content="前言之前在OC高级中，已经对GCD有了了解，这里通过深入libdispatch的源码进行理解，源码传送门：https:&#x2F;&#x2F;github.com&#x2F;apple-oss-distributions&#x2F;libdispatch&#x2F;tags queue和线程之间的关系 之前我们知道，queue负责存放任务，queue中任务的具体执行最终需要线程执行 不同的queue中的任务可以放到同一个线程上，每个线程在执行qu">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解GCD-Dispatch Queue">
<meta property="og:url" content="https://nuko1993.github.io/2024/02/21/think-deep-in-gcd-dispatch-queue/index.html">
<meta property="og:site_name" content="nuko的小站">
<meta property="og:description" content="前言之前在OC高级中，已经对GCD有了了解，这里通过深入libdispatch的源码进行理解，源码传送门：https:&#x2F;&#x2F;github.com&#x2F;apple-oss-distributions&#x2F;libdispatch&#x2F;tags queue和线程之间的关系 之前我们知道，queue负责存放任务，queue中任务的具体执行最终需要线程执行 不同的queue中的任务可以放到同一个线程上，每个线程在执行qu">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nuko1993.github.io/images/image-43.png">
<meta property="og:image" content="https://nuko1993.github.io/images/image-44.png">
<meta property="og:image" content="https://nuko1993.github.io/images/image-45.png">
<meta property="og:image" content="https://nuko1993.github.io/images/image-46.png">
<meta property="article:published_time" content="2024-02-21T13:31:48.000Z">
<meta property="article:modified_time" content="2024-02-27T14:14:44.481Z">
<meta property="article:author" content="nuko">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="GCD">
<meta property="article:tag" content="Dispatch Queue">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://nuko1993.github.io/images/image-43.png">
  
  
  
  <title>深入理解GCD-Dispatch Queue - nuko的小站</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"nuko1993.github.io","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>nuko的小站</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="深入理解GCD-Dispatch Queue"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-02-21 21:31" pubdate>
          2024年2月21日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          42k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          353 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">深入理解GCD-Dispatch Queue</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前在OC高级中，已经对GCD有了了解，这里通过深入libdispatch的源码进行理解，源码传送门：<a target="_blank" rel="noopener" href="https://github.com/apple-oss-distributions/libdispatch/tags">https://github.com/apple-oss-distributions/libdispatch/tags</a></p>
<h2 id="queue和线程之间的关系"><a href="#queue和线程之间的关系" class="headerlink" title="queue和线程之间的关系"></a>queue和线程之间的关系</h2><ul>
<li>之前我们知道，queue负责存放任务，queue中任务的具体执行最终需要线程执行</li>
<li>不同的queue中的任务可以放到同一个线程上，每个线程在执行queue中任务时会记录当前正在执行的是哪个queue的任务</li>
<li>并发queue可以同时将多个任务放在多个线程上执行，串行queue只能每次在单个线程上执行一个任务</li>
<li>一个queue可以设置另一个queue为自己的目标queue，即将自己整体作为任务以另一个queue的策略执行，比如一个<code>并发queue设置一个串行queue作为目标，那么并发queue中的所有任务也都变成了串行</code><br>一张图可以解释：<br><img src="/../images/image-43.png" srcset="/img/loading.gif" lazyload alt="Alt text"><br>可以看到，queue和线程并非一对一关系，一个线程可以执行多个queue的任务（但同一时间肯定是只能执行一个queue的任务，所以有线程的当前queue的概念）。queue可以串行也可以是并行。</li>
<li>但是对于main queue优点特殊，main queue的任务只能在主线程上执行；反之则不然，主线程也能执行非main queue的任务，如下代码：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">// 测试代码</span><br><span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() &#123;<br>    <span class="hljs-keyword">super</span>.viewDidLoad()<br>    <br>    <span class="hljs-keyword">let</span> sQueue <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>(label: <span class="hljs-string">&quot;sQueue&quot;</span>)<br>    <span class="hljs-comment">// 串行队列同步不会产生新线程，任务在当前线程下执行，因此Thread.current必然是主线程</span><br>    sQueue.sync &#123; <span class="hljs-built_in">print</span>(<span class="hljs-type">Thread</span>.current) &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<code>注意是同步执行时不会产生新线程，如果是异步执行，仍然会产生新线程</code></li>
</ul>
<h2 id="queue的定义"><a href="#queue的定义" class="headerlink" title="queue的定义"></a>queue的定义</h2><h3 id="dispatch-queue-s"><a href="#dispatch-queue-s" class="headerlink" title="dispatch_queue_s"></a>dispatch_queue_s</h3><p>在源码中，通过dispatch_queue_s来定义queue，为了方便后续分析，先列出一些函数方便理解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_s</span> &#123;<br>    <span class="hljs-comment">// 第一部分：DISPATCH_STRUCT_HEADER(dispatch_queue_s, dispatch_queue_vtable_s)</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_vtable_s</span> *do_vtable; <span class="hljs-comment">// 该类型的结构体包含了对dispatch_queue_s的操作函数</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_s</span> *<span class="hljs-keyword">volatile</span> do_next; <span class="hljs-comment">//链表的next</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> do_ref_cnt; <span class="hljs-comment">// 引用计数</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> do_xref_cnt; <span class="hljs-comment">// 外部引用计数</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> do_suspend_cnt; <span class="hljs-comment">// 暂停标志，比如延时处理中，在任务到时后，计时器处理将会将该标志位修改，然后唤醒队列调度</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_s</span> *do_targetq; <span class="hljs-comment">// 目标队列，GCD允许我们将一个队列放在另一个队列里执行任务</span><br>	<span class="hljs-type">void</span> *do_ctxt; <span class="hljs-comment">// 上下文，用来存储线程池相关数据，比如用于线程挂起和唤醒的信号量、线程池尺寸等</span><br>	<span class="hljs-type">void</span> *do_finalizer;<br>	<br>    <span class="hljs-comment">// 第二部分：DISPATCH_QUEUE_HEADER</span><br>    <span class="hljs-type">uint32_t</span> <span class="hljs-keyword">volatile</span> dq_running; <span class="hljs-comment">// 队列运行的任务数量</span><br>    <span class="hljs-type">uint32_t</span> dq_width; <span class="hljs-comment">// 最大并发数：主队列/串行队列的最大并发数为1</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_object_s</span> *<span class="hljs-keyword">volatile</span> dq_items_tail; <span class="hljs-comment">// 队列尾结点</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_object_s</span> *<span class="hljs-keyword">volatile</span> dq_items_head; <span class="hljs-comment">// 队列头结点</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> dq_serialnum; <span class="hljs-comment">// 队列序列号</span><br>    <span class="hljs-type">dispatch_queue_t</span> dq_specific_q; <span class="hljs-comment">// specific队列</span><br>	<br>    <span class="hljs-type">char</span> dq_label[DISPATCH_QUEUE_MIN_LABEL_SIZE]; <span class="hljs-comment">// 队列名，队列名要少于64个字符    </span><br>    <span class="hljs-type">char</span> _dq_pad[DISPATCH_QUEUE_CACHELINE_PAD]; <span class="hljs-comment">// for static queues only</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="dispatch-queue-vtable-s"><a href="#dispatch-queue-vtable-s" class="headerlink" title="dispatch_queue_vtable_s"></a>dispatch_queue_vtable_s</h3><p>在上面我们可以看到，dispatch_queue_s中包含了dispatch_queue_vtable_s，该结构体包含了针对dispatch_queue_s的操作函数，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// dispatch_queue_vtable_s结构体，声明了一些函数用于操作dispatch_queue_s结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_vtable_s</span> &#123;<br>	<span class="hljs-comment">// DISPATCH_VTABLE_HEADER(dispatch_queue_s);</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">const</span> do_type;<br>	<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-type">const</span> do_kind;<br>	<span class="hljs-built_in">size_t</span> (*<span class="hljs-type">const</span> do_debug)(<span class="hljs-keyword">struct</span> dispatch_queue_s *, <span class="hljs-type">char</span> *, <span class="hljs-type">size_t</span>);<br>	<span class="hljs-comment">// 唤醒队列的方法，全局队列和主队列此项为NULL</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_s</span> *(*<span class="hljs-type">const</span> do_invoke)(<span class="hljs-keyword">struct</span> dispatch_queue_s); <br>	<span class="hljs-comment">// 用于检测传入对象中的一些值是否满足条件</span><br>	<span class="hljs-built_in">bool</span> (*<span class="hljs-type">const</span> do_probe)(<span class="hljs-keyword">struct</span> dispatch_queue_s *);<br>	<span class="hljs-comment">// 销毁队列的方法，通常内部会调用这个对象的finalizer函数</span><br>	<span class="hljs-built_in">void</span> (*<span class="hljs-type">const</span> do_dispose)(<span class="hljs-keyword">struct</span> dispatch_queue_s *)<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在queue.c中定义了三个预定义的dispatch_queue_vtable_s，分别用于main queue&amp;自定义queue、global queue和manager queue</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 用于主队列和自定义队列</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_vtable_s</span> _dispatch_queue_vtable = &#123;<br>	.do_type = DISPATCH_QUEUE_TYPE,<br>	.do_kind = <span class="hljs-string">&quot;queue&quot;</span>,<br>	.do_dispose = _dispatch_queue_dispose,<br>	.do_invoke = <span class="hljs-literal">NULL</span>,<br>	.do_probe = (<span class="hljs-type">void</span> *)dummy_function_r0,<br>	.do_debug = dispatch_queue_debug,<br>&#125;;<br><br><span class="hljs-comment">// 用于全局队列</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_vtable_s</span> _dispatch_queue_root_vtable = &#123;<br>	.do_type = DISPATCH_QUEUE_GLOBAL_TYPE,<br>	.do_kind = <span class="hljs-string">&quot;global-queue&quot;</span>,<br>	.do_debug = dispatch_queue_debug,<br>	.do_probe = _dispatch_queue_wakeup_global,<br>&#125;;<br><br><span class="hljs-comment">// 用于管理队列</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_vtable_s</span> _dispatch_queue_mgr_vtable = &#123;<br>	.do_type = DISPATCH_QUEUE_MGR_TYPE,<br>	.do_kind = <span class="hljs-string">&quot;mgr-queue&quot;</span>,<br>	.do_invoke = _dispatch_mgr_thread,<br>	.do_debug = dispatch_queue_debug,<br>	.do_probe = _dispatch_mgr_wakeup,<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="queue的类型"><a href="#queue的类型" class="headerlink" title="queue的类型"></a>queue的类型</h2><p>queue可以分为main queue、自定义queue、global queue和manager queue</p>
<h3 id="main-queue"><a href="#main-queue" class="headerlink" title="main queue"></a>main queue</h3><p>我们最为熟悉，通过dispatch_get_main_queue即可获取，其内部定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> dispatch_get_main_queue() (&amp;_dispatch_main_q)</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_s</span> _dispatch_main_q = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !DISPATCH_USE_RESOLVERS</span><br>	.do_vtable = &amp;_dispatch_queue_vtable,<br>	.do_targetq = &amp;_dispatch_root_queues[<br>			DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY], <span class="hljs-comment">// root queue中的其中一个</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>	.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>	.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>	.dq_label = <span class="hljs-string">&quot;com.apple.main-thread&quot;</span>,<br>	.dq_running = <span class="hljs-number">1</span>,<br>	.dq_width = <span class="hljs-number">1</span>, <span class="hljs-comment">// 说明主队列是一个串行队列</span><br>	.dq_serialnum = <span class="hljs-number">1</span>, <span class="hljs-comment">// 主队列序列号</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>main queue的成员说明如下：<ul>
<li>do_vtable之前已经看到了，是预定义的_dispatch_queue_vtable</li>
<li>do_targetq，也是一个预定义的queue，其定义如下：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY] = &#123;<br>        .do_vtable = &amp;_dispatch_queue_root_vtable,<br>        .do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>        .do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>        .do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>        .do_ctxt = &amp;_dispatch_root_queue_contexts[<br>                DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY],<br>        .dq_label = <span class="hljs-string">&quot;com.apple.root.default-overcommit-priority&quot;</span>,<br>        .dq_running = <span class="hljs-number">2</span>,<br>        .dq_width = UINT32_MAX,<br>        .dq_serialnum = <span class="hljs-number">7</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>do_ref_cnt、do_xref_cnt,引用计数，和GCD的对象内存管理相关（GCD内部有自己的引用计数规则，不采用ARC），下面是它的引用计数方法：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dispatch_retain</span><span class="hljs-params">(<span class="hljs-type">dispatch_object_t</span> dou)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dou._do-&gt;do_xref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT)) &#123;<br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// global object</span><br>&#125;<br><span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-type">void</span> _dispatch_retain(<span class="hljs-type">dispatch_object_t</span> dou) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dou._do-&gt;do_ref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT)) &#123;<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// global object</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dispatch_release</span><span class="hljs-params">(<span class="hljs-type">dispatch_object_t</span> dou)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dou._do-&gt;do_xref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 调用_dispatch_release函数;</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-type">void</span> _dispatch_release(<span class="hljs-type">dispatch_object_t</span> dou) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dou._do-&gt;do_ref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT)) &#123;<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// global object</span><br>    &#125;<br>    <span class="hljs-comment">// 调用dx_dispose宏即调用do_dispose</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
  从上述代码可以看出：1.由于main queue的ref cnt是DISPATCH_OBJECT_GLOBAL_REFCNT，因而main queue的生命周期是整个进程 2.当ref cnt为0时，GCD中的对象才会释放</li>
</ul>
</li>
</ul>
<h3 id="manager-queue"><a href="#manager-queue" class="headerlink" title="manager queue"></a>manager queue</h3><p>manager queue是只在GCD内部使用的queue，不对外公开。用于GCD内部的管理角色，比如GCD定时器就用到了它，其内部定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_s</span> _dispatch_mgr_q = &#123;<br>	.do_vtable = &amp;_dispatch_queue_mgr_vtable,<br>	.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>	.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>	.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>	.do_targetq = &amp;_dispatch_root_queues[<br>			DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY],<br>	.dq_label = <span class="hljs-string">&quot;com.apple.libdispatch-manager&quot;</span>,<br>	.dq_width = <span class="hljs-number">1</span>,<br>	.dq_serialnum = <span class="hljs-number">2</span>, <span class="hljs-comment">// 管理队列序列号</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>manager queue的成员说明如下<ul>
<li>do_vtable：就是前面定义的_dispatch_queue_mgr_vtable</li>
<li>do_targetq：也是一个内部预定义的queue，如下：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">  [DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY] = &#123;<br>.do_vtable = &amp;_dispatch_queue_root_vtable,<br>.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>		DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY],<br>.dq_label = <span class="hljs-string">&quot;com.apple.root.high-overcommit-priority&quot;</span>,<br>.dq_running = <span class="hljs-number">2</span>,<br>.dq_width = UINT32_MAX,<br>.dq_serialnum = <span class="hljs-number">9</span>,<br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li>do_ref_cnt、do_xref_cnt:和main queue相同，也是DISPATCH_OBJECT_GLOBAL_REFCNT，因而生命周期也是整个进程</li>
</ul>
</li>
</ul>
<h3 id="自定义queue"><a href="#自定义queue" class="headerlink" title="自定义queue"></a>自定义queue</h3><p>通过dispatch_queue_create创建出来的queue就属于自定义queue，其源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">dispatch_queue_t</span> <span class="hljs-title">dispatch_queue_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *label, <span class="hljs-type">dispatch_queue_attr_t</span> attr)</span> </span>&#123;<br>	<span class="hljs-type">dispatch_queue_t</span> dq;<br>	<span class="hljs-type">size_t</span> label_len;<br>	<br>	<span class="hljs-keyword">if</span> (!label) &#123;<br>		label = <span class="hljs-string">&quot;&quot;</span>;<br>	&#125;<br>	<br>	label_len = <span class="hljs-built_in">strlen</span>(label);<br>	<span class="hljs-keyword">if</span> (label_len &lt; (DISPATCH_QUEUE_MIN_LABEL_SIZE - <span class="hljs-number">1</span>)) &#123;<br>		label_len = (DISPATCH_QUEUE_MIN_LABEL_SIZE - <span class="hljs-number">1</span>);<br>	&#125;<br>	<br>	<span class="hljs-comment">// XXX switch to malloc()</span><br>	dq = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1ul</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> dispatch_queue_s) -<br>				DISPATCH_QUEUE_MIN_LABEL_SIZE - DISPATCH_QUEUE_CACHELINE_PAD +<br>				label_len + <span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(!dq)) &#123;<br>		<span class="hljs-keyword">return</span> dq;<br>	&#125;<br>	<br>	<span class="hljs-comment">// _dispatch_queue_init(dq);</span><br>	<span class="hljs-comment">// 队列初始化展开如下</span><br>	dq-&gt;do_vtable = &amp;_dispatch_queue_vtable;<br>	dq-&gt;do_next = DISPATCH_OBJECT_LISTLESS;<br>	dq-&gt;do_ref_cnt = <span class="hljs-number">1</span>;<br>	dq-&gt;do_xref_cnt = <span class="hljs-number">1</span>;<br>	<span class="hljs-comment">// Default target queue is overcommit!</span><br>	<span class="hljs-comment">// 使用的目标队列：_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY]</span><br>	dq-&gt;do_targetq = _dispatch_get_root_queue(<span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>	dq-&gt;dq_running = <span class="hljs-number">0</span>;<br>	dq-&gt;dq_width = <span class="hljs-number">1</span>;<br>	dq-&gt;dq_serialnum = <span class="hljs-built_in">dispatch_atomic_inc</span>(&amp;_dispatch_queue_serial_numbers) - <span class="hljs-number">1</span>;<br>	<br>	<span class="hljs-built_in">strcpy</span>(dq-&gt;dq_label, label);<br>	<br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">fastpath</span>(!attr)) &#123;<br>		<span class="hljs-keyword">return</span> dq;<br>	&#125;<br>	<span class="hljs-comment">// 如果是并发队列，设置最大并发数，UINT32_MAX可以看成不限制最大并发数</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">fastpath</span>(attr == DISPATCH_QUEUE_CONCURRENT)) &#123;<br>		dq-&gt;dq_width = UINT32_MAX;<br>		<span class="hljs-comment">// 设置目标队列，对于并发队列_dispatch_get_root_queue函数中的overcommit传的是false，获取的值： _dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY]</span><br>		dq-&gt;do_targetq = _dispatch_get_root_queue(<span class="hljs-number">0</span>, <span class="hljs-literal">false</span>);<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-built_in">dispatch_debug_assert</span>(!attr, <span class="hljs-string">&quot;Invalid attribute&quot;</span>);<br>	&#125;<br>	<span class="hljs-keyword">return</span> dq;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关于slowpath和fastpath，实际是为了编译器优化，提高执行效率，slowpath表示该分支较少发生，fastpath表示该分支较大可能发生</p>
<ul>
<li><p>关于自定义queue的成员：</p>
<ul>
<li>do_vtable，和main queue相同，前面已经介绍了</li>
<li>do_targetq分为两种：<ul>
<li>自定义串行queue：通过dispatch_get_root_queue(0, true)获取，获取到的是_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY]</li>
<li>自定义并发queue：通过_dispatch_get_root_queue(0, false)获取，获取到的是_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY]</li>
<li>可以看到，true&#x2F;false代表是否要针对该queue创建新的线程，若是true，表示需要，否则不需要</li>
</ul>
</li>
<li>dq_serialnum是在_dispatch_queue_serial_numbers的基础上原子自增，从12开始，1到11是被内部保留的，如下：</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// skip zero</span><br><span class="hljs-comment">// 1 - main_q</span><br><span class="hljs-comment">// 2 - mgr_q</span><br><span class="hljs-comment">// 3 - _unused_</span><br><span class="hljs-comment">// 4,5,6,7,8,9,10,11 - global queues</span><br><span class="hljs-comment">// we use &#x27;xadd&#x27; on Intel, so the initial value == next assigned</span><br></code></pre></td></tr></table></figure>
<p>  1是main queue，2是manager queue，3暂时未使用，4-11是global queue</p>
</li>
</ul>
<h3 id="global-queue"><a href="#global-queue" class="headerlink" title="global queue"></a>global queue</h3><p>我们使用dispatch_get_global_queue来获取，其源码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">dispatch_queue_t</span> <span class="hljs-title">dispatch_get_global_queue</span><span class="hljs-params">(<span class="hljs-type">long</span> priority, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (flags &amp; ~DISPATCH_QUEUE_OVERCOMMIT) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> _dispatch_get_root_queue(priority, flags &amp; DISPATCH_QUEUE_OVERCOMMIT);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">dispatch_queue_t</span> _dispatch_get_root_queue(<span class="hljs-type">long</span> priority, <span class="hljs-type">bool</span> overcommit) &#123;<br>	<span class="hljs-keyword">if</span> (overcommit) <span class="hljs-keyword">switch</span> (priority) &#123;<br>	<span class="hljs-keyword">case</span> DISPATCH_QUEUE_PRIORITY_LOW:<br>		<span class="hljs-keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY];<br>	<span class="hljs-keyword">case</span> DISPATCH_QUEUE_PRIORITY_DEFAULT:<br>		<span class="hljs-keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY];<br>	<span class="hljs-keyword">case</span> DISPATCH_QUEUE_PRIORITY_HIGH:<br>		<span class="hljs-keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY];<br>	<span class="hljs-keyword">case</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND:<br>		<span class="hljs-keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY];<br>	&#125;<br>	<br>	<span class="hljs-keyword">switch</span> (priority) &#123;<br>	<span class="hljs-keyword">case</span> DISPATCH_QUEUE_PRIORITY_LOW:<br>		<span class="hljs-keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY];<br>	<span class="hljs-keyword">case</span> DISPATCH_QUEUE_PRIORITY_DEFAULT:<br>		<span class="hljs-keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY];<br>	<span class="hljs-keyword">case</span> DISPATCH_QUEUE_PRIORITY_HIGH:<br>		<span class="hljs-keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY];<br>	<span class="hljs-keyword">case</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND:<br>		<span class="hljs-keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY];<br>	<span class="hljs-keyword">default</span>:<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_s</span> _dispatch_root_queues[] = &#123;<br>	[DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY] = &#123;<br>		.do_vtable = &amp;_dispatch_queue_root_vtable,<br>		.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>		.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>		.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>		.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>				DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY],<br><br>		.dq_label = <span class="hljs-string">&quot;com.apple.root.low-priority&quot;</span>,<br>		.dq_running = <span class="hljs-number">2</span>,<br>		.dq_width = UINT32_MAX,<br>		.dq_serialnum = <span class="hljs-number">4</span>,<br>	&#125;,<br>	[DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY] = &#123;<br>		.do_vtable = &amp;_dispatch_queue_root_vtable,<br>		.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>		.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>		.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>		.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>				DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY],<br><br>		.dq_label = <span class="hljs-string">&quot;com.apple.root.low-overcommit-priority&quot;</span>,<br>		.dq_running = <span class="hljs-number">2</span>,<br>		.dq_width = UINT32_MAX,<br>		.dq_serialnum = <span class="hljs-number">5</span>,<br>	&#125;,<br>	[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY] = &#123;<br>		.do_vtable = &amp;_dispatch_queue_root_vtable,<br>		.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>		.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>		.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>		.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>				DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY],<br><br>		.dq_label = <span class="hljs-string">&quot;com.apple.root.default-priority&quot;</span>,<br>		.dq_running = <span class="hljs-number">2</span>,<br>		.dq_width = UINT32_MAX,<br>		.dq_serialnum = <span class="hljs-number">6</span>,<br>	&#125;,<br>	[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY] = &#123;<br>		.do_vtable = &amp;_dispatch_queue_root_vtable,<br>		.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>		.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>		.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>		.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>				DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY],<br><br>		.dq_label = <span class="hljs-string">&quot;com.apple.root.default-overcommit-priority&quot;</span>,<br>		.dq_running = <span class="hljs-number">2</span>,<br>		.dq_width = UINT32_MAX,<br>		.dq_serialnum = <span class="hljs-number">7</span>,<br>	&#125;,<br>	[DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY] = &#123;<br>		.do_vtable = &amp;_dispatch_queue_root_vtable,<br>		.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>		.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>		.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>		.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>				DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY],<br><br>		.dq_label = <span class="hljs-string">&quot;com.apple.root.high-priority&quot;</span>,<br>		.dq_running = <span class="hljs-number">2</span>,<br>		.dq_width = UINT32_MAX,<br>		.dq_serialnum = <span class="hljs-number">8</span>,<br>	&#125;,<br>	[DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY] = &#123;<br>		.do_vtable = &amp;_dispatch_queue_root_vtable,<br>		.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>		.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>		.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>		.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>				DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY],<br><br>		.dq_label = <span class="hljs-string">&quot;com.apple.root.high-overcommit-priority&quot;</span>,<br>		.dq_running = <span class="hljs-number">2</span>,<br>		.dq_width = UINT32_MAX,<br>		.dq_serialnum = <span class="hljs-number">9</span>,<br>	&#125;,<br>	[DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY] = &#123;<br>		.do_vtable = &amp;_dispatch_queue_root_vtable,<br>		.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>		.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>		.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>		.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>				DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY],<br><br>		.dq_label = <span class="hljs-string">&quot;com.apple.root.background-priority&quot;</span>,<br>		.dq_running = <span class="hljs-number">2</span>,<br>		.dq_width = UINT32_MAX,<br>		.dq_serialnum = <span class="hljs-number">10</span>,<br>	&#125;,<br>	[DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY] = &#123;<br>		.do_vtable = &amp;_dispatch_queue_root_vtable,<br>		.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>		.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>		.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>		.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>				DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY],<br><br>		.dq_label = <span class="hljs-string">&quot;com.apple.root.background-overcommit-priority&quot;</span>,<br>		.dq_running = <span class="hljs-number">2</span>,<br>		.dq_width = UINT32_MAX,<br>		.dq_serialnum = <span class="hljs-number">11</span>,<br>	&#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>global queue的成员<ul>
<li><p>do_vtable是_dispatch_queue_root_vtable，在该vtable中，检测函数do_probe是_dispatch_queue_wakeup_global，用于唤醒global queue</p>
</li>
<li><p>do_targetq：之前我们看到，main queue、自定义queue和manager queue都使用预定义的queue作为target，但是global queue并没有，为啥没有呢，因为global queue获取到的就是root queue之一，root queue就不用再找target了，他们只能是其他queue的target</p>
</li>
<li><p>do_ref_cnt、do_xref_cnt：和main queue相同，所以也跟着整个进程</p>
</li>
<li><p>do_ctxt: 上下文，用于存储线程池相关数据，比如用于线程挂起和唤醒的信号量，其内部预定义：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_root_queue_context_s</span> _dispatch_root_queue_contexts[] = &#123;<br>    [DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>        .dgq_thread_mediator = &amp;_dispatch_thread_mediator[<br>                DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY],<br>        .dgq_thread_pool_size = MAX_THREAD_COUNT,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;,<br>    [DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>        .dgq_thread_mediator = &amp;_dispatch_thread_mediator[<br>                DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY],<br>        .dgq_thread_pool_size = MAX_THREAD_COUNT,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;,<br>    [DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>        .dgq_thread_mediator = &amp;_dispatch_thread_mediator[<br>                DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY],<br>        .dgq_thread_pool_size = MAX_THREAD_COUNT,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;,<br>    [DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>        .dgq_thread_mediator = &amp;_dispatch_thread_mediator[<br>                DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY],<br>        .dgq_thread_pool_size = MAX_THREAD_COUNT,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;,<br>    [DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>        .dgq_thread_mediator = &amp;_dispatch_thread_mediator[<br>                DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY],<br>        .dgq_thread_pool_size = MAX_THREAD_COUNT,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;,<br>    [DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>        .dgq_thread_mediator = &amp;_dispatch_thread_mediator[<br>                DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY],<br>        .dgq_thread_pool_size = MAX_THREAD_COUNT,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;,<br>    [DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>        .dgq_thread_mediator = &amp;_dispatch_thread_mediator[<br>                DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY],<br>        .dgq_thread_pool_size = MAX_THREAD_COUNT,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;,<br>    [DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>        .dgq_thread_mediator = &amp;_dispatch_thread_mediator[<br>                DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY],<br>        .dgq_thread_pool_size = MAX_THREAD_COUNT,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="queue中代码的同步执行：dispatch-sync"><a href="#queue中代码的同步执行：dispatch-sync" class="headerlink" title="queue中代码的同步执行：dispatch_sync"></a>queue中代码的同步执行：dispatch_sync</h2><p>首先明确，同步执行，即需要等待queue中代码执行完毕才能接着向下执行。<br>测试代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">// 串行队列</span><br><span class="hljs-keyword">let</span> sQueue <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>(label: <span class="hljs-string">&quot;sQueue&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>)<br>sQueue.sync &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-number">2</span>)</span>：<span class="hljs-subst">\(Thread.current)</span>&quot;</span>) &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-number">3</span>)<br>sQueue.sync &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-number">4</span>)</span>：<span class="hljs-subst">\(Thread.current)</span>&quot;</span>) &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-number">5</span>)<br><br><span class="hljs-comment">// 并行队列</span><br><span class="hljs-keyword">let</span> cQueue <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>(label: <span class="hljs-string">&quot;cQueue&quot;</span>, attributes: [.concurrent])<br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>)<br>cQueue.sync &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-number">2</span>)</span>：<span class="hljs-subst">\(Thread.current)</span>&quot;</span>) &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-number">3</span>)<br>cQueue.sync &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-number">4</span>)</span>：<span class="hljs-subst">\(Thread.current)</span>&quot;</span>) &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-number">1</span><br><span class="hljs-number">2</span>：<span class="hljs-operator">&lt;</span><span class="hljs-type">NSThread</span>: <span class="hljs-number">0x600002478980</span><span class="hljs-operator">&gt;</span>&#123;number <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, name <span class="hljs-operator">=</span> main&#125;<br><span class="hljs-number">3</span><br><span class="hljs-number">4</span>：<span class="hljs-operator">&lt;</span><span class="hljs-type">NSThread</span>: <span class="hljs-number">0x600002478980</span><span class="hljs-operator">&gt;</span>&#123;number <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, name <span class="hljs-operator">=</span> main&#125;<br><span class="hljs-number">5</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span>：<span class="hljs-operator">&lt;</span><span class="hljs-type">NSThread</span>: <span class="hljs-number">0x600002478980</span><span class="hljs-operator">&gt;</span>&#123;number <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, name <span class="hljs-operator">=</span> main&#125;<br><span class="hljs-number">3</span><br><span class="hljs-number">4</span>：<span class="hljs-operator">&lt;</span><span class="hljs-type">NSThread</span>: <span class="hljs-number">0x600002478980</span><span class="hljs-operator">&gt;</span>&#123;number <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, name <span class="hljs-operator">=</span> main&#125;<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
<p>可见，<code>不管是串行queue和并发queue，只要是sync，都是在当前线程执行，不会使用新线程</code>，且会阻塞当前执行流，所以如果是在并发queue上同步执行，那么仍然不会创建新线程，而只是在当前线程执行。但是注意特殊情况：在异步线程执行sync到main queue的任务，仍然会在主线程执行！所以的main queue任务必须在主线程执行！！</p>
<h3 id="入口函数：dispatch-sync"><a href="#入口函数：dispatch-sync" class="headerlink" title="入口函数：dispatch_sync"></a>入口函数：dispatch_sync</h3><p>源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dispatch_sync</span><span class="hljs-params">(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> (^work)(<span class="hljs-type">void</span>))</span> </span>&#123;<br>	<span class="hljs-comment">// DISPATCH_COCOA_COMPAT是Mac OS下才会走的</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_COCOA_COMPAT</span><br>	<span class="hljs-comment">// 是否是主队列</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dq == &amp;_dispatch_main_q)) &#123;<br>		<span class="hljs-comment">// 内部也是执行dispatch_sync_f函数</span><br>		<span class="hljs-keyword">return</span> _dispatch_sync_slow(dq, work);<br>	&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Block_basic</span> *bb = (<span class="hljs-type">void</span> *)work;<br>	<span class="hljs-built_in">dispatch_sync_f</span>(dq, work, (<span class="hljs-type">dispatch_function_t</span>)bb-&gt;Block_invoke);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<p>虽然该函数缺乏了main queue，但是最终执行的还是dispatch_sync_f，其源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dispatch_sync_f</span><span class="hljs-params">(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> *ctxt, <span class="hljs-type">dispatch_function_t</span> func)</span> </span>&#123;<br>	<span class="hljs-comment">// 串行队列包括主队列</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">fastpath</span>(dq-&gt;dq_width == <span class="hljs-number">1</span>)) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">dispatch_barrier_sync_f</span>(dq, ctxt, func);<br>	&#125;<br>	<span class="hljs-comment">// 全局队列，全局队列是没有do_targetq的，主队列/管理队列/自定义队列都有</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(!dq-&gt;do_targetq)) &#123;<br>		<span class="hljs-comment">// the global root queues do not need strict ordering</span><br>		(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_atomic_add2o</span>(dq, dq_running, <span class="hljs-number">2</span>);<br>		<span class="hljs-keyword">return</span> _dispatch_sync_f_invoke(dq, ctxt, func);<br>	&#125;<br>	<span class="hljs-comment">// 其他队列</span><br>	_dispatch_sync_f2(dq, ctxt, func);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>该函数区分了三种case：</p>
<ul>
<li>串行queue：执行dispatch_barrier_sync_f</li>
<li>并发queue：<ul>
<li>global queue：_dispatch_sync_f_invoke</li>
<li>非global queue：_dispatch_sync_f2</li>
</ul>
</li>
</ul>
<h3 id="重点函数dispatch-barrier-sync-f"><a href="#重点函数dispatch-barrier-sync-f" class="headerlink" title="重点函数dispatch_barrier_sync_f"></a>重点函数dispatch_barrier_sync_f</h3><p>该函数用于串行queue sync的时候，其实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dispatch_barrier_sync</span><span class="hljs-params">(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> (^work)(<span class="hljs-type">void</span>))</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_COCOA_COMPAT</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dq == &amp;_dispatch_main_q)) &#123;<br>	   <span class="hljs-comment">// 内部调用dispatch_barrier_sync_f函数</span><br>		<span class="hljs-keyword">return</span> _dispatch_barrier_sync_slow(dq, work);<br>	&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Block_basic</span> *bb = (<span class="hljs-type">void</span> *)work;<br>	<span class="hljs-built_in">dispatch_barrier_sync_f</span>(dq, work, (<span class="hljs-type">dispatch_function_t</span>)bb-&gt;Block_invoke);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>虽然区分main queue，但最终是调用dispatch_barrier_sync_f。查看源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">DISPATCH_NOINLINE</span><br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">dispatch_barrier_sync_f</span><span class="hljs-params">(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> *ctxt, <span class="hljs-type">dispatch_function_t</span> func)</span> </span>&#123;<br>	<span class="hljs-comment">// 1) ensure that this thread hasn&#x27;t enqueued anything ahead of this call</span><br>	<span class="hljs-comment">// 2) the queue is not suspended</span><br>	<span class="hljs-comment">// 1) 确保此线程在此调用之前没有入队</span><br>	<span class="hljs-comment">// 2) 队列未挂起</span><br>	<br>	<span class="hljs-comment">// 第1步：如果串行队列中存在其他任务或者队列被挂起，进入_dispatch_barrier_sync_f_slow，</span><br>	<span class="hljs-comment">// 等待这个队列中的其他任务完成(用信号量的方式通知)，然后执行这个任务。</span><br>	<span class="hljs-comment">// 多数情况下不会发生</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dq-&gt;dq_items_tail) || <span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">DISPATCH_OBJECT_SUSPENDED</span>(dq)))&#123;<br>		<span class="hljs-keyword">return</span> _dispatch_barrier_sync_f_slow(dq, ctxt, func);<br>	&#125;<br>	<br>	<span class="hljs-comment">// 第2步：检查队列的dq_running状态，如果没有运行，进入_dispatch_barrier_sync_f_slow，等待激活。</span><br>	<span class="hljs-comment">// bool __sync_bool_compare_and_swap (type *ptr, type oldval, type newval, ...)</span><br>	<span class="hljs-comment">// 比较*ptr与oldval的值，如果两者相等，则将newval更新到*ptr并返回true</span><br>	<span class="hljs-comment">// dispatch_atomic_cmpxchg2o(dq, dq_running, 0, 1)相当于dq-&gt;dq_running为0的时候将</span><br>	<span class="hljs-comment">// dq-&gt;dq_running设置为1，并返回true</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(!<span class="hljs-built_in">dispatch_atomic_cmpxchg2o</span>(dq, dq_running, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>))) &#123;<br>		<span class="hljs-comment">// global queues and main queue bound to main thread always falls into</span><br>		<span class="hljs-comment">// the slow case</span><br>		<span class="hljs-comment">// 全局队列和绑定到主线程的主队列始终属于慢速情况即会进入_dispatch_barrier_sync_f_slow函数</span><br>		<span class="hljs-keyword">return</span> _dispatch_barrier_sync_f_slow(dq, ctxt, func);<br>	&#125;<br>	<br>	<span class="hljs-comment">// 第3步：有多重队列，寻找真正的目标队列，其实还是回到了dispatch_sync_f方法</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dq-&gt;do_targetq-&gt;do_targetq)) &#123;<br>		<span class="hljs-keyword">return</span> _dispatch_barrier_sync_f_recurse(dq, ctxt, func);<br>	&#125;<br>	<br>	<span class="hljs-comment">// 第4步：队列无任务执行，调用_dispatch_barrier_sync_f_invoke执行任务。</span><br>	<span class="hljs-comment">// 内部调用_dispatch_function_invoke去执行任务</span><br>	_dispatch_barrier_sync_f_invoke(dq, ctxt, func);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中涉及到三个函数：</p>
<ul>
<li>_dispatch_barrier_sync_f_slow：若串行queue有任务正在执行，内部使用线程对应信号量并wait，使得当前线程挂起等待被唤醒</li>
<li>_dispatch_barrier_sync_f_recurse：内部调用dispatch_sync_f，这样形成递归，目的是查找最终的目标queue</li>
<li>若queue无任务执行，则可以直接执行，调用_dispatch_barrier_sync_f_invoke执行，执行时调用_dispatch_function_invoke</li>
<li>总结起来：有任务正在执行，先挂起线程，等待任务执行完毕再唤醒当前线程继续执行</li>
</ul>
<h3 id="dispatch-barrier-sync-f-invoke"><a href="#dispatch-barrier-sync-f-invoke" class="headerlink" title="_dispatch_barrier_sync_f_invoke"></a>_dispatch_barrier_sync_f_invoke</h3><p>该函数用于在串行queue当前无任务正在执行时，实际去执行任务，源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++">DISPATCH_NOINLINE<br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br>_dispatch_barrier_sync_f_invoke(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> *ctxt, <span class="hljs-type">dispatch_function_t</span> func) &#123;<br>    <span class="hljs-comment">// _dispatch_function_invoke的实现</span><br>    <span class="hljs-comment">// 将当前线程的dispatch_queue_key设置为dq，然后执行任务，</span><br>    <span class="hljs-comment">// 执行完之后再恢复到之前的old_dq</span><br>    <span class="hljs-type">dispatch_queue_t</span> old_dq = _dispatch_thread_getspecific(dispatch_queue_key);<br>	_dispatch_thread_setspecific(dispatch_queue_key, dq);<br>	_dispatch_client_callout(ctxt, func);<br>	_dispatch_workitem_inc();<br>	_dispatch_thread_setspecific(dispatch_queue_key, old_dq);<br>	<br>	<span class="hljs-comment">// 如果队列中存在其他任务，用信号量的方法唤醒，然后继续执行下一个任务</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dq-&gt;dq_items_tail)) &#123;<br>		<span class="hljs-keyword">return</span> _dispatch_barrier_sync_f2(dq);<br>	&#125;<br>	<br>	<span class="hljs-comment">// dispatch_atomic_dec2o这个宏，会调用GCC内置的函数 __sync_sub_and_fetch，实现减法的原子性操作。因此这一行的意思是将dq_running的值减1，然后判断是否与0相等。</span><br>	<span class="hljs-comment">// _dispatch_wakeup为唤醒队列函数</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">dispatch_atomic_dec2o</span>(dq, dq_running) == <span class="hljs-number">0</span>)) &#123;<br>		_dispatch_wakeup(dq);<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>该函数总结就是：先执行任务，任务执行完毕之后若有其他任务在等着，则尝试唤醒，执行下一个任务</p>
<h3 id="GCD死锁产生的原因"><a href="#GCD死锁产生的原因" class="headerlink" title="GCD死锁产生的原因"></a>GCD死锁产生的原因</h3><p>我们知道，如果在主线程中使用dispatch_sync到main queue会造成死锁，比如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-meta">#import <span class="hljs-string">&quot;DeadLock.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">DeadLock</span></span><br><br>- (<span class="hljs-keyword">instancetype</span>)init &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init]) &#123;<br><span class="hljs-comment">//        [self _mianQueueDeadLock];</span><br>        [<span class="hljs-keyword">self</span> _serialQueueDeadLock];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - Private</span><br><br>- (<span class="hljs-type">void</span>)_mianQueueDeadLock &#123;<br>    <span class="hljs-built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^(<span class="hljs-type">void</span>)&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;这里死锁了&quot;</span>);<br>    &#125;);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)_serialQueueDeadLock &#123;<br>    <span class="hljs-built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="hljs-string">&quot;1serialQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <span class="hljs-built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="hljs-string">&quot;2serialQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <br>    <span class="hljs-built_in">dispatch_sync</span>(queue1, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;11111&quot;</span>);<br>        <br>        <span class="hljs-built_in">dispatch_sync</span>(queue1, ^&#123; <br>            <span class="hljs-comment">// 如果使用queue2就不会发生死锁，使用queue1就会死锁</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;22222&quot;</span>);<br>        &#125;);<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>
<p>以_serialQueueDeadLock为例，当我们首次执行串行queue任务时，正常执行，而执行到第二个dispatch_sync时，<code>由于上一个任务还没执行完毕(正在执行sync)，从而使得当前线程进入了wait，从而永远没有机会被唤醒，进入死锁</code></p>
<h3 id="dispatch-sync-f-invoke"><a href="#dispatch-sync-f-invoke" class="headerlink" title="_dispatch_sync_f_invoke"></a>_dispatch_sync_f_invoke</h3><p>该函数用于在并发的global queue同步执行任务时被调用，具体代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br>_dispatch_sync_f_invoke(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> *ctxt, <span class="hljs-type">dispatch_function_t</span> func) &#123;<br>	<span class="hljs-comment">// 执行任务</span><br>	_dispatch_function_invoke(dq, ctxt, func);<br>	<span class="hljs-comment">// dq-&gt;dq_running减2后判断是否等于0，是就唤醒队列</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">dispatch_atomic_sub2o</span>(dq, dq_running, <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>)) &#123;<br>		_dispatch_wakeup(dq);<br>	&#125;<br>&#125;<br><br>``<br>该函数作用：先通过_dispatch_function_invoke执行任务，执行完毕后，判断queue有没有激活，没有激活，则执行激活函数_dispatch_wakeup<br><br>### _dispatch_sync_f2<br>当在非global的并发queue上同步执行任务时，调用该函数，源码<br>```C++<br>_dispatch_sync_f2(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> *ctxt, <span class="hljs-type">dispatch_function_t</span> func) &#123;<br>	<span class="hljs-comment">// 1) ensure that this thread hasn&#x27;t enqueued anything ahead of this call</span><br>	<span class="hljs-comment">// 2) the queue is not suspended</span><br>	<br>	<span class="hljs-comment">// 第1步：队列中有其他任务或者队列被挂起，压入信号量开始等待</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dq-&gt;dq_items_tail) || <span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">DISPATCH_OBJECT_SUSPENDED</span>(dq)))&#123;<br>		<span class="hljs-keyword">return</span> _dispatch_sync_f_slow(dq, ctxt, func);<br>	&#125;<br>	<span class="hljs-comment">// 第2步：队列没有激活，激活队列后执行任务，最终还是调用了_dispatch_sync_f_slow函数，只是多了一个_dispatch_wakeup函数</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">dispatch_atomic_add2o</span>(dq, dq_running, <span class="hljs-number">2</span>) &amp; <span class="hljs-number">1</span>)) &#123;<br>		<span class="hljs-keyword">return</span> _dispatch_sync_f_slow2(dq, ctxt, func);<br>	&#125;<br>	<span class="hljs-comment">// 第3步：队列有多重队列，寻找真正的目标队列</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dq-&gt;do_targetq-&gt;do_targetq)) &#123;<br>		<span class="hljs-keyword">return</span> _dispatch_sync_f_recurse(dq, ctxt, func);<br>	&#125;<br>	<span class="hljs-comment">// 第4步：队列无任务执行，调用_dispatch_sync_f_invoke执行任务。</span><br>	<span class="hljs-comment">// 内部调用_dispatch_function_invoke去执行任务</span><br>	_dispatch_sync_f_invoke(dq, ctxt, func);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里涉及到三个函数：</p>
<ul>
<li>_dispatch_sync_f_slow：该函数内部使用wait让调用线程进入等待</li>
<li>_dispatch_sync_f_recurse：该函内部调用了dispatch_sync_f,寻找最终的目标队列</li>
<li>_dispatch_sync_f_invoke：若队列中无任务，则调用该函数执行，最终调用_dispatch_function_invoke</li>
</ul>
<p>从上面的代码可以看出，<code>在queue上执行同步任务都是顺序执行的，这种顺序和queue是串行还是并发没有关系，这些任务按照fifo的方式进入queue，每一个任务都会等待前一个的完成，并且不会开辟新线程，只会在当前线程执行</code></p>
<p>整理下如图所示<br><img src="/../images/image-44.png" srcset="/img/loading.gif" lazyload alt="Alt text"></p>
<h2 id="queue中代码的异步执行：dispatch-async"><a href="#queue中代码的异步执行：dispatch-async" class="headerlink" title="queue中代码的异步执行：dispatch_async"></a>queue中代码的异步执行：dispatch_async</h2><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>串行queue：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">let</span> sQueue <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>(label: <span class="hljs-string">&quot;sQueue&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>)<br>sQueue.async &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-number">2</span>)</span>：<span class="hljs-subst">\(Thread.current)</span>&quot;</span>) &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-number">3</span>)<br>sQueue.async &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-number">4</span>)</span>：<span class="hljs-subst">\(Thread.current)</span>&quot;</span>) &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br><span class="hljs-number">5</span><br><span class="hljs-number">2</span>：<span class="hljs-operator">&lt;</span><span class="hljs-type">NSThread</span>: <span class="hljs-number">0x600000b884c0</span><span class="hljs-operator">&gt;</span>&#123;number <span class="hljs-operator">=</span> <span class="hljs-number">4</span>, name <span class="hljs-operator">=</span> (null)&#125;<br><span class="hljs-number">4</span>：<span class="hljs-operator">&lt;</span><span class="hljs-type">NSThread</span>: <span class="hljs-number">0x600000b884c0</span><span class="hljs-operator">&gt;</span>&#123;number <span class="hljs-operator">=</span> <span class="hljs-number">4</span>, name <span class="hljs-operator">=</span> (null)&#125;<br></code></pre></td></tr></table></figure>
<p>可见，顺序执行串行queue中的任务，并且新创建了线程</p>
<p>并发queue：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">let</span> cQueue <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>(label: <span class="hljs-string">&quot;cQueue&quot;</span>, attributes: [.concurrent])<br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>)<br>cQueue.async &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-number">2</span>)</span>：<span class="hljs-subst">\(Thread.current)</span>&quot;</span>) &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-number">3</span>)<br>cQueue.async &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-number">4</span>)</span>：<span class="hljs-subst">\(Thread.current)</span>&quot;</span>) &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br><span class="hljs-number">5</span><br><span class="hljs-number">4</span>：<span class="hljs-operator">&lt;</span><span class="hljs-type">NSThread</span>: <span class="hljs-number">0x600002bc69c0</span><span class="hljs-operator">&gt;</span>&#123;number <span class="hljs-operator">=</span> <span class="hljs-number">6</span>, name <span class="hljs-operator">=</span> (null)&#125;<br><span class="hljs-number">2</span>：<span class="hljs-operator">&lt;</span><span class="hljs-type">NSThread</span>: <span class="hljs-number">0x600002bc84c0</span><span class="hljs-operator">&gt;</span>&#123;number <span class="hljs-operator">=</span> <span class="hljs-number">5</span>, name <span class="hljs-operator">=</span> (null)&#125;<br></code></pre></td></tr></table></figure>
<p>可见，然后使用不同线程，乱序执行加入的任务</p>
<p>总结就是：</p>
<ul>
<li>queue的异步任务具有创建新线程的能力</li>
<li>非main queue的串行queue，会创建一个新线程，然后所有任务串行执行</li>
<li>并发queue会创建多个线程，具体数量由系统决定，任务之间无顺序</li>
</ul>
<h3 id="入口函数：dispatch-async"><a href="#入口函数：dispatch-async" class="headerlink" title="入口函数：dispatch_async"></a>入口函数：dispatch_async</h3><p>源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dispatch_async</span><span class="hljs-params">(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> (^work)(<span class="hljs-type">void</span>))</span> </span>&#123;<br>	<span class="hljs-built_in">dispatch_async_f</span>(dq, _dispatch_Block_copy(work), _dispatch_call_block_and_release);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>该函数会将任务block copy到堆，或者增加引用计数（如果block已经在堆上），调用dispatch_async_f进入执行策略</p>
<p>dispatch_async_f函数的试实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">dispatch_async_f</span><span class="hljs-params">(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> *ctxt, <span class="hljs-type">dispatch_function_t</span> func)</span> </span>&#123;<br>	<span class="hljs-type">dispatch_continuation_t</span> dc;<br><br>	<span class="hljs-comment">// No fastpath/slowpath hint because we simply don&#x27;t know</span><br>	<span class="hljs-comment">// 串行队列，执行dispatch_barrier_async_f，其实最后还是执行任务入队的操作</span><br>	<span class="hljs-keyword">if</span> (dq-&gt;dq_width == <span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">dispatch_barrier_async_f</span>(dq, ctxt, func);<br>	&#125;<br><br>	<span class="hljs-comment">// 从线程私有数据中获取一个dispatch_continuation_t的结构体</span><br>	dc = <span class="hljs-built_in">fastpath</span>(_dispatch_continuation_alloc_cacheonly());<br>	<span class="hljs-keyword">if</span> (!dc) &#123;<br>		<span class="hljs-keyword">return</span> _dispatch_async_f_slow(dq, ctxt, func);<br>	&#125;<br><br>	dc-&gt;do_vtable = (<span class="hljs-type">void</span> *)DISPATCH_OBJ_ASYNC_BIT;<br>	dc-&gt;dc_func = func;<br>	dc-&gt;dc_ctxt = ctxt;<br><br>	<span class="hljs-comment">// No fastpath/slowpath hint because we simply don&#x27;t know</span><br>	<span class="hljs-comment">// 有目标队列，调用_dispatch_async_f2函数进行转发。</span><br>	<span class="hljs-keyword">if</span> (dq-&gt;do_targetq) &#123;<br>		<span class="hljs-keyword">return</span> _dispatch_async_f2(dq, dc);<br>	&#125;<br><br>	<span class="hljs-comment">// 全局队列直接进行入队操作</span><br>	_dispatch_queue_push(dq, dc);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从源码可以看出，该函数主要分为三种case：</p>
<ul>
<li>串行queue：调用dispatch_barrier_async_f</li>
<li>并发queue：<ul>
<li>若有目标queue：调用_dispatch_async_f2进行转发</li>
<li>若是global queue：直接调用_dispatch_queue_push入queue</li>
</ul>
</li>
</ul>
<p>由于queue的异步执行策略较为复杂，下面是图示：<br><img src="/../images/image-45.png" srcset="/img/loading.gif" lazyload alt="Alt text"><br>从途中可以看出，虽然分了三种情况，但是最终都要走到_dispatch_queue_push或者_dispatch_async_f2，而后者其实也是执行入队操作，所以本质就是执行_dispatch_queue_push</p>
<h3 id="dispatch-continuation-t结构体"><a href="#dispatch-continuation-t结构体" class="headerlink" title="dispatch_continuation_t结构体"></a>dispatch_continuation_t结构体</h3><p>这个结构体实际就是用力啊封装我们传入的block，以串行queue的case，dispatch_barrier_async_f的源码为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dispatch_barrier_async_f</span><span class="hljs-params">(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> *ctxt, <span class="hljs-type">dispatch_function_t</span> func)</span> </span>&#123;<br>	<span class="hljs-type">dispatch_continuation_t</span> dc;<br>	<span class="hljs-comment">// 从线程私有数据中获取一个dispatch_continuation_t的结构体。</span><br>	dc = <span class="hljs-built_in">fastpath</span>(_dispatch_continuation_alloc_cacheonly());<br>	<span class="hljs-keyword">if</span> (!dc) &#123;<br>		<span class="hljs-comment">// _dispatch_barrier_async_f_slow内部也是在进行入队操作</span><br>		<span class="hljs-keyword">return</span> _dispatch_barrier_async_f_slow(dq, ctxt, func);<br>	&#125;<br>	<br>	<span class="hljs-comment">// DISPATCH_OBJ_BARRIER_BIT，用于阻塞标识</span><br>	dc-&gt;do_vtable = (<span class="hljs-type">void</span> *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT);<br>	<span class="hljs-comment">// 将_dispatch_call_block_and_release作为func方法</span><br>	dc-&gt;dc_func = func;<br>	<span class="hljs-comment">// 将传入的block作为上下文</span><br>	dc-&gt;dc_ctxt = ctxt;<br>	<span class="hljs-comment">// 入队操作</span><br>	_dispatch_queue_push(dq, dc);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看出，我们的block被作为dc的context成员了。<br>注意dc的do_vtable：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 串行队列异步或者使用dispatch_barrier_async函数会有一个DISPATCH_OBJ_BARRIER_BIT的barrier标记</span><br>dc-&gt;do_vtable = (<span class="hljs-type">void</span> *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT);<br><br><span class="hljs-comment">// not barrier</span><br>dc-&gt;do_vtable = (<span class="hljs-type">void</span> *)DISPATCH_OBJ_ASYNC_BIT;<br></code></pre></td></tr></table></figure>
<p>可以看出，对于不同情况，dc的do_vtable的标记也不相同，在GCD内部，存在4种标记：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISPATCH_OBJ_ASYNC_BIT		0x1		<span class="hljs-comment">//异步</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISPATCH_OBJ_BARRIER_BIT	0x2		<span class="hljs-comment">//阻塞</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISPATCH_OBJ_GROUP_BIT		0x4		<span class="hljs-comment">//组</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISPATCH_OBJ_SYNC_SLOW_BIT	0x8		<span class="hljs-comment">//同步慢</span></span><br></code></pre></td></tr></table></figure>
<p>通过DISPATCH_OBJ_BARRIER_BIT标记，GCD知道需要使用阻塞特性。</p>
<h3 id="任务入queue：-dispatch-queue-push"><a href="#任务入queue：-dispatch-queue-push" class="headerlink" title="任务入queue：_dispatch_queue_push"></a>任务入queue：_dispatch_queue_push</h3><p>它实际是个宏定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _dispatch_queue_push(x, y) _dispatch_queue_push_list((x), (y), (y))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _dispatch_queue_push_list _dispatch_trace_queue_push_list</span><br></code></pre></td></tr></table></figure>

<p>_dispatch_trace_queue_push_list源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">void</span> _dispatch_trace_queue_push_list(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">dispatch_object_t</span> _head, <span class="hljs-type">dispatch_object_t</span> _tail) &#123;<br>	<span class="hljs-comment">// 是否可以入队</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">DISPATCH_QUEUE_PUSH_ENABLED</span>())) &#123;<br>		<span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_object_s</span> *dou = _head._do;<br>		<span class="hljs-keyword">do</span> &#123;<br>			<span class="hljs-comment">// 主要是对dispatch_continuation_s结构体的处理，确保后面的使用。</span><br>			_dispatch_trace_continuation(dq, dou, DISPATCH_QUEUE_PUSH);<br>		&#125; <span class="hljs-keyword">while</span> (dou != _tail._do &amp;&amp; (dou = dou-&gt;do_next));<br>	&#125;<br>	<br>	_dispatch_queue_push_list(dq, _head, _tail);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>_dispatch_queue_push_list的源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">void</span> _dispatch_queue_push_list(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">dispatch_object_t</span> _head, <span class="hljs-type">dispatch_object_t</span> _tail) &#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_object_s</span> *prev, *head = _head._do, *tail = _tail._do;<br><br>	tail-&gt;do_next = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-built_in">dispatch_atomic_store_barrier</span>();<br>	<span class="hljs-comment">// dispatch_atomic_xchg2o实质是调用((typeof(*(p)))__sync_swap((p), (n)))，它的定义是将p设为n并返回p操作之前的值。</span><br>	<span class="hljs-comment">// dispatch_atomic_xchg2o(dq, dq_items_tail, tail)相当于dq-&gt;dq_items_tail = tail，重新设置了队列的尾指针</span><br>	prev = <span class="hljs-built_in">fastpath</span>(<span class="hljs-built_in">dispatch_atomic_xchg2o</span>(dq, dq_items_tail, tail));<br>	<span class="hljs-keyword">if</span> (prev) &#123;<br>		<span class="hljs-comment">// if we crash here with a value less than 0x1000, then we are at a</span><br>		<span class="hljs-comment">// known bug in client code for example, see _dispatch_queue_dispose</span><br>		<span class="hljs-comment">// or _dispatch_atfork_child</span><br>		<span class="hljs-comment">// prev是原先的队尾，如果队列中有其他的元素，就将压入的对象加在队列的尾部。</span><br>		prev-&gt;do_next = head;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-comment">// 如果队列为空</span><br>		_dispatch_queue_push_list_slow(dq, head);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>_dispatch_queue_push_list_slow的源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">_dispatch_queue_push_list_slow(<span class="hljs-type">dispatch_queue_t</span> dq,<br>		<span class="hljs-keyword">struct</span> dispatch_object_s *obj)<br>&#123;<br>	<span class="hljs-comment">//dq-&gt;dq_items_head设置为dc，然后唤醒这个队列。因为此时队列为空，没有任务在执行，处于休眠状态，所以需要唤醒</span><br>	_dispatch_retain(dq);<br>	dq-&gt;dq_items_head = obj;<br>	_dispatch_wakeup(dq);<br>	_dispatch_release(dq);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="唤醒queue：-dispatch-wakeup"><a href="#唤醒queue：-dispatch-wakeup" class="headerlink" title="唤醒queue：_dispatch_wakeup"></a>唤醒queue：_dispatch_wakeup</h3><p>无论是同步执行还是异步执行，都使用该函数，用于唤醒当前queue，其源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">dispatch_queue_t</span> _dispatch_wakeup(<span class="hljs-type">dispatch_object_t</span> dou) &#123;<br>	<span class="hljs-type">dispatch_queue_t</span> tq;<br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">DISPATCH_OBJECT_SUSPENDED</span>(dou._do))) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dx_probe</span>(dou._do) &amp;&amp; !dou._dq-&gt;dq_items_tail) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// 如果dou._do-&gt;do_suspend_cnt == 0，返回YES,否则返回NO；</span><br>	<span class="hljs-comment">// 同时将DISPATCH_OBJECT_SUSPEND_LOCK赋值给dou._do-&gt;do_suspend_cnt</span><br>	<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dispatch_atomic_cmpxchg2o</span>(dou._do, do_suspend_cnt, <span class="hljs-number">0</span>, DISPATCH_OBJECT_SUSPEND_LOCK)) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_COCOA_COMPAT</span><br>		<span class="hljs-comment">// 主队列的任务调用_dispatch_queue_wakeup_main唤醒主队列</span><br>		<span class="hljs-keyword">if</span> (dou._dq == &amp;_dispatch_main_q) &#123;<br>			_dispatch_queue_wakeup_main();<br>		&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br>	<br>	<span class="hljs-comment">// 放到目标队列中，重新走_dispatch_queue_push方法</span><br>	_dispatch_retain(dou._do);<br>	tq = dou._do-&gt;do_targetq;<br>	_dispatch_queue_push(tq, dou._do);<br>	<br>	<span class="hljs-keyword">return</span> tq;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面我们看到了main queue和自定义queue的情况，但是没有global queue，因为global queue的唤醒比较隐晦，针对global queue的dx_probe(dou._do)调用如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> dx_probe(x) (x)-&gt;do_vtable-&gt;do_probe(x)</span><br><br><span class="hljs-comment">// dx_probe(dou._do) 相当于 (dou.do)-&gt;do_vtable-&gt;do_probe(dou.do)</span><br><br><span class="hljs-comment">// 全局队列的do_vtable：_dispatch_queue_root_vtable</span><br><br><span class="hljs-comment">// _dispatch_queue_root_vtable的定义</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_vtable_s</span> _dispatch_queue_root_vtable = &#123;<br>	.do_type = DISPATCH_QUEUE_GLOBAL_TYPE,<br>	.do_kind = <span class="hljs-string">&quot;global-queue&quot;</span>,<br>	.do_debug = dispatch_queue_debug,<br>	.do_probe = _dispatch_queue_wakeup_global,<br>&#125;;<br><br><span class="hljs-comment">// 全局队列：</span><br><span class="hljs-comment">// globalQueue -&gt; _dispatch_queue_root_vtable -&gt; _dispatch_queue_wakeup_global</span><br></code></pre></td></tr></table></figure>
<p>从上面可以看出，唤醒分为4种case：</p>
<ul>
<li>main queue：使用_dispatch_queue_wakeup_main</li>
<li>global queue：使用_dispatch_queue_wakeup_global</li>
<li>manager queue：调用_dispatch_mgr_wakeup，主要为dispatch_source服务</li>
<li>其他queue：向target queue压入该queue，继续做入queue操作</li>
</ul>
<h3 id="dispatch-queue-wakeup-main"><a href="#dispatch-queue-wakeup-main" class="headerlink" title="_dispatch_queue_wakeup_main"></a>_dispatch_queue_wakeup_main</h3><p>用于唤醒主线程的runloop，源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">void</span> _dispatch_queue_wakeup_main(<span class="hljs-type">void</span>) &#123;<br>	<span class="hljs-type">kern_return_t</span> kr;<br>	<span class="hljs-comment">// 主要看_dispatch_main_q_port_init的实现</span><br>	<span class="hljs-built_in">dispatch_once_f</span>(&amp;_dispatch_main_q_port_pred, <span class="hljs-literal">NULL</span>,<br>			_dispatch_main_q_port_init);<br>	<span class="hljs-comment">// 关于主线程的唤醒主要靠mach_port和在runloop中注册相对应的source1</span><br>    <span class="hljs-comment">// 但是该函数的实现没有公开</span><br>	kr = _dispatch_send_wakeup_main_thread(main_q_port, <span class="hljs-number">0</span>);<br><br>	<span class="hljs-keyword">switch</span> (kr) &#123;<br>	<span class="hljs-keyword">case</span> MACH_SEND_TIMEOUT:<br>	<span class="hljs-keyword">case</span> MACH_SEND_TIMED_OUT:<br>	<span class="hljs-keyword">case</span> MACH_SEND_INVALID_DEST:<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">default</span>:<br>		(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_assume_zero</span>(kr);<br>		<span class="hljs-keyword">break</span>;<br>	&#125;<br><br>	_dispatch_safe_fork = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// _dispatch_main_q_port_init的实现，RunLoop的唤醒需要依赖于mach port</span><br><span class="hljs-type">void</span> _dispatch_main_q_port_init(<span class="hljs-type">void</span> *ctxt DISPATCH_UNUSED) &#123;<br>	<span class="hljs-type">kern_return_t</span> kr;<br><br>	kr = <span class="hljs-built_in">mach_port_allocate</span>(<span class="hljs-built_in">mach_task_self</span>(), MACH_PORT_RIGHT_RECEIVE,<br>			&amp;main_q_port);<br>	<span class="hljs-built_in">DISPATCH_VERIFY_MIG</span>(kr);<br>	(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_assume_zero</span>(kr);<br>	kr = <span class="hljs-built_in">mach_port_insert_right</span>(<span class="hljs-built_in">mach_task_self</span>(), main_q_port, main_q_port,<br>			MACH_MSG_TYPE_MAKE_SEND);<br>	<span class="hljs-built_in">DISPATCH_VERIFY_MIG</span>(kr);<br>	(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_assume_zero</span>(kr);<br><br>	_dispatch_program_is_probably_callback_driven = <span class="hljs-literal">true</span>;<br>	_dispatch_safe_fork = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看出，唤醒主线程就是通过mach port向主线程发送消息，从而进一步唤醒RunLoop。所以我们说RunLoop RunLoop可以看做是使用GCD的API的，但是对于main queue，GCD和RunLoop紧密合作。</p>
<h3 id="dispatch-queue-wakeup-global"><a href="#dispatch-queue-wakeup-global" class="headerlink" title="_dispatch_queue_wakeup_global"></a>_dispatch_queue_wakeup_global</h3><p>源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-type">bool</span><br>_dispatch_queue_wakeup_global(<span class="hljs-type">dispatch_queue_t</span> dq) &#123;<br>	<span class="hljs-type">static</span> <span class="hljs-type">dispatch_once_t</span> pred;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_root_queue_context_s</span> *qc = dq-&gt;do_ctxt;<br>	<span class="hljs-type">int</span> r;<br><br>	<span class="hljs-keyword">if</span> (!dq-&gt;dq_items_tail) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>	_dispatch_safe_fork = <span class="hljs-literal">false</span>;<br><br>	<span class="hljs-built_in">dispatch_debug_queue</span>(dq, __PRETTY_FUNCTION__);<br>	<br>	<span class="hljs-comment">// 上下文以及根队列的初始化，根队列内部会初始化线程池</span><br>	<span class="hljs-built_in">dispatch_once_f</span>(&amp;pred, <span class="hljs-literal">NULL</span>, _dispatch_root_queues_init);<br>	<br>	<span class="hljs-comment">// _dispatch_queue_wakeup_global支持两种实现的任务唤醒pthread_workqueue和thread pool</span><br>	<span class="hljs-comment">//  1.支持pthread_workqueue</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> HAVE_PTHREAD_WORKQUEUES</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>	<span class="hljs-comment">// 如果队列的dgq_kworkqueue存在，则调用pthread_workqueue_additem_np函数</span><br>	<span class="hljs-comment">// dgq_kworkqueue是一个用于创建内核线程的接口，通过它创建的内核线程来执行内核其他模块排列到队列里的工作。</span><br>	<span class="hljs-comment">// 不同优先级的dispatch queue对应着对应优先级的workqueue。</span><br>	<span class="hljs-comment">// _dispatch_root_queues_init初始化的时候，使用pthread_workqueue_create_np创建pthread_workqueue</span><br>	<span class="hljs-keyword">if</span> (qc-&gt;dgq_kworkqueue)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>	&#123;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">dispatch_atomic_cmpxchg2o</span>(qc, dgq_pending, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>			<span class="hljs-type">pthread_workitem_handle_t</span> wh;<br>			<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> gen_cnt;<br>			_dispatch_debug(<span class="hljs-string">&quot;requesting new worker thread&quot;</span>);<br>			<span class="hljs-comment">// 该函数使用workq_kernreturn系统调用，通知workqueue增加应当执行的项目。</span><br>			<span class="hljs-comment">// 根据该通知，XNU内核基于系统状态判断是否要生成线程，如果是overcommit优先级的队列，workqueue则始终生成线程。</span><br>			r = <span class="hljs-built_in">pthread_workqueue_additem_np</span>(qc-&gt;dgq_kworkqueue, _dispatch_worker_thread2, dq, &amp;wh, &amp;gen_cnt);<br>			(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_assume_zero</span>(r);<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			_dispatch_debug(<span class="hljs-string">&quot;work thread request still pending on global &quot;</span><br>					<span class="hljs-string">&quot;queue: %p&quot;</span>, dq);<br>		&#125;<br>		<span class="hljs-keyword">goto</span> out;<br>	&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// HAVE_PTHREAD_WORKQUEUES</span></span><br>	<span class="hljs-comment">// 2. 支持thread pool</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>	<span class="hljs-comment">// 通过发送一个信号量使线程保活</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">dispatch_semaphore_signal</span>(qc-&gt;dgq_thread_mediator)) &#123;<br>		<span class="hljs-keyword">goto</span> out;<br>	&#125;<br><br>	<span class="hljs-comment">// 计算线程池可用长度，如果线程池已满则跳转到out即return false，否则执行线程池-1操作</span><br>	<span class="hljs-type">pthread_t</span> pthr;<br>	<span class="hljs-type">int</span> t_count;<br>	<span class="hljs-keyword">do</span> &#123;<br>		t_count = qc-&gt;dgq_thread_pool_size;<br>		<span class="hljs-keyword">if</span> (!t_count) &#123;<br>			_dispatch_debug(<span class="hljs-string">&quot;The thread pool is full: %p&quot;</span>, dq);<br>			<span class="hljs-keyword">goto</span> out;<br>		&#125;<br>	&#125; <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">dispatch_atomic_cmpxchg2o</span>(qc, dgq_thread_pool_size, t_count, t_count - <span class="hljs-number">1</span>));<br>	<span class="hljs-comment">// qc-&gt;dgq_thread_pool_size的值与t_counts是否相等，是就减1，并返回ture</span><br><br>	<span class="hljs-comment">// 这里说明线程池不够用了，使用pthread创建一个线程，</span><br>	<span class="hljs-comment">// 并执行_dispatch_worker_thread,_dispatch_worker_thread最终会调用到_dispatch_worker_thread2</span><br>	<span class="hljs-keyword">while</span> ((r = <span class="hljs-built_in">pthread_create</span>(&amp;pthr, <span class="hljs-literal">NULL</span>, _dispatch_worker_thread, dq))) &#123;<br>		<span class="hljs-keyword">if</span> (r != EAGAIN) &#123;<br>			(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_assume_zero</span>(r);<br>		&#125;<br>		<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>	&#125;<br>	<span class="hljs-comment">// 保证pthr能够被回收</span><br>	r = <span class="hljs-built_in">pthread_detach</span>(pthr);<br>	(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_assume_zero</span>(r);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// DISPATCH_ENABLE_THREAD_POOL</span></span><br><br>out:<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="queue的任务调度"><a href="#queue的任务调度" class="headerlink" title="queue的任务调度"></a>queue的任务调度</h2><h3 id="main-queue的任务调度"><a href="#main-queue的任务调度" class="headerlink" title="main queue的任务调度"></a>main queue的任务调度</h3><p>在上面的分析中我们知道，唤醒main queue会调用_dispatch_send_wakeup_main_thread，但是该函数没有公开实现。通过函数调用栈我们知道，main queue的任务调度最终又回到了GCD之中的_dispatch_main_queue_callback_4CF。唤醒主线程，RunLoop执行__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__，接着调用了GCD执行_dispatch_main_queue_callback_4CF，其源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 处理主队列任务</span><br><span class="hljs-type">void</span> _dispatch_main_queue_callback_4CF(<span class="hljs-type">mach_msg_header_t</span> *msg DISPATCH_UNUSED) &#123;<br>	<span class="hljs-keyword">if</span> (main_q_is_draining) &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-comment">// 正在处理任务，设置状态为true</span><br>	_dispatch_queue_set_mainq_drain_state(<span class="hljs-literal">true</span>);<br>	<span class="hljs-comment">// 调度处理任务</span><br>	_dispatch_main_queue_drain();<br>	<span class="hljs-comment">// 处理任务完成任务，恢复状态为false</span><br>	_dispatch_queue_set_mainq_drain_state(<span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>main queue是串行queue，拿到本次要执行的dc，执行任务。对于之后入队的block，则放在下一轮的main queue唤醒中执行</p>
<p>如果RunLoop还未休眠，并且main queue中存在等待执行的任务，则RunLoop会在处理完这些任务之后再进入休眠。否则，GCD唤醒主线程，进而唤醒RunLoop，再通过GCD中的函数取出来执行，直到执行完毕再进入休眠。</p>
<p>ps，再看下gcd唤醒追线程后的调用栈：<br>主线程唤醒-&gt;执行runloop的__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__-&gt;调用GCD的_dispatch_main_queue_callback_4CF-&gt;调用之前封装dc的_dispatch_call_block_and_release的函数-&gt;执行block，注意这里_dispatch_call_block_and_release函数，他是之前封装dc时传进来的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++">thread #<span class="hljs-number">1</span>, queue = <span class="hljs-string">&#x27;com.apple.main-thread&#x27;</span>, stop reason = breakpoint <span class="hljs-number">2.1</span><br>    frame #<span class="hljs-number">0</span>: <span class="hljs-number">0x000000010740f897</span> TestXX`__29-[ViewController viewDidLoad]_block_invoke(.block_descriptor=<span class="hljs-number">0x00006000035faca0</span>) at ViewController.m:<span class="hljs-number">81</span>:<span class="hljs-number">13</span><br>    frame #<span class="hljs-number">1</span>: <span class="hljs-number">0x00000001076847ec</span> libdispatch.dylib`_dispatch_call_block_and_release + <span class="hljs-number">12</span><br>    frame #<span class="hljs-number">2</span>: <span class="hljs-number">0x00000001076859c8</span> libdispatch.dylib`_dispatch_client_callout + <span class="hljs-number">8</span><br>  * frame #<span class="hljs-number">3</span>: <span class="hljs-number">0x0000000107693e75</span> libdispatch.dylib`_dispatch_main_queue_callback_4CF + <span class="hljs-number">1152</span><br>    frame #<span class="hljs-number">4</span>: <span class="hljs-number">0x00007fff2038fdbb</span> CoreFoundation`__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + <span class="hljs-number">9</span><br>    frame #<span class="hljs-number">5</span>: <span class="hljs-number">0x00007fff2038a63e</span> CoreFoundation`__CFRunLoopRun + <span class="hljs-number">2685</span><br>    frame #<span class="hljs-number">6</span>: <span class="hljs-number">0x00007fff203896d6</span> CoreFoundation`CFRunLoopRunSpecific + <span class="hljs-number">567</span><br>    frame #<span class="hljs-number">7</span>: <span class="hljs-number">0x00007fff2c257db3</span> GraphicsServices`GSEventRunModal + <span class="hljs-number">139</span><br>    frame #<span class="hljs-number">8</span>: <span class="hljs-number">0x00007fff24696cf7</span> UIKitCore`-[UIApplication _run] + <span class="hljs-number">912</span><br>    frame #<span class="hljs-number">9</span>: <span class="hljs-number">0x00007fff2469bba8</span> UIKitCore`UIApplicationMain + <span class="hljs-number">101</span><br>    frame #<span class="hljs-number">10</span>: <span class="hljs-number">0x000000010740feb2</span> TestXX`<span class="hljs-built_in">main</span>(argc=<span class="hljs-number">1</span>, argv=<span class="hljs-number">0x00007ffee87efea8</span>) at main.m:<span class="hljs-number">17</span>:<span class="hljs-number">12</span><br>    frame #<span class="hljs-number">11</span>: <span class="hljs-number">0x00007fff2025a3e9</span> libdyld.dylib`start + <span class="hljs-number">1</span><br>    frame #<span class="hljs-number">12</span>: <span class="hljs-number">0x00007fff2025a3e9</span> libdyld.dylib`start + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h3 id="global-queue的任务调度-dispatch-worker-thread2"><a href="#global-queue的任务调度-dispatch-worker-thread2" class="headerlink" title="global queue的任务调度_dispatch_worker_thread2"></a>global queue的任务调度_dispatch_worker_thread2</h3><p>global queue通过_dispatch_queue_wakeup_global函数，将任务入queue，让后调用_dispatch_worker_thread2进行处理任务</p>
<p>在_dispatch_worker_thread2中有两个函数比较重要：</p>
<ul>
<li>_dispatch_queue_concurrent_drain_one</li>
<li>_dispatch_continuation_pop</li>
</ul>
<h4 id="dispatch-queue-concurrent-drain-one"><a href="#dispatch-queue-concurrent-drain-one" class="headerlink" title="_dispatch_queue_concurrent_drain_one"></a>_dispatch_queue_concurrent_drain_one</h4><p>该函数的重要作用：</p>
<ul>
<li>多线程下的边界处理</li>
<li>获取出队的dc</li>
<li>再次唤醒global queue<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_object_s</span> *<br>_dispatch_queue_concurrent_drain_one(<span class="hljs-type">dispatch_queue_t</span> dq) &#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_object_s</span> *head, *next, *<span class="hljs-type">const</span> mediator = (<span class="hljs-type">void</span> *)~<span class="hljs-number">0ul</span>;<br><br>	<span class="hljs-comment">// The mediator value acts both as a &quot;lock&quot; and a signal</span><br>	head = <span class="hljs-built_in">dispatch_atomic_xchg2o</span>(dq, dq_items_head, mediator);<br><br>	<span class="hljs-comment">// 1. 检查队列是否为空，是返回NULL</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(head == <span class="hljs-literal">NULL</span>)) &#123;<br>		(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_atomic_cmpxchg2o</span>(dq, dq_items_head, mediator, <span class="hljs-literal">NULL</span>);<br>		_dispatch_debug(<span class="hljs-string">&quot;no work on global work queue&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(head == mediator)) &#123;<br>		<span class="hljs-comment">// 该线程在现线程竞争中失去了对队列的拥有权，这意味着libdispatch的效率很糟糕，</span><br>		<span class="hljs-comment">// 这种情况意味着在线程池中有太多的线程，这个时候应该创建一个pengding线程，</span><br>		<span class="hljs-comment">// 然后退出该线程，内核会在负载减弱的时候创建一个新的线程</span><br>		_dispatch_debug(<span class="hljs-string">&quot;Contention on queue: %p&quot;</span>, dq);<br>		_dispatch_queue_wakeup_global(dq);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_PERF_MON</span><br>		<span class="hljs-built_in">dispatch_atomic_inc</span>(&amp;_dispatch_bad_ratio);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// 在返回之前将head指针的do_next保存下来，如果next为NULL，这意味着item是最后一个</span><br>	next = <span class="hljs-built_in">fastpath</span>(head-&gt;do_next);<br><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(!next)) &#123;<br>		dq-&gt;dq_items_head = <span class="hljs-literal">NULL</span>;<br><br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">dispatch_atomic_cmpxchg2o</span>(dq, dq_items_tail, head, <span class="hljs-literal">NULL</span>)) &#123;<br>			<span class="hljs-comment">// head和tail头尾指针均为空</span><br>			<span class="hljs-keyword">goto</span> out;<br>		&#125;<br><br>		<span class="hljs-comment">// 此时一定有item，该线程不会等待太久。</span><br>		<span class="hljs-keyword">while</span> (!(next = head-&gt;do_next)) &#123;<br>			_dispatch_hardware_pause();<br>		&#125;<br>	&#125;<br><br>	dq-&gt;dq_items_head = next;<br>	<span class="hljs-comment">// 再次唤醒全局队列</span><br>	_dispatch_queue_wakeup_global(dq);<br>out:<br>	<span class="hljs-comment">// 返回需要处理的dc</span><br>	<span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>
这里再次调用_dispatch_queue_wakeup_global,我们知道，并发queue中的dc执行是并发的，所以每次出队dc后检查下global queue，是否还有dc在queue中。如果有，在再次通知需要再创建一个work queue处理queue中剩余的dc，然后重复上面的步骤，类似递归。当多个work queue同时处理多个dc的时候，就是异步效果。</li>
</ul>
<h4 id="dispatch-continuation-pop"><a href="#dispatch-continuation-pop" class="headerlink" title="_dispatch_continuation_pop"></a>_dispatch_continuation_pop</h4><p>该函数实现了对任务处理，这些任务可能是异步任务、group任务、barrier任务甚至queue。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span><br>_dispatch_continuation_pop(<span class="hljs-type">dispatch_object_t</span> dou) &#123;<br>	<span class="hljs-type">dispatch_continuation_t</span> dc = dou._dc;<br>	<span class="hljs-type">dispatch_group_t</span> dg;<br><br>	_dispatch_trace_continuation_pop(_dispatch_queue_get_current(), dou);<br>	<span class="hljs-comment">// 检测是不是队列，如果是，就进入_dispatch_queue_invoke处理队列</span><br>	<span class="hljs-comment">// dispatch_barrier_async的任务会进入以下分支，以保证barrier任务和其他任务隔离，</span><br>	<span class="hljs-comment">// 并通过dispath_semaphore_t实现通知barrier任务执行</span><br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">DISPATCH_OBJ_IS_VTABLE</span>(dou._do)) &#123;<br>		<span class="hljs-keyword">return</span> _dispatch_queue_invoke(dou._dq);<br>	&#125;<br><br>	<span class="hljs-comment">// Add the item back to the cache before calling the function. This</span><br>	<span class="hljs-comment">// allows the &#x27;hot&#x27; continuation to be used for a quick callback.</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// The ccache version is per-thread.</span><br>	<span class="hljs-comment">// Therefore, the object has not been reused yet.</span><br>	<span class="hljs-comment">// This generates better assembly.</span><br>	<span class="hljs-comment">// 是否是异步任务</span><br>	<span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>)dc-&gt;do_vtable &amp; DISPATCH_OBJ_ASYNC_BIT) &#123;<br>		_dispatch_continuation_free(dc);<br>	&#125;<br>	<br>	<span class="hljs-comment">// 判断是否是group任务</span><br>	<span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>)dc-&gt;do_vtable &amp; DISPATCH_OBJ_GROUP_BIT) &#123;<br>		dg = dc-&gt;dc_group;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		dg = <span class="hljs-literal">NULL</span>;<br>	&#125;<br>	<br>	<span class="hljs-comment">// 是任务封装的dispatch_continuation_t结构体（dc），直接执行任务。</span><br>	<span class="hljs-comment">// 这也是异步的block被调用的时机</span><br>	_dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);<br>	<span class="hljs-keyword">if</span> (dg) &#123;<br>		<span class="hljs-comment">// 如果是group执行dispatch_group_leave</span><br>		<span class="hljs-built_in">dispatch_group_leave</span>(dg);<br>		_dispatch_release(dg);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="dispatch-queue-invoke"><a href="#dispatch-queue-invoke" class="headerlink" title="_dispatch_queue_invoke"></a>_dispatch_queue_invoke</h4><p>该函数用于异步处理任务，并且任务本身是queue时调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">void</span><br>_dispatch_queue_invoke(<span class="hljs-type">dispatch_queue_t</span> dq) &#123;<br>	<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">DISPATCH_OBJECT_SUSPENDED</span>(dq)) &amp;&amp;<br>			<span class="hljs-built_in">fastpath</span>(<span class="hljs-built_in">dispatch_atomic_cmpxchg2o</span>(dq, dq_running, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>))) &#123;<br>		<span class="hljs-built_in">dispatch_atomic_acquire_barrier</span>();<br>		<span class="hljs-type">dispatch_queue_t</span> otq = dq-&gt;do_targetq, tq = <span class="hljs-literal">NULL</span>;<br>		_dispatch_queue_drain(dq);<br>		<span class="hljs-keyword">if</span> (dq-&gt;do_vtable-&gt;do_invoke) &#123;<br>			<span class="hljs-comment">// Assume that object invoke checks it is executing on correct queue</span><br>			tq = <span class="hljs-built_in">dx_invoke</span>(dq);<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(otq != dq-&gt;do_targetq)) &#123;<br>			<span class="hljs-comment">// An item on the queue changed the target queue</span><br>			tq = dq-&gt;do_targetq;<br>		&#125;<br>		<span class="hljs-comment">// We do not need to check the result.</span><br>		<span class="hljs-comment">// When the suspend-count lock is dropped, then the check will happen.</span><br>		<span class="hljs-built_in">dispatch_atomic_release_barrier</span>();<br>		<span class="hljs-comment">//dq_running减1，因为任务要么被直接执行了，要么被压到target队列了</span><br>		(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_atomic_dec2o</span>(dq, dq_running);<br>		<span class="hljs-keyword">if</span> (tq) &#123;<br>			<span class="hljs-keyword">return</span> _dispatch_queue_push(tq, dq);<br>		&#125;<br>	&#125;<br><br>	dq-&gt;do_next = DISPATCH_OBJECT_LISTLESS;<br>	<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dispatch_atomic_sub2o</span>(dq, do_suspend_cnt,<br>			DISPATCH_OBJECT_SUSPEND_LOCK)) &#123;<br>		<span class="hljs-comment">// 队列处于空闲状态，需要唤醒</span><br>		<span class="hljs-keyword">if</span> (dq-&gt;dq_running == <span class="hljs-number">0</span>) &#123;<br>			_dispatch_wakeup(dq); <span class="hljs-comment">// verify that the queue is idle</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">// 释放队列</span><br>	_dispatch_release(dq); <span class="hljs-comment">// added when the queue is put on the list</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>整理下上述流程<br><img src="/../images/image-46.png" srcset="/img/loading.gif" lazyload alt="Alt text"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>queue和线程是多对1关系，一个线程上可以执行不同queue的任务，即使是主线程也如此，即主线程不仅能执行main queue的任务，也能执行其他queue的任务</li>
<li>queue操作与开启线程的关系<ul>
<li>串行queue+sync：任务在当前线程执行，并且等待之前任务执行，并且阻塞当前线程</li>
<li>串行queue+async：任务在新线程执行，不阻塞当前线程，任务在新线程上串行执行</li>
<li>并发queue+sync：任务在当前线程执行，阻塞当前线程</li>
<li>并发queue+async：开启多个线程，任务在新线程上执行，数量由系统决定，任务无序执行</li>
<li>主线程+main queue+sync：死锁，因为sync阻塞当前线程，主线程进入wait，此时调用sync的操作永远无法执行完毕，因为主线程永远不会被唤醒，从而死锁</li>
<li>main queue+async：任务在主线程串行执行</li>
</ul>
</li>
<li>queue的sync不具备开启线程能力，async才能开启新线程，串行&amp;并发决定了处理线程是否有多个</li>
<li>dispatch_queue通过struct和链表，实现为fifo的队列，无论串行queue还是并发queue，在调度时都是按顺序获取，主要区别在于：执行的顺序&amp;开启线程的数量</li>
<li>dispatch_sync:在当前线程执行，利用信号量实现串行</li>
<li>dispatch_async:<ul>
<li>若是main queue，则唤醒后执行runloop，然后调用gcd处理</li>
<li>若是其他queue：由线程池处理</li>
</ul>
</li>
<li>传递的block不是直接添加到queue上，而是封装为dispatch_continuation。dc包含了block还有上下文信息。queue会将dc添加链表中。无论queue是什么类型，最终的target都是global queue。在global queue执行block时，gcd从global queue取出dc，调用pthread_workqueue_additem_np，将该global queue自身，符合其优先级的workqueue和dc的回调函数进行传递。pthread_workqueue_additem_np函数使用workq_kernreturn系统调用，通知workqueue增加执行项目。而根据该通知，XNU kernel基于系统状态判断是否要生成线程，如果是overcommit的global queue，则始终生成线程。workqueue的新城执行pthread_workqueue函数，该函数调用gcd传递的回到函数，该函数中最终执行封装到dc中的block</li>
<li>gcd死锁是queue导致而不是线程导致，是因为_dispatch_barrier_sync_f_slow使用了线程对应的信号量，并进行wait，从而让线程等待，而又没有时机唤醒</li>
<li>关于barrier函数：<ul>
<li>dispatch_barrier_async的queue必须是由DISPATCH_QUEUE_CONCURRENT创建的queue</li>
<li>如果使用global queue，则表现的和dispatch_async一样</li>
<li>原因：<ul>
<li>若是global queue，则唤醒queue时执行_dispatch_queue_wakeup_global，则和dispatch_async一样</li>
<li>若是自定义queue：_dispatch_continuation_pop会执行dispatch_queue_invoke，在while循环中依次取出任务并调用_dispatch_continuation_redirect，使得任务并发执行；遇到DISPATCH_OBJ_BARRIER_BIT标记时，修改do_suspend_cnt保证后续while循环时直接go out。当barrier block的任务执行完，_dispatch_queue_class_invoke将do_suspend_cnt重置，允许barrier之后的任务执行</li>
</ul>
</li>
</ul>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/iOS/" class="print-no-link">#iOS</a>
      
        <a href="/tags/GCD/" class="print-no-link">#GCD</a>
      
        <a href="/tags/Dispatch-Queue/" class="print-no-link">#Dispatch Queue</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>深入理解GCD-Dispatch Queue</div>
      <div>https://nuko1993.github.io/2024/02/21/think-deep-in-gcd-dispatch-queue/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>nuko</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年2月21日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/02/28/think-deep-in-gcd-dispatch-seamphore/" title="深入理解GCD-Dispatch Semaphore">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">深入理解GCD-Dispatch Semaphore</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/02/20/think-about-oc-block-again/" title="再谈OC Block原理">
                        <span class="hidden-mobile">再谈OC Block原理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":300,"height":600},"mobile":{"show":false},"rect":"opacity:0.7","log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
