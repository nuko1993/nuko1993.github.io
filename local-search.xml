<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Swift进阶-可选值</title>
    <link href="/2023/12/20/swift-advance-optional-value/"/>
    <url>/2023/12/20/swift-advance-optional-value/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分主要介绍Swift中可选值的底层原理</p><h2 id="哨岗值"><a href="#哨岗值" class="headerlink" title="哨岗值"></a>哨岗值</h2><ul><li>在许多时候，函数在没有读取到有效值后需要返回给我们一个特定的值，称为哨岗值，比如EOF、-1、null等等</li><li>哨岗值有时是有效的值，比如-1，但有时候这种情况会导致错误的结果，比如OC对nil发消息，如果方法返回的是结构体，则会是一个值全部为0的结构体，这时有可能导致逻辑错误,eg<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">NSString *someString = ...;<br>if ([someString rangeOfString:@<span class="hljs-string">&quot;Swift&quot;</span>].<span class="hljs-keyword">location</span> <span class="hljs-title">!= NSNotFound</span>) &#123;<br>NSLog(@<span class="hljs-string">&quot;Someone mentioned Swift!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>如果someString是nil，location就会是0而不是NSNotFound（是NSIntegerMax），显然是错误的。</li><li>哨岗值还依赖约定，如果不知道约定，则无法使用。</li><li>Swift通过枚举实现Optional来解决哨岗值的问题,没错，可选值的本质实际就是带有关联值的Swift枚举<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">Optional</span>&lt;Wrapped&gt; &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">none</span><br><span class="hljs-keyword">case</span> some(Wrapped)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>Swift中对于可能是哨岗值的返回的都是可选值，从而避免了必须了解哨岗值约定的问题</li><li>语法糖使得使用可选值更加方便：<ul><li>Type? &#x3D; Optional<Type></li><li>nil &#x3D; .none(因为可选值遵守ExpressibleByNilLiteral协议，即可用nil表示)</li><li>在必要时，非可选值会自动封装为可选值，不需要手动调用.some(Type)，比如函数的返回类型标记为可选值类型</li></ul></li><li>可选值匹配：<ul><li>匹配值：switch .some(let v)或者swifth let v?</li><li>匹配nil：switch .none或者switch nil</li></ul></li></ul><h2 id="可选值概览"><a href="#可选值概览" class="headerlink" title="可选值概览"></a>可选值概览</h2><ul><li>if let:可选值绑定,略</li><li>while let:当遇到nil时终止</li><li>双重可选值：即Type??，实际就是Optional(Optional(value))<ul><li>case let v? &#x3D; case let .some(v)，仅匹配值</li></ul></li><li>case实际上的匹配功能很强大，比如 case 0..&lt;10 &#x3D; j可以检查j是否在范围内</li><li>if var&#x2F;while var:可变版本，使得我们在if语句中可以修改变量</li><li>在作用域之外使用解包后的值：使用guard let语句，其else路径必须是要求离开当前作用域，如return或者调用一个Never函数</li><li>返回Never（又称为无人类型）的函数向编译器表明自己绝对不会返回，如fatalError或者dispatchMain;又或者对应的值绝对不会出现，比如将泛型指定为Never</li><li>Never实际在Swift中就是个enum<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Never&#123;&#125;<br></code></pre></td></tr></table></figure></li><li>Never和Void是不同的，Void实际是空元祖()</li><li>总结，不存在是nil，存在且为空Void，绝对不会发生Never</li><li>在OC中，对nil发消息不会发生，在Swift中，使用可选链实现，如v?.callback(),<strong>可选链的调用结果一定是可选值</strong></li><li>对于可选值成员，默认值是nil，这是Swift中对于成员成员初始化的<strong>唯一例外</strong>。注意这个默认行为支队x?的形式有效，如果写成了Optional<T>就无效了，还是必须初始化</li><li>可选链和赋值：可以使用可选链来对可选值进行赋值，如<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span>: Int?<br>a?+=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>注意不能写成，因为可选值绑定对值类型来说是复制<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> a: <span class="hljs-built_in">Int</span>? = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">var</span> a = a &#123;<br>    <span class="hljs-comment">// 无法改变外层的a</span><br>    a+=<span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>nil合并操作符：??,略，注意??也是短路操作符</li><li>可选值提供了一个map方法，方便我们在不为nil的请款修改进行转换，注意因为是Optional本身提供的方法，所以调用的时候不能加?,eg.arr.first.map{…}（注意，只要是可选值，就可以调用该map方法，不要求可选值是集合类型！！），但是注意，即使如此，<strong>返回的仍然是可选值类型</strong></li><li>flatMap：如果变换本身返回了可选值类型，那么map得到的结果则是双重可选值，为了去掉一层，可以使用flatMap，注意可选值的类型上也是直接定义了flatMap</li><li>compactMap：可以将变换后为nil的可选值给筛掉</li><li>可选值判等：如果可选值封装的类型符合Equatable，则对应的可选值类型也是Equatable的，所以我们可以方便的判等：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> a: <span class="hljs-built_in">Int</span>? = <span class="hljs-number">0</span><br>a == <span class="hljs-number">0</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>这里work的原因是swift会在必要时将0升级为可选值</li><li>字典中如果直接设置key的value为nil会移除掉key和value，若要插入值nil，可以使用Optional(nil)</li><li>强制解包的使用：一般不要使用，除非预期是在遇到nil时直接crash</li><li>挂起操作的方式：fatalError直接crash、assert在测试版本不符合条件执行并且crash、precondtion和assert一样只不过在正式版也存在</li><li>隐式解包：标记为Type!的类型<ul><li>情景1：oc返回的类型，并且没有标记nullable和nonnull</li><li>情景2：暂时的为空，不如初始化的过程中</li><li>隐式可选值在使用上既可以假定为非可选值不加？，也可以当做可选值加？</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-内建集合类型</title>
    <link href="/2023/12/19/swift-advance-built-in-collection/"/>
    <url>/2023/12/19/swift-advance-built-in-collection/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>虽然在工作中已经大量使用了Swift了，但总感觉自己停留在使用的层面。从今天开始，开始复习Swift Adavance，回忆、理解、总结。</p><p>本章重点介绍了Swift内建的几种集合类型，并讨论如何高效使用。</p><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><ul><li>值语义： Swift中所有的内建集合类型都具有值语义，数组当然也不例外。值语义的典型表现是当其被赋值给一个变量时，将发生复制。</li><li>使用let和var来表示数组是不可变数组or可变数组。注意，即使是可变数组，仍然是值类型。这和NSMutableArray完全不同。</li><li>Swift编译器会对值语义集合进行优化，如果被赋值给对个变量，只有通过变量修改值时才会发生实际的copy，但我们不应依赖该行为。</li><li>数组越界会直接崩溃。</li><li>数组为空时，调用removeLast会崩溃，但popLast则不会崩溃，而是返回nil。</li><li>支持map、flatMap、filter等函数式编程。</li><li>使用.lazy将变形延迟发生到最终需要结果的时候，比如需要将结果转换为数组输出。</li><li>map：遍历元素，对每个元素应用func得到新集合。</li><li>filter: 遍历元素，删除掉符合func的元素得到新集合。</li><li>reduce: 遍历元素，对每个元素应用和之前的结果应用func得到结果值。</li><li>flatMap: 如果得到的结果外层是数组，则去掉结果外层数组。</li><li>forEach: 遍历元素，应用func但不返回结果。注意func中写return并不会使得遍历停止。</li><li>数组可以切片，类似于python，结果是ArraySlice。但是，<strong>切片完之后的索引和原始数组共享索引和内存</strong>！</li></ul><h2 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h2><ul><li>字典查找总是返回可选值，这和Array不同。</li><li>思想：Array中的索引一般总是通过某种方式计算得到的，一般都是有效的，无效的索引一般意味着开发者的计算失误。所以崩溃就好。但是Dict的key一般是其他取到得来的，比如server下发，所以返回可选值比较好。</li><li>删除值：将对应key的value设置为nil或者removeValue(forKey:),该方法返回删除的value,注意，这同时会将key也给删掉。</li><li>更新值：简单，设置即可，或者使用updateValue(_:forKey:),该方法会返回old value。</li><li>合并dict：merge(_:uniquingKeysWith:),第二个参数是决定决策对于相同的key使用如何获取value的函数，注意<strong>是获取value，而不是选择value</strong>，因为不仅可以选择某一个value，也可以对这两个value进行操作得到新的value。</li><li>mapValues: 对dict的values作map</li><li>Dict的key必须符合Hashable协议。<ul><li>标准库中所有基本数据类型都是Hashable的，如Int、String</li><li>数组、集合或可选值，如果其元素时Hashable，则他们也是Hashable</li><li>结构体和enum，如果是由Hashable的类型组成（对结构体来说，要求存储属性，对enum来说，要求关联值，若无关联值，则默认是Hashable的，不需要声明），只要我们声明他们是Hashable，则Swift会帮我们合成Hashable的实现</li><li>对于通过&#x3D;&#x3D;比较相等的两个对象，hash值必须相同，反之，hash值相同，不一定是相同的对象，因为hash值有限，但对象数量无限，可能存在hash冲突的可能。</li><li>所以一般不要使用可变对象作为key，否则如果对象改变造成hash改变，则会造成dict存储找不到或存储错误。</li></ul></li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul><li>嘛，就是集合</li><li>可以使用数组字面量初始化Set，因为Set遵守ExpressibleByArrayLiteral。</li><li>补集：substring</li><li>交集：intersection</li><li>并集：formUnion，这是union的可变版本，即改变原集合，所有以form开头的版本都是可变版本。</li></ul><h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><ul><li>就是区间</li><li>x..&lt;y左闭右开: Range，只有此类型可以表示空集，如5..&lt;5</li><li>x…y闭区间: ClosedRange,只有此类型可以表示最大值，如0…Int.max，因为Range需要上界是比自身包含的范围还得+1</li><li>Range和ClosedRange都有Bound泛型，Bound需要符合Comparable</li><li>x…，左闭右无界: PratialRangeFrom，可遍历，需自己break<ul><li>对于PartialRangeFrom遍历时，会从下界开始，调用adavanced(by:1)</li></ul></li><li>…y，左无界右闭：PartialRangeThrough，不可遍历</li><li>..&lt;y，左无界右开: PartialRangeUpTo，不可遍历</li><li>检测包含：contains、overlaps</li><li>Range可以遍历，但不能完全遍历emm…，支持遍历的<strong>Range的Bound</strong>需要实现Strideable协议。</li><li>Range必须是可数的才能遍历</li><li>Swift之前为了区分可数还是不可数，引入两个类型，即CountableRange和CountableClosedRange</li><li>所有的Range都满足RangeExpression协议<ul><li>contains：判断元素是否包含在范围中</li><li>relative：对给定集合，能够计算出该集合的Range。<strong>若该RangeExpression缺少上界或者下界，则返回的结果中使用给定集合的startIndex或endIndex作为上界或者下界</strong>。</li><li>所以数组可以使用Range进行切片，原理就是数组的subscript实现了接受RangeExpression作为参数，从而结合自身的startIndex和endIndex得到一个Range，从而执行切片</li></ul></li><li>RangeSet: 即Range的集合，在表示多个区间时更加高效</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo添加Live2D看板娘</title>
    <link href="/2023/12/03/hexo-add-live2d/"/>
    <url>/2023/12/03/hexo-add-live2d/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在浏览别人的blog时，有时可以看到一个类似于下面这个萌萌哒的玩意，这其实是通过Live2D Widget插件实现的。方法也很简单，follow me~<br><img src="/../images/image-19.png" alt="Alt text"></p><h2 id="Step1-安装live-2d插件"><a href="#Step1-安装live-2d插件" class="headerlink" title="Step1 安装live 2d插件"></a>Step1 安装live 2d插件</h2><p>注意，下面的指令都是在Hexo项目目录中使用的</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-helper-live2d</span><br></code></pre></td></tr></table></figure><h2 id="Step2-下载live-2d模型"><a href="#Step2-下载live-2d模型" class="headerlink" title="Step2 下载live 2d模型"></a>Step2 下载live 2d模型</h2><p>通过下载不同的live 2d模型，就可以获得不同的看板娘啦，直接npm下载，贼方便</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">// 下载的model会存放在node_modules中</span><br>npm install live2d-widget-<span class="hljs-keyword">model</span>-tororo<br></code></pre></td></tr></table></figure><h2 id="Step3-配置-config-yml"><a href="#Step3-配置-config-yml" class="headerlink" title="Step3 配置_config.yml"></a>Step3 配置_config.yml</h2><p>添加如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Live2D看板娘</span><br><span class="hljs-attr">live2d:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">pluginModelPath:</span> <span class="hljs-string">assets/</span><br>  <span class="hljs-attr">model:</span><br>    <span class="hljs-comment">#模板目录，在node_modules里</span><br>    <span class="hljs-attr">use:</span> <span class="hljs-string">live2d-widget-model-tororo</span><br>  <span class="hljs-attr">display:</span><br>    <span class="hljs-attr">position:</span> <span class="hljs-string">right</span><br>    <span class="hljs-attr">width:</span> <span class="hljs-number">300</span> <br>    <span class="hljs-attr">height:</span> <span class="hljs-number">600</span><br>  <span class="hljs-attr">mobile:</span><br>    <span class="hljs-comment"># 在手机端显示</span><br>    <span class="hljs-attr">show:</span> <span class="hljs-literal">false</span>   <br>  <span class="hljs-attr">rect:</span><br>    <span class="hljs-string">opacity:0.7</span><br></code></pre></td></tr></table></figure><h2 id="Step4-查看效果"><a href="#Step4-查看效果" class="headerlink" title="Step4 查看效果"></a>Step4 查看效果</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">hexo g <span class="hljs-meta">&amp;&amp; hexo s</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何让Hexo被Google索引到</title>
    <link href="/2023/12/03/about-hexo-google-index/"/>
    <url>/2023/12/03/about-hexo-google-index/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们写blog的目的是让自己的分享被别人看到，如果Google没有收录自己的网址，那么就没有意义了。 本篇文章主要介绍如何让咱们的blog被Google收录。</p><h2 id="Step1-检查收录"><a href="#Step1-检查收录" class="headerlink" title="Step1 检查收录"></a>Step1 检查收录</h2><p>首先检查咱们的blog有没有被Google索引，在搜索框输入site:xxx.github.io，不出意外的话，Google没有收录：<br><img src="/../images/image-13.png" alt="Alt text"></p><h2 id="Step2-验证网址所有权"><a href="#Step2-验证网址所有权" class="headerlink" title="Step2 验证网址所有权"></a>Step2 验证网址所有权</h2><p>按照提示，点击进入Google Search Console，Google会要求验证这个网址的归属权，这里由于采用的GitHub Page，所以按照第二种网址前缀的方式进行验证：<br><img src="/../images/image-14.png" alt="Alt text"><br>接下来，会看到有几种验证的方式，因为不想添加一个乱七八糟的html到网站目录中（强迫症犯了QAQ），所以我选择HTML标记的方式。这种方式会要求我们在index.html的head标签中添加一个meta标签，按照提示复制该标签。<br><img src="/../images/image-15.png" alt="Alt text"><br>接下来，找到Hexo项目的public文件夹下的index.html，将这个标签复制到head标签的末尾。<br><img src="/../images/image-16.png" alt="Alt text"><br>顺便说下，Hexo在部署的就是public文件夹下的内容。<br>我们直接发布，<strong>注意不要generate</strong>，因为generate会重新生成index.html，会将咱们之前的修改给覆盖掉。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">// 直接发布即可</span><br>hexo d<br></code></pre></td></tr></table></figure><p>发布完成之后，稍等1min左右，等待GitHub Page部署完成，点击验证按钮。Congratulations，验证完成~~~<br><img src="/../images/image-17.png" alt="Alt text"></p><h2 id="Step3-添加sitemap-xml"><a href="#Step3-添加sitemap-xml" class="headerlink" title="Step3 添加sitemap.xml"></a>Step3 添加sitemap.xml</h2><p>到上面其实Google已经允许收录咱们的blog了，但是为了Google的蜘蛛机器人更好的爬取到网站的内容，我们可以在网站根目录下放一个sitemap.xml。<br>进入到Hexo项目目录中，安装插件：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-generator-sitemap <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>安装完毕之后，打开_config.yml，添加如下内容</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"># automatically <span class="hljs-keyword">generate</span> sitemap<br>sitemap:<br>  path: sitemap<span class="hljs-variable">.xml</span><br></code></pre></td></tr></table></figure><p>重新生成部署，不再啰嗦啦，hexo g -d一把梭。<br>等待1min。进入到Google Search Console，提交我们的sitemap.xml，如下图，OK收工。<br>但我们这个时候再搜索还是搜不到的，需要等个几天，到时候再来更新~<br><img src="/../images/image-18.png" alt="Alt text"></p><hr><p>12月9日更新，已经可以被索引到了~<br><img src="/../images/image-20.png" alt="Alt text"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Hexo中图片路径问题</title>
    <link href="/2023/12/03/about-hexo-picture-path/"/>
    <url>/2023/12/03/about-hexo-picture-path/</url>
    
    <content type="html"><![CDATA[<p>在编写Hexo时，通常需要粘贴图片到markdown中。默认粘贴的path和咱们的md文件同级别，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![Alt text](image-9.png)</span><br></pre></td></tr></table></figure><p>虽然本地预览没有问题，但是在generate的时候，存在两个问题：<br>1.Hexo会忽略_post下的图片资源<br>2.Hexo会将md文件中的path转换为域名&#x2F;path，例如<a href="http://xxx.github.io/xxx.png">http://xxx.github.io/xxx.png</a><br>这两个问题都会导致无法正常看到我们blog中的图片。  </p><p>问题解决：<br>1.在source下新建images文件夹，专门用来存放图片<br>2.Hexo中使用images&#x2F;xxx.png来引用该图片</p><p>那么还是有问题，在使用VS Code粘贴图片时，还是默认粘贴到_posts下面，这样每次都要移动图片和修改路径，很麻烦。没错，贴心的VS Code可以自定义粘贴的路径，使用cmd+,打开设置，找到如下界面设置默认的粘贴路径：<br><img src="/../images/image-10.png" alt="Alt text"><br>完成！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo的安装与部署</title>
    <link href="/2023/12/03/hexo-install-and-deploy/"/>
    <url>/2023/12/03/hexo-install-and-deploy/</url>
    
    <content type="html"><![CDATA[<p>一时间还没想好要写哪些东西，万事开头难嘛，既然这样，咱就先记录下烂大街的Hexo安装与部署吧。</p><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>我们可以将我们的blog理解成一个app，Hexo项目就是这个app的框架工程源码，通过Node.js进行编译打包，最终生成产品发布到GitHub上被人查看使用。</p><h1 id="安装Git-注册GitHub账号"><a href="#安装Git-注册GitHub账号" class="headerlink" title="安装Git&amp;注册GitHub账号"></a>安装Git&amp;注册GitHub账号</h1><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>传送门：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a><br>作用：用于管理Hexo生成的文件，对接GitHub</p><h2 id="注册GitHub账号"><a href="#注册GitHub账号" class="headerlink" title="注册GitHub账号"></a>注册GitHub账号</h2><p>传送门：<a href="https://github.com/">https://github.com/</a><br>作用：托管Hexo生成的文件，并提供GitHub Page服务，让blog可以被别人浏览  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 校验安装</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure><h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><p>传送门：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a><br>Node.js是一个跨平台的基于Chrome V8引擎的JavaScript运行环境，它可以让JS脚本可以脱离浏览器执行。这么说如果还是不太理解的话，把他理解成Python就可以<br>为啥需要Node.js呢，有两个原因：</p><ul><li>Hexo是基于Node.js作为构建系统来生成网页</li><li>Hexo可以使用npm来下载安装</li><li>等等，这里npm又是啥？别慌，npm是Node.js的包管理器，理解成pip之于Python。最近的Node.js在安装的时候已经会一起安装npm了</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 校验安装</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><h1 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h1><p>使用npm进行安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// -g参数表示将hexo-cli作为全局(global)包安装，hexo-cli中的二进制文件加入到PATH中，方便终端调用hexo命令</span><br><span class="line">// 全局安装还可以使得在创建其他Node.js项目的时候也方便引用到</span><br><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h1 id="创建Hexo项目"><a href="#创建Hexo项目" class="headerlink" title="创建Hexo项目"></a>创建Hexo项目</h1><p>1.在你喜欢的地方创建一个文件夹，例如桌面上，就叫做hexo_blog吧<br>2.cd到该目录<br>3.执行命令，创建Hexo项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 创建Hexo项目</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>4.执行命令，在本地生成网页产物</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 生成网页产物</span><br><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>5.执行命令，启动本地服务器查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 启动本地server</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>6.在浏览器中打开 <a href="http://localhost:4000/">http://localhost:4000/</a> 查看效果<br>不出意外的话，恭喜，已经曙光初现了，接下来就是将我们的blog发布到GitHub Page上供别人浏览了</p><h1 id="部署到GitHub-Page"><a href="#部署到GitHub-Page" class="headerlink" title="部署到GitHub Page"></a>部署到GitHub Page</h1><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>之前我们创建了GitHub账号，我们新建一个仓库<br><img src="/../images/image.png" alt="Alt text"><br><img src="/../images/image-1.png" alt="Alt text"></p><h2 id="配置SSH密钥"><a href="#配置SSH密钥" class="headerlink" title="配置SSH密钥"></a>配置SSH密钥</h2><p>等等，啥是SSH，啥是密钥？我们要把本地的Hexo产物文件push到GitHub，是通过ssh的方式。那GitHub肯定需要鉴权把。鉴权我们可以使用账号密码，但是如果每次push都要输入账号密码，那想想都很痛苦。<br>那有没有更加轻松的方式呢？GitHub很贴心的为你想好啦，我们只要把我们的设备添加到GitHub的信任名单中，那就不用每次都输入账号密码了，so easy!<br>那么，GitHub是怎么信任咱们的设备呢，它需要一个凭证，这个凭证就是SSH密钥。通过SSH密钥能够唯一标识请求来自于这台设备。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 生成ssh密钥，引号中的内容是注释，可以写我们自己的邮箱账号</span><br><span class="line">// 一路回车即可，记录下保存密钥的文件，例如~/.ssh/id_rsa，对应的公钥就是~/.ssh/id_rsa.pub</span><br><span class="line">ssh-keygen -t rsa -C &quot;your email@example.com&quot;</span><br></pre></td></tr></table></figure><p>查看公钥并复制到剪切板中，然后按找到下面的位置将公钥粘贴进去<br><img src="/../images/image-2.png" alt="Alt text"><br><img src="/../images/image-3.png" alt="Alt text"><br><img src="/../images/image-4.png" alt="Alt text"><br><img src="/../images/image-5.png" alt="Alt text"><br>测试下添加是否成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 当出现提示时回车即可</span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><h2 id="配置Git个人信息"><a href="#配置Git个人信息" class="headerlink" title="配置Git个人信息"></a>配置Git个人信息</h2><p>上面的ssh密钥只是前提条件，GitHub在我们push文件时还会根据邮箱和用户名做校验，因而需要设置下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;此处填你的用户名&quot;</span><br><span class="line">git config --global user.email &quot;此处填你的邮箱&quot;</span><br></pre></td></tr></table></figure><h2 id="将Hexo部署到GitHub-Page"><a href="#将Hexo部署到GitHub-Page" class="headerlink" title="将Hexo部署到GitHub Page"></a>将Hexo部署到GitHub Page</h2><p>首先，回到我们之前在GitHub上创建的仓库，复制我们仓库的ssh地址<br><img src="/../images/image-6.png" alt="Alt text"><br>打开我们创建的Hexo项目中的_config.yml文件(推荐Visual Studio Code，后续写blog也很方便)，找到如下入位置进行修改<br><img src="/../images/image-12.png" alt="Alt text"><br><img src="/../images/image-11.png" alt="Alt text"></p><p><strong>敲黑板！！注意branch不要填入master，要填入main。</strong> 分支填错会就看不到了页面了，GitHub Page使用默认分支部署。不知道啥时候开始，GitHub为了zzzq把默认分支的名称从master修改为main了QAQ  </p><p>我们还需要安装一个hexo部署到git的插件来完成最终部署，进入到我们之前创建的Hexo项目目录中，执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这里--save是将该插件添加到Hexo项目的依赖中，记录到package.json</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>最后一步，激动人心的时刻就要到了，执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>完成之后，访问user_name.github.io（user_name替换成你自己的GitHub账号名称），我们就可以看到我们的blog啦，完结撒花~~~~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第一篇正式的blog</title>
    <link href="/2023/12/03/first_blog/"/>
    <url>/2023/12/03/first_blog/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到我的blog，从今天起，开始正式坚持写blog，记录下工作生活中遇到的一些问题，同时也希望分享一些有价值的经验。<br>作为一个曾经幻想着推动人类文明进步的孩子，到现在休息日只想躺着的废柴，终究还是被现实磨平了棱角。<br>那至少，希望用技术创造一些有价值的东西吧。<br>emmm，虽然也很难就是了，但梦想还是要有的嘛，万一呢</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/12/03/hello-world/"/>
    <url>/2023/12/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
