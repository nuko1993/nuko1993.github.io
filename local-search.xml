<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>iOS-内存大小相关计算</title>
    <link href="/2024/03/11/ios-oc-memory-size/"/>
    <url>/2024/03/11/ios-oc-memory-size/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要介绍OC中计算类占用大小的方法</p><p>测试代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-keyword">struct</span> A &#123;<br>&#125; TestA;<br><br><span class="hljs-keyword">struct</span> AA &#123;<br>    <span class="hljs-type">char</span> a;<br>&#125; TestAA;<br><br><span class="hljs-keyword">struct</span> AAA &#123;<br>    <span class="hljs-type">char</span> a;<br>    <span class="hljs-type">int</span> b;<br>&#125; TestAAA;<br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span>: <span class="hljs-title">NSObject</span> </span>&#123;<br>    <span class="hljs-type">int</span> _a;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Person</span></span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Student1</span>: <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-type">int</span> _b;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Student1</span></span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Student2</span>: <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-type">int</span> _b;<br>    <span class="hljs-type">int</span> _c;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Student2</span></span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">// 测试</span><br>+ (<span class="hljs-type">void</span>)test &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;TestA sizeof: %lu&quot;</span>,<span class="hljs-keyword">sizeof</span>(TestA));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;TestAA sizeof: %lu&quot;</span>,<span class="hljs-keyword">sizeof</span>(TestAA));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;TestAAA sizeof: %lu&quot;</span>,<span class="hljs-keyword">sizeof</span>(TestAAA));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;--------------------------------------&quot;</span>);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;NSObject class_getInstanceSize = %zd&quot;</span>, class_getInstanceSize([<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>]));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;NSObject malloc_size = %zd&quot;</span>, malloc_size((__bridge <span class="hljs-keyword">const</span> <span class="hljs-type">void</span>*)[<span class="hljs-built_in">NSObject</span> new]));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;--------------------------------------&quot;</span>);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Person class_getInstanceSize = %zd&quot;</span>, class_getInstanceSize([Person <span class="hljs-keyword">class</span>]));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Person malloc_size = %zd&quot;</span>, malloc_size((__bridge <span class="hljs-keyword">const</span> <span class="hljs-type">void</span>*)[Person new]));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;--------------------------------------&quot;</span>);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Student1 class_getInstanceSize = %zd&quot;</span>, class_getInstanceSize([Student1 <span class="hljs-keyword">class</span>]));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Student1 malloc_size = %zd&quot;</span>, malloc_size((__bridge <span class="hljs-keyword">const</span> <span class="hljs-type">void</span>*)[Student1 new]));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Student1 sizeof = %zd&quot;</span>, <span class="hljs-keyword">sizeof</span>([Student1 <span class="hljs-keyword">class</span>]));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;--------------------------------------&quot;</span>);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Student2 class_getInstanceSize = %zd&quot;</span>, class_getInstanceSize([Student2 <span class="hljs-keyword">class</span>]));<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Student2 malloc_size = %zd&quot;</span>, malloc_size((__bridge <span class="hljs-keyword">const</span> <span class="hljs-type">void</span>*)[Student2 new]));<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果（模拟器）<br><img src="/../images/image-66.png" alt="alt text"></p><p>其中class_getInstanceSize是指成员变量占用的内存大小，malloc_size是指针指向的内存空间的大小（即实际分配的大小）</p><p>内存大小的计算主要依赖于运行环境和内存对齐。</p><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><ul><li>内存对齐主要是为了提高CPU寻址性能</li><li>可以通过#pragma pack(n)来修改，其中n&#x3D;1,2,4,8,16,n就是对齐系数</li><li>内存对齐规则：<ul><li>数据成员对齐：struct或union的第一个成员在偏移为0的位置，以后每个数据的成员位置为min(对齐系数，自身长度)的<strong>整数倍</strong></li><li>数据成员为struct：以该struct内的最大长度的整数倍的位置开始存储</li><li>整体对齐规则：按照1、2对齐后，自身大小也要对齐，对齐原则是min(对齐系数,数据成员最大长度)的<strong>整数倍</strong></li></ul></li><li>内存对齐计算：<br>在64bit编译器环境下：</li></ul><p>实例1：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-comment">// 对齐系数为8</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(8)</span><br><span class="hljs-keyword">struct</span> AA &#123;<br>    <span class="hljs-type">int</span> a;   <span class="hljs-comment">// 4字节</span><br>    <span class="hljs-type">char</span> b;  <span class="hljs-comment">// 1字节</span><br>    <span class="hljs-type">short</span> c; <span class="hljs-comment">// 2字节</span><br>    <span class="hljs-type">char</span> d;  <span class="hljs-comment">// 1字节</span><br>&#125; Test1AA;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()</span><br><br><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[]) &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123; <br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Test1AA: %lu&quot;</span>,<span class="hljs-keyword">sizeof</span>(Test1AA));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出12，计算过程<br><img src="/../images/image-67.png" alt="alt text"></p><p>实例2：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(8)</span><br><span class="hljs-keyword">struct</span> AA &#123;<br>    <span class="hljs-type">char</span> a[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">short</span> b;<br>    <span class="hljs-keyword">struct</span> BB &#123;<br>        <span class="hljs-type">int</span> a;<br>        <span class="hljs-type">double</span> b;<br>        <span class="hljs-type">float</span> c;<br>    &#125; Test2BB;<br>&#125; Test2AA;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()</span><br><br><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[]) &#123;<br>    <br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Test2AA: %lu&quot;</span>,<span class="hljs-keyword">sizeof</span>(Test2AA));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出为32。<br><img src="/../images/image-68.png" alt="alt text"></p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Memory Size</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS-Autorelease Pool</title>
    <link href="/2024/03/11/ios-oc-autorelasepool/"/>
    <url>/2024/03/11/ios-oc-autorelasepool/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前已经学习过iOS中的autorelease pool，这里再回忆下。</p><ul><li>在MRC中，手动调用[obj autorelease]来延迟对象向内存释放</li><li>在ARC中，调用auotorelease方法，会将其添加到最近的pool，当pool被销毁时才执行release</li></ul><h2 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h2><p>在main.m中一般是这样</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[]) &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">UIApplicationMain</span>(argc, argv, <span class="hljs-literal">nil</span>, <span class="hljs-built_in">NSStringFromClass</span>([AppDelegate <span class="hljs-keyword">class</span>]));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span> </span>&#123;<br>    <span class="hljs-comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">UIApplicationMain</span>(argc, argv, __null, <span class="hljs-built_in">NSStringFromClass</span>(((<span class="hljs-built_in">Class</span> (*)(id, SEL))(<span class="hljs-type">void</span> *)objc_msgSend)((id)<span class="hljs-built_in">objc_getClass</span>(<span class="hljs-string">&quot;AppDelegate&quot;</span>), <span class="hljs-built_in">sel_registerName</span>(<span class="hljs-string">&quot;class&quot;</span>))));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，@autoreleasepool实际就是 __AtAutoreleasePool __autoreleasepool。__AtAutoreleasePool是个struct，其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__AtAutoreleasePool</span> &#123;<br>  __AtAutoreleasePool() &#123;atautoreleasepoolobj = <span class="hljs-built_in">objc_autoreleasePoolPush</span>();&#125;<br>  ~__AtAutoreleasePool() &#123;<span class="hljs-built_in">objc_autoreleasePoolPop</span>(atautoreleasepoolobj);&#125;<br>  <span class="hljs-type">void</span> * atautoreleasepoolobj;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可见，pool的创建与销毁绑定了push和pop，从而实现自动释放。方法定义在NSObject.mm中，分别是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">objc_autoreleasePoolPush</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> AutoreleasePoolPage::<span class="hljs-built_in">push</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">objc_autoreleasePoolPop</span><span class="hljs-params">(<span class="hljs-type">void</span> *ctxt)</span> </span>&#123;<br>    AutoreleasePoolPage::<span class="hljs-built_in">pop</span>(ctxt);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，实际是调用了AutoreleasePoolPage的类方法，push和pop。</p><h2 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h2><p>在NSObject.mm中，定义了page：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoreleasePoolPage</span> &#123;<br>    <span class="hljs-comment">// SIZE是AutoreleasePoolPage的大小，4096个字节</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">size_t</span> <span class="hljs-type">const</span> SIZE = PAGE_MAX_SIZE;<br>    <span class="hljs-comment">// autoreleasepool完整性校验</span><br>    <span class="hljs-type">magic_t</span> <span class="hljs-type">const</span> magic; <br>    <span class="hljs-comment">// 单个AutoreleasePoolPage节点是一个链表，next指向栈顶的最新的autorelease对象的下一个位置</span><br>    id *next;<br>    <span class="hljs-comment">// 当前所在的线程</span><br>    <span class="hljs-type">pthread_t</span> <span class="hljs-type">const</span> thread;<br>    <span class="hljs-comment">// 指针，指向前一个AutoreleasePoolPage节点</span><br>    AutoreleasePoolPage * <span class="hljs-type">const</span> parent;<br>    <span class="hljs-comment">// 指针，指向后一个AutoreleasePoolPage节点</span><br>    AutoreleasePoolPage *child;<br>    <span class="hljs-comment">// 深度</span><br>    <span class="hljs-type">uint32_t</span> <span class="hljs-type">const</span> depth;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过源码可以知道：</p><ul><li>pool并没有特定的内存结构，它本质是以page为节点的双向链表</li><li>每个page是一个栈结构，大小为4kb</li></ul><p>pool的结构如图所示：<br><img src="/../images/image-63.png" alt="alt text"></p><p>看下page的构造函数以及方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">AutoreleasePoolPage</span>(AutoreleasePoolPage *newParent)<br>: <span class="hljs-built_in">magic</span>(), <span class="hljs-built_in">next</span>(<span class="hljs-built_in">begin</span>()), <span class="hljs-built_in">thread</span>(<span class="hljs-built_in">pthread_self</span>()),<br><span class="hljs-built_in">parent</span>(newParent), <span class="hljs-built_in">child</span>(nil),<br><span class="hljs-built_in">depth</span>(parent ? <span class="hljs-number">1</span>+parent-&gt;depth : <span class="hljs-number">0</span>),<br><span class="hljs-built_in">hiwat</span>(parent ? parent-&gt;hiwat : <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (parent) &#123;<br>        parent-&gt;<span class="hljs-built_in">check</span>();<br>        <span class="hljs-built_in">assert</span>(!parent-&gt;child);<br>        parent-&gt;<span class="hljs-built_in">unprotect</span>();<br>        parent-&gt;child = <span class="hljs-keyword">this</span>;<br>        parent-&gt;<span class="hljs-built_in">protect</span>();<br>    &#125;<br>    <span class="hljs-built_in">protect</span>();<br>&#125;<br><br><span class="hljs-comment">// 一个AutoreleasePoolPage节点开始存autorelease对象的位置</span><br><span class="hljs-function">id *<span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (id *) ((<span class="hljs-type">uint8_t</span> *)<span class="hljs-keyword">this</span>+<span class="hljs-built_in">sizeof</span>(*<span class="hljs-keyword">this</span>));<br>&#125;<br><br><span class="hljs-comment">// 一个AutoreleasePoolPage节点最大的位置</span><br><span class="hljs-function">id *<span class="hljs-title">end</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (id *) ((<span class="hljs-type">uint8_t</span> *)<span class="hljs-keyword">this</span>+SIZE);<br>&#125;<br><br><span class="hljs-comment">// AutoreleasePoolPage节点是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> next == <span class="hljs-built_in">begin</span>();<br>&#125;<br><br><span class="hljs-comment">// AutoreleasePoolPage节点是否满</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">full</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> next == <span class="hljs-built_in">end</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lessThanHalfFull</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (next - <span class="hljs-built_in">begin</span>() &lt; (<span class="hljs-built_in">end</span>() - <span class="hljs-built_in">begin</span>()) / <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-comment">// 添加一个autorelease对象，next指向下一个存对象的地址</span><br><span class="hljs-function">id *<span class="hljs-title">add</span><span class="hljs-params">(id obj)</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(!<span class="hljs-built_in">full</span>());<br>    <span class="hljs-built_in">unprotect</span>();<br>    id *ret = next;  <span class="hljs-comment">// faster than `return next-1` because of aliasing</span><br>    *next++ = obj;<br>    <span class="hljs-built_in">protect</span>();<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">// 释放AutoreleasePoolPage节点所有存储的对象</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">releaseAll</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">releaseUntil</span>(<span class="hljs-built_in">begin</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，一个空的page结构如下：<br><img src="/../images/image-64.png" alt="alt text"></p><h2 id="AutoreleasePoolPage-push"><a href="#AutoreleasePoolPage-push" class="headerlink" title="AutoreleasePoolPage::push()"></a>AutoreleasePoolPage::push()</h2><p>push代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title">push</span><span class="hljs-params">()</span> </span>&#123;<br>    id *dest;<br>    <span class="hljs-keyword">if</span> (DebugPoolAllocation) &#123;<br>        <span class="hljs-comment">// Each autorelease pool starts on a new pool page.</span><br>        dest = <span class="hljs-built_in">autoreleaseNewPage</span>(POOL_BOUNDARY);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        dest = <span class="hljs-built_in">autoreleaseFast</span>(POOL_BOUNDARY);<br>    &#125;<br>    <span class="hljs-built_in">assert</span>(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);<br>    <span class="hljs-keyword">return</span> dest;<br>&#125;<br></code></pre></td></tr></table></figure><p>push的时候回先进行判断，如果需要每个pool都生成一个新page，则调用autoreleaseNewPage，否则调用autoreleaseFast。</p><p><strong>autoreleaseNewPage</strong><br>源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> __attribute__((noinline)) <span class="hljs-function">id *<span class="hljs-title">autoreleaseNewPage</span><span class="hljs-params">(id obj)</span> </span>&#123;<br>    AutoreleasePoolPage *page = <span class="hljs-built_in">hotPage</span>();<br>    <span class="hljs-keyword">if</span> (page) <span class="hljs-keyword">return</span> <span class="hljs-built_in">autoreleaseFullPage</span>(obj, page);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">autoreleaseNoPage</span>(obj);<br>&#125;<br></code></pre></td></tr></table></figure><p>分两种case：</p><ul><li>当前存在page，执行autoreleaseFullPage</li><li>当前不存在page，调用autoreleaseNoPage</li></ul><p><strong>autoreleaseFast</strong><br>源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> id *<span class="hljs-title">autoreleaseFast</span><span class="hljs-params">(id obj)</span> </span>&#123;<br>    AutoreleasePoolPage *page = <span class="hljs-built_in">hotPage</span>();<br>    <span class="hljs-keyword">if</span> (page &amp;&amp; !page-&gt;<span class="hljs-built_in">full</span>()) &#123;<br>        <span class="hljs-keyword">return</span> page-&gt;<span class="hljs-built_in">add</span>(obj);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (page) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">autoreleaseFullPage</span>(obj, page);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">autoreleaseNoPage</span>(obj);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分三种case：</p><ul><li>存在page，但未满，通过add方法将对象添加到page中</li><li>存在page但page已满，执行autoreleaseFullPage</li><li>不存在page，调用autoreleaseNoPage</li></ul><p><strong>hotPage</strong><br>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> AutoreleasePoolPage *<span class="hljs-title">hotPage</span><span class="hljs-params">()</span> </span>&#123;<br>    AutoreleasePoolPage *result = (AutoreleasePoolPage *)<br>    <span class="hljs-built_in">tls_get_direct</span>(key);<br>    <span class="hljs-keyword">if</span> ((id *)result == EMPTY_POOL_PLACEHOLDER) <span class="hljs-keyword">return</span> nil;<br>    <span class="hljs-keyword">if</span> (result) result-&gt;<span class="hljs-built_in">fastcheck</span>();<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过上面代码我们知道当前page是存在于TLS中（即线程私有数据），当第一次调用push的时候，没有page，hotPage自然也取不到。</p><p><strong>autoreleaseFullPage</strong><br>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> __attribute__((noinline)) <br><span class="hljs-function">id *<span class="hljs-title">autoreleaseFullPage</span><span class="hljs-params">(id obj, AutoreleasePoolPage *page)</span> </span>&#123;<br>    <span class="hljs-comment">// The hot page is full. </span><br>    <span class="hljs-comment">// Step to the next non-full page, adding a new page if necessary.</span><br>    <span class="hljs-comment">// Then add the object to that page.</span><br>    <span class="hljs-built_in">assert</span>(page == <span class="hljs-built_in">hotPage</span>());<br>    <span class="hljs-built_in">assert</span>(page -&gt; <span class="hljs-built_in">full</span>() || DebugPoolAllocation);<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">if</span> (page -&gt; child) page = page -&gt; child;<br>        <span class="hljs-keyword">else</span> page = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AutoreleasePoolPage</span>(page);<br>    &#125; <span class="hljs-keyword">while</span> (page -&gt; <span class="hljs-built_in">full</span>());<br><br>    <span class="hljs-built_in">setHotPage</span>(page);<br>    <span class="hljs-keyword">return</span> page -&gt; <span class="hljs-built_in">add</span>(obj);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数从传入的page开始遍历双线链表，若当前page满了，则查找child节点，直到找到一个未满的page。若最后找不到，则创建一个新的page。</p><p>再找到可用page之后，将该page标记为hotPage，然后调用add将对象添加到该page中</p><p><strong>autoreleaseNoPage</strong><br>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> __attribute__((noinline))<br><span class="hljs-function">id *<span class="hljs-title">autoreleaseNoPage</span><span class="hljs-params">(id obj)</span> </span>&#123;<br>    <span class="hljs-comment">// &quot;no page&quot;意味着没有没有池子被push或者说push了一个空的池子</span><br>    <span class="hljs-built_in">assert</span>(!<span class="hljs-built_in">hotPage</span>());<br><br>    <span class="hljs-type">bool</span> pushExtraBoundary = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// push了一个空的池子</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">haveEmptyPoolPlaceholder</span>()) &#123;<br>        pushExtraBoundary = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obj != POOL_BOUNDARY  &amp;&amp;  DebugMissingPools) &#123;<br>        _objc_inform(<span class="hljs-string">&quot;MISSING POOLS: (%p) Object %p of class %s &quot;</span><br>        <span class="hljs-string">&quot;autoreleased with no pool in place - &quot;</span><br>        <span class="hljs-string">&quot;just leaking - break on &quot;</span><br>        <span class="hljs-string">&quot;objc_autoreleaseNoPool() to debug&quot;</span>,<br>        <span class="hljs-built_in">pthread_self</span>(), (<span class="hljs-type">void</span>*)obj, <span class="hljs-built_in">object_getClassName</span>(obj));<br>        <span class="hljs-built_in">objc_autoreleaseNoPool</span>(obj);<br>        <span class="hljs-keyword">return</span> nil;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obj == POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation) &#123;<br>        <span class="hljs-comment">// 没有池子被push</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">setEmptyPoolPlaceholder</span>();<br>    &#125;<br><br>    AutoreleasePoolPage *page = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AutoreleasePoolPage</span>(nil);<br>    <span class="hljs-built_in">setHotPage</span>(page);<br><br>    <span class="hljs-keyword">if</span> (pushExtraBoundary) &#123;<br>        <span class="hljs-comment">// push了一个空的池子，添加哨兵对象</span><br>        page-&gt;<span class="hljs-built_in">add</span>(POOL_BOUNDARY);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> page-&gt;<span class="hljs-built_in">add</span>(obj);<br>&#125;<br><br><span class="hljs-comment">// haveEmptyPoolPlaceholder函数的实现</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">haveEmptyPoolPlaceholder</span><span class="hljs-params">()</span> </span>&#123;<br>    id *tls = (id *)<span class="hljs-built_in">tls_get_direct</span>(key);<br>    <span class="hljs-keyword">return</span> (tls == EMPTY_POOL_PLACEHOLDER);<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面代码中可以看出，若当前内存不存在page，就要从头开始构建这个pool的双向链表。也就是说，新的page是没有parent之子很的。初始化之后，将当前page标记为hotpage，然后向该page添加一个POOL_BOUNDARY的标记，确保在pop调用的时候，不会出现异常。最后，将obj添加到page中。</p><p>所以push的流程如图：<br><img src="/../images/image-65.png" alt="alt text"><br>简单来说，就是查看是否有可用page，若存在，直接add。若不存在，则创建page并add。若没有任何page，则需要从头构建page链表。</p><h2 id="AutoreleasePoolPage-pop-ctxt"><a href="#AutoreleasePoolPage-pop-ctxt" class="headerlink" title="AutoreleasePoolPage::pop(ctxt)"></a>AutoreleasePoolPage::pop(ctxt)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">void</span> *token)</span> </span>&#123;<br>    AutoreleasePoolPage *page;<br>    id *stop;<br><br>    <span class="hljs-comment">// 第一种情况：autoreleasepool首次push的时候返回的，也就是最顶层的page执行pop会执行这一部分</span><br>    <span class="hljs-keyword">if</span> (token == (<span class="hljs-type">void</span>*)EMPTY_POOL_PLACEHOLDER) &#123;<br>        <span class="hljs-comment">// Popping the top-level placeholder pool.</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">hotPage</span>()) &#123;<br>            <span class="hljs-comment">// Pool was used. Pop its contents normally.</span><br>            <span class="hljs-comment">// Pool pages remain allocated for re-use as usual.</span><br>            <span class="hljs-built_in">pop</span>(<span class="hljs-built_in">coldPage</span>() -&gt; <span class="hljs-built_in">begin</span>());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Pool was never used. Clear the placeholder.</span><br>            <span class="hljs-built_in">setHotPage</span>(nil);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    page = <span class="hljs-built_in">pageForPointer</span>(token);<br><br>    <span class="hljs-comment">// https://stackoverflow.com/questions/24952549/does-nsthread-create-autoreleasepool-automatically-now</span><br>    <span class="hljs-comment">// 第二种情况：在非ARC的情况下，在新创建的线程中不使用autoreleasepool，直接调用autorelease方法时会出现这个情况，</span><br>    <span class="hljs-comment">// 此时没有pool，直接进行autorelease。</span><br>    stop = (id *)token;<br>    <span class="hljs-keyword">if</span> (*stop != POOL_BOUNDARY) &#123;<br>        <span class="hljs-keyword">if</span> (stop == page -&gt; <span class="hljs-built_in">begin</span>() &amp;&amp; !page -&gt; parent) &#123;<br>            <span class="hljs-comment">// Start of coldest page may correctly not be POOL_BOUNDARY:</span><br>            <span class="hljs-comment">// 1. top-level pool is popped, leaving the cold page in place</span><br>            <span class="hljs-comment">// 2. an object is autoreleased with no pool</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Error. For bincompat purposes this is not</span><br>            <span class="hljs-comment">// fatal in executables built with old SDKs.</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">badPop</span>(token);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (PrintPoolHiwat) <span class="hljs-built_in">printHiwat</span>();<br><br>    <span class="hljs-comment">// 第三种情况：也就是我们经常碰到的情况</span><br>    page -&gt; <span class="hljs-built_in">releaseUntil</span>(stop);<br><br>    <span class="hljs-comment">// memory: delete empty children</span><br>    <span class="hljs-keyword">if</span> (DebugPoolAllocation &amp;&amp; page -&gt; <span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// special case: delete everything during page-per-pool debugging</span><br>        AutoreleasePoolPage *parent = page -&gt; parent;<br>        page -&gt; <span class="hljs-built_in">kill</span>();<br>        <span class="hljs-built_in">setHotPage</span>(parent);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (DebugMissingPools &amp;&amp; page -&gt; <span class="hljs-built_in">empty</span>() &amp;&amp; !page -&gt; parent) &#123;<br>        <span class="hljs-comment">// special case: delete everything for pop(top)</span><br>        <span class="hljs-comment">// when debugging missing autorelease pools</span><br>        page -&gt; <span class="hljs-built_in">kill</span>();<br>        <span class="hljs-built_in">setHotPage</span>(nil);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (page -&gt; child) &#123;<br>        <span class="hljs-comment">// hysteresis: keep one empty child if page is more than half full</span><br>        <span class="hljs-keyword">if</span> (page -&gt; <span class="hljs-built_in">lessThanHalfFull</span>()) &#123;<br>            page -&gt; child -&gt; <span class="hljs-built_in">kill</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (page -&gt; child -&gt; child) &#123;<br>            page -&gt; child -&gt; child -&gt; <span class="hljs-built_in">kill</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里重要分析第三种case</p><p><strong>releaseUntil</strong><br>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">releaseUntil</span><span class="hljs-params">(id *stop)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>-&gt;next != stop) &#123;<br>        AutoreleasePoolPage *page = <span class="hljs-built_in">hotPage</span>();<br><br>        <span class="hljs-keyword">while</span> (page-&gt;<span class="hljs-built_in">empty</span>()) &#123;<br>            page = page-&gt;parent;<br>            <span class="hljs-built_in">setHotPage</span>(page);<br>        &#125;<br><br>        page-&gt;<span class="hljs-built_in">unprotect</span>();<br>        id obj = *--page-&gt;next;<br>        <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span>*)page-&gt;next, SCRIBBLE, <span class="hljs-built_in">sizeof</span>(*page-&gt;next));<br>        page-&gt;<span class="hljs-built_in">protect</span>();<br><br>        <span class="hljs-keyword">if</span> (obj != POOL_BOUNDARY) &#123;<br>            <span class="hljs-built_in">objc_release</span>(obj);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">setHotPage</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>从next指针开始，逐个对存储的对象指针调用objc_release，知道碰到push时压入的pool为止。<br>所以pool的运行过程是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">pool1 = push()<br>...<br>    pool2 = push()<br>    ...<br>        pool3 = push()<br>        ...<br>        pop(pool3)<br>    ...<br>    pop(pool2)<br>...<br>pop(pool1)<br></code></pre></td></tr></table></figure><p>每次pop，实际上会把最近一次push之后添加进去的对象全部release掉。</p><h2 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++">- (id)autorelease &#123;<br>    <span class="hljs-keyword">return</span> ((id)self)-&gt;<span class="hljs-built_in">rootAutorelease</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> id <span class="hljs-title">objc_object::rootAutorelease</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isTaggedPointer</span>()) <span class="hljs-keyword">return</span> (id)<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">prepareOptimizedReturn</span>(ReturnAtPlus1)) <span class="hljs-keyword">return</span> (id)<span class="hljs-keyword">this</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">rootAutorelease2</span>();<br>&#125;<br><br>__attribute__((noinline,used)) idobjc_object::<span class="hljs-built_in">rootAutorelease2</span>() &#123;<br>    <span class="hljs-built_in">assert</span>(!<span class="hljs-built_in">isTaggedPointer</span>());<br>    <span class="hljs-keyword">return</span> AutoreleasePoolPage::<span class="hljs-built_in">autorelease</span>((id)<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> id <span class="hljs-title">autorelease</span><span class="hljs-params">(id obj)</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(obj);<br>    <span class="hljs-built_in">assert</span>(!obj-&gt;<span class="hljs-built_in">isTaggedPointer</span>());<br>    id *dest __unused = <span class="hljs-built_in">autoreleaseFast</span>(obj);<br>    <span class="hljs-built_in">assert</span>(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述源码可以看到，对autorelease方法的调用，最后会变成对page的autorelease调用。而page的autorelease本质是调用autoreleaseFast(obj)。只不过push操作插入的是一个POOL_BOUNDARY，而autorelease操作插入的是一个具体的obj。</p><p>ps：这么说自然并不严谨，还需要考虑是否是tagged pointer（前面说过，tagged pointer不参与ARC）和是否进行优化，如果不满足这俩条件才最终会进入pool。</p><h2 id="AutoreleasePool、RunLoop、线程之间的关系"><a href="#AutoreleasePool、RunLoop、线程之间的关系" class="headerlink" title="AutoreleasePool、RunLoop、线程之间的关系"></a>AutoreleasePool、RunLoop、线程之间的关系</h2><ul><li>每个线程至多有一个runloop，再需要时自动创建</li><li>主线程runloop开始之前自动创建pool，结束时pop</li><li>每个线程维护自己的pool，每个pool也只属于一个线程</li></ul><h2 id="进入AutoreleasePool的时机"><a href="#进入AutoreleasePool的时机" class="headerlink" title="进入AutoreleasePool的时机"></a>进入AutoreleasePool的时机</h2><p>什么样的对象会进入pool？</p><ul><li>当使用new&#x2F;alloc时不会进入pool，使用其他方法创建的对象默认进入pool（还记得为什么嘛？如果不加入pool，那么返回之后，对象将被立即释放）</li><li>但是，在OC高级编程中也提到过，runtime会对加入pool进行优化，通过objc_retainAutoreleasedReturnValue和objc_retainAutoreleaseReturnValue可以不用将对象加入到pool。</li></ul><p><strong>objc_retainAutoreleasedReturnValue</strong><br>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Accept a value returned through a +0 autoreleasing convention for use at +1.</span><br><span class="hljs-function">id</span><br><span class="hljs-function"><span class="hljs-title">objc_retainAutoreleasedReturnValue</span><span class="hljs-params">(id obj)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">acceptOptimizedReturn</span>() == ReturnAtPlus1) <span class="hljs-keyword">return</span> obj;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">objc_retain</span>(obj);<br>&#125;<br><br><span class="hljs-comment">// Try to accept an optimized return.</span><br><span class="hljs-comment">// Returns the disposition of the returned object (+0 or +1).</span><br><span class="hljs-comment">// An un-optimized return is +0.</span><br><span class="hljs-function"><span class="hljs-type">static</span> ALWAYS_INLINE ReturnDisposition </span><br><span class="hljs-function"><span class="hljs-title">acceptOptimizedReturn</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ReturnDisposition disposition = <span class="hljs-built_in">getReturnDisposition</span>();<br>    <span class="hljs-built_in">setReturnDisposition</span>(ReturnAtPlus0);  <span class="hljs-comment">// reset to the unoptimized state</span><br>    <span class="hljs-keyword">return</span> disposition;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> ALWAYS_INLINE ReturnDisposition </span><br><span class="hljs-function"><span class="hljs-title">getReturnDisposition</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (ReturnDisposition)(<span class="hljs-type">uintptr_t</span>)<span class="hljs-built_in">tls_get_direct</span>(RETURN_DISPOSITION_KEY);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以知道，该函数尝试接受被优化的记过，若是ReturnAtPlus1，返回对象本身，否则执行objc_retain。<br>这个被优化的结果是在TLS中的，可以理解为优化标志，当优化标志返回YES时，直接返回对象本身，否则执行retain。</p><p><strong>objc_retainAutoreleaseReturnValue</strong><br>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Prepare a value at +0 for return through a +0 autoreleasing convention.</span><br><span class="hljs-function">id </span><br><span class="hljs-function"><span class="hljs-title">objc_retainAutoreleaseReturnValue</span><span class="hljs-params">(id obj)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">prepareOptimizedReturn</span>(ReturnAtPlus0)) <span class="hljs-keyword">return</span> obj;<br><br>    <span class="hljs-comment">// not objc_autoreleaseReturnValue(objc_retain(obj)) </span><br>    <span class="hljs-comment">// because we don&#x27;t need another optimization attempt</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">objc_retainAutoreleaseAndReturn</span>(obj);<br>&#125;<br><br><span class="hljs-comment">// Try to prepare for optimized return with the given disposition (+0 or +1).</span><br><span class="hljs-comment">// Returns true if the optimized path is successful.</span><br><span class="hljs-comment">// Otherwise the return value must be retained and/or autoreleased as usual.</span><br><span class="hljs-function"><span class="hljs-type">static</span> ALWAYS_INLINE <span class="hljs-type">bool</span> </span><br><span class="hljs-function"><span class="hljs-title">prepareOptimizedReturn</span><span class="hljs-params">(ReturnDisposition disposition)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">getReturnDisposition</span>() == ReturnAtPlus0);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">callerAcceptsOptimizedReturn</span>(__builtin_return_address(<span class="hljs-number">0</span>))) &#123;<br>        <span class="hljs-keyword">if</span> (disposition) <span class="hljs-built_in">setReturnDisposition</span>(disposition);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> ALWAYS_INLINE <span class="hljs-type">bool</span> </span><br><span class="hljs-function"><span class="hljs-title">callerAcceptsOptimizedReturn</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> * <span class="hljs-type">const</span> ra0)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *ra1 = (<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *)ra0;<br>    <span class="hljs-type">const</span> <span class="hljs-type">unaligned_uint16_t</span> *ra2;<br>    <span class="hljs-type">const</span> <span class="hljs-type">unaligned_uint32_t</span> *ra4 = (<span class="hljs-type">const</span> <span class="hljs-type">unaligned_uint32_t</span> *)ra1;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span> **sym;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PREFER_GOTPCREL 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> PREFER_GOTPCREL</span><br>    <span class="hljs-comment">// 48 89 c7    movq  %rax,%rdi</span><br>    <span class="hljs-comment">// ff 15       callq *symbol@GOTPCREL(%rip)</span><br>    <span class="hljs-keyword">if</span> (*ra4 != <span class="hljs-number">0xffc78948</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ra1[<span class="hljs-number">4</span>] != <span class="hljs-number">0x15</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    ra1 += <span class="hljs-number">3</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-comment">// 48 89 c7    movq  %rax,%rdi</span><br>    <span class="hljs-comment">// e8          callq symbol</span><br>    <span class="hljs-keyword">if</span> (*ra4 != <span class="hljs-number">0xe8c78948</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    ra1 += (<span class="hljs-type">long</span>)*(<span class="hljs-type">const</span> <span class="hljs-type">unaligned_int32_t</span> *)(ra1 + <span class="hljs-number">4</span>) + <span class="hljs-number">8l</span>;<br>    ra2 = (<span class="hljs-type">const</span> <span class="hljs-type">unaligned_uint16_t</span> *)ra1;<br>    <span class="hljs-comment">// ff 25       jmpq *symbol@DYLDMAGIC(%rip)</span><br>    <span class="hljs-keyword">if</span> (*ra2 != <span class="hljs-number">0x25ff</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    ra1 += <span class="hljs-number">6l</span> + (<span class="hljs-type">long</span>)*(<span class="hljs-type">const</span> <span class="hljs-type">unaligned_int32_t</span> *)(ra1 + <span class="hljs-number">2</span>);<br>    sym = (<span class="hljs-type">const</span> <span class="hljs-type">void</span> **)ra1;<br>    <span class="hljs-keyword">if</span> (*sym != objc_retainAutoreleasedReturnValue  &amp;&amp;  <br>        *sym != objc_unsafeClaimAutoreleasedReturnValue) <br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// Same as objc_retainAutorelease but suitable for tail-calling </span><br><span class="hljs-comment">// if you don&#x27;t want to push a frame before this point.</span><br>__attribute__((noinline))<br><span class="hljs-function"><span class="hljs-type">static</span> id </span><br><span class="hljs-function"><span class="hljs-title">objc_retainAutoreleaseAndReturn</span><span class="hljs-params">(id obj)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">objc_retainAutorelease</span>(obj);<br>&#125;<br><br><span class="hljs-function">id</span><br><span class="hljs-function"><span class="hljs-title">objc_retainAutorelease</span><span class="hljs-params">(id obj)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">objc_autorelease</span>(<span class="hljs-built_in">objc_retain</span>(obj));<br>&#125;<br></code></pre></td></tr></table></figure><p>这里主要涉及到callerAcceptsOptimizedReturn，它应该是要检查返回之后调用者是否紧接着调用了objc_retainAutoreleasedReturnValue，若是，则就走优化，不加入pool，反之就不走优化。</p><p>所以，使用new、alloc这种方法创建的对象一般不会进入pool，使用其他便捷方法创建的对象，runtime会开启优化以决定是否进入pool。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>pool的本质：是以page为节点的双向链表，每个page都是一个栈结构，且每个page都属于一个线程</li><li>pool的工作原理：<ul><li>在app中，主线程最外面是一个pool，生命周期是整个app</li><li>使用@autoreleasepool标记，就是创建pool，并加入boundary</li><li>若tls没有hotpage，则要从头创建page，设置EMPTY_POOL_PLACEHOLDER</li><li>因为设置了EMPTY_POOL_PLACEHOLDER，设置此page为hotpage，添加边界标记POOL_BOUNDARY，然后添加obj</li><li>后续调用autorelease，因为已经有page，直接添加</li><li>若page满了，则autoreleaseFullPage创建新page</li><li>达到pool边界，调用pop方法，释放掉POOL_BOUNDARY之后的所有obj</li></ul></li><li>什么样的obj会进入pool<ul><li>tagged pinter不会进入</li><li>new&#x2F;alloc不进入</li><li>其他快捷方法创建的obj会视情况，判断有无优化进入</li></ul></li><li>何时需要手动创建pool<ul><li>代码中使用循环使用便捷方法大量创建对象</li></ul></li><li>子线程中使用autorelease对象是否能确保被释放<ul><li>底层函数autoreleaseNoPage会在没有pool的情况下懒加载创建</li><li>即使没有pop也不要紧，当线程exit时，执行AutoreleasePoolPage::tls_dealloc，从而释放pool</li></ul></li><li>pool释放对象的实际<ul><li>没有手动创建pool时，主线程是通过runloop监听来决定释放，子线程是在退出线程时释放</li><li>手动创建pool时，会在@autoreleasepool的block结束后释放</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Autorelase Pool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS-自动引用计数</title>
    <link href="/2024/03/07/ios-oc-arc/"/>
    <url>/2024/03/07/ios-oc-arc/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前已经深入理解了ARC原理，本文再复习下并查漏补缺</p><h2 id="引用计数的存储策略"><a href="#引用计数的存储策略" class="headerlink" title="引用计数的存储策略"></a>引用计数的存储策略</h2><ul><li>若对象支持Tagged Pointer，则直接将指针值作为引用计数</li><li>若当前设备是64位且使用OC 2.0，那么某些对鞋会使用isa指针来存储引用计数</li><li>一般使用hash表管理引用计数</li></ul><h2 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h2><ul><li>从64bit开始，iOS引入了Tagged Pointer，来优化一些小对象的内存占用</li><li>在之前，每个oc对象至少需要16byte代销，如果还需要存储额外的值，会增大内存占用</li><li>启用Tagged Pointer之后，其指针不再是地址，而是值，准确来说是Tag+Data。所以本质就是个和int一样的值，只不过runtime能够将其包装为对象。因而，其内存不再存储于堆，不需要malloc和free。读取速度也会快</li></ul><p>看下Tagged Pointer引用：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[]) &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        <span class="hljs-built_in">NSNumber</span> *number1 = @<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">NSNumber</span> *number2 = @<span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">NSNumber</span> *number3 = @<span class="hljs-number">3</span>;<br>        <span class="hljs-built_in">NSNumber</span> *number4 = @<span class="hljs-number">4</span>;<br>        <br>        <span class="hljs-built_in">NSNumber</span> *numberLarger = @(MAXFLOAT);<br>        <br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;number1 pointer is %p&quot;</span>, number1);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;number2 pointer is %p&quot;</span>, number2);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;number3 pointer is %p&quot;</span>, number3);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;number4 pointer is %p&quot;</span>, number4);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;numberLarger pointer is %p&quot;</span>, numberLarger);<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">UIApplicationMain</span>(argc, argv, <span class="hljs-literal">nil</span>, <span class="hljs-built_in">NSStringFromClass</span>([AppDelegate <span class="hljs-keyword">class</span>]));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-number">2018</span><span class="hljs-number">-09</span><span class="hljs-number">-25</span> <span class="hljs-number">15</span>:<span class="hljs-number">26</span>:<span class="hljs-number">05.788382</span>+<span class="hljs-number">0800</span> <span class="hljs-built_in">NSObjectProject</span>[<span class="hljs-number">68029</span>:<span class="hljs-number">24580896</span>] number1 pointer is <span class="hljs-number">0x9c344c19d780bc93</span><br><span class="hljs-number">2018</span><span class="hljs-number">-09</span><span class="hljs-number">-25</span> <span class="hljs-number">15</span>:<span class="hljs-number">26</span>:<span class="hljs-number">05.789257</span>+<span class="hljs-number">0800</span> <span class="hljs-built_in">NSObjectProject</span>[<span class="hljs-number">68029</span>:<span class="hljs-number">24580896</span>] number2 pointer is <span class="hljs-number">0x9c344c19d780bca3</span><br><span class="hljs-number">2018</span><span class="hljs-number">-09</span><span class="hljs-number">-25</span> <span class="hljs-number">15</span>:<span class="hljs-number">26</span>:<span class="hljs-number">05.789383</span>+<span class="hljs-number">0800</span> <span class="hljs-built_in">NSObjectProject</span>[<span class="hljs-number">68029</span>:<span class="hljs-number">24580896</span>] number3 pointer is <span class="hljs-number">0x9c344c19d780bcb3</span><br><span class="hljs-number">2018</span><span class="hljs-number">-09</span><span class="hljs-number">-25</span> <span class="hljs-number">15</span>:<span class="hljs-number">26</span>:<span class="hljs-number">05.789489</span>+<span class="hljs-number">0800</span> <span class="hljs-built_in">NSObjectProject</span>[<span class="hljs-number">68029</span>:<span class="hljs-number">24580896</span>] number4 pointer is <span class="hljs-number">0x9c344c19d780bcc3</span><br><span class="hljs-number">2018</span><span class="hljs-number">-09</span><span class="hljs-number">-25</span> <span class="hljs-number">15</span>:<span class="hljs-number">26</span>:<span class="hljs-number">05.789579</span>+<span class="hljs-number">0800</span> <span class="hljs-built_in">NSObjectProject</span>[<span class="hljs-number">68029</span>:<span class="hljs-number">24580896</span>] numberLarger pointer is <span class="hljs-number">0x600001e60d80</span><br></code></pre></td></tr></table></figure><p>上述结果中，除了numberLarger，其他都是Tagged Pointer。如何判断呢，看源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">objc_object::isTaggedPointer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> _objc_isTaggedPointer(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> _objc_isTaggedPointer(<span class="hljs-type">const</span> <span class="hljs-type">void</span> * _Nullable ptr) &#123;<br>    <span class="hljs-keyword">return</span> ((<span class="hljs-type">uintptr_t</span>)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;<br>&#125;<br></code></pre></td></tr></table></figure><p>而_OBJC_TAG_MASK依赖于环境：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">if</span> (TARGET_OS_OSX || TARGET_OS_IOSMAC) &amp;&amp; __x86_64__</span><br>    <span class="hljs-comment">// 64-bit Mac - tag bit is LSB</span><br><span class="hljs-meta">#   <span class="hljs-keyword">define</span> OBJC_MSB_TAGGED_POINTERS 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-comment">// Everything else - tag bit is MSB</span><br><span class="hljs-meta">#   <span class="hljs-keyword">define</span> OBJC_MSB_TAGGED_POINTERS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> OBJC_MSB_TAGGED_POINTERS</span><br><span class="hljs-meta">#   <span class="hljs-keyword">define</span> _OBJC_TAG_MASK (1UL&lt;&lt;63)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#   <span class="hljs-keyword">define</span> _OBJC_TAG_MASK 1UL</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>若是在macOS 64bit，_OBJC_TAG_MASK是1，若是iOS 64bit，其值是1UL&lt;&lt;63。</p><p>所以该判断条件需要区分Mac OS和iOS。在iOS上，需查看指针的最高位是否为1.</p><p>我们知道，所有oc对象都有isa，那么引入了Tagged Pointer，怎么获取isa呢？</p><h2 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a>isa指针</h2><p>本质是isa_t这个union。在oc中，类本身也可以看做是oc对象，其isa指向metaClass。在arm64架构之前，isa就是个普通指针，但arm64之后，isa编程了union，并且可以通过bitfield存储更多信息。<br>查看定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">objc_object</span> &#123;<br>    <span class="hljs-type">isa_t</span> isa;<br>&#125;<br><br><span class="hljs-comment">// isa_t的定义</span><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">isa_t</span> &#123;<br>    <span class="hljs-built_in">isa_t</span>() &#123; &#125;<br>    <span class="hljs-built_in">isa_t</span>(<span class="hljs-type">uintptr_t</span> value) : <span class="hljs-built_in">bits</span>(value) &#123; &#125;<br><br>    Class cls;<br>    <span class="hljs-type">uintptr_t</span> bits;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> SUPPORT_PACKED_ISA</span><br><span class="hljs-meta"># <span class="hljs-keyword">if</span> __arm64__</span><br><span class="hljs-meta">#   <span class="hljs-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="hljs-meta">#   <span class="hljs-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class="hljs-meta">#   <span class="hljs-keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span><br>    <span class="hljs-keyword">struct</span> &#123;<br>        <span class="hljs-comment">// 不同的isa_t类型，是否开启指针优化（影响引用计数的存储是否启用side table）</span><br>        <span class="hljs-type">uintptr_t</span> nonpointer        : <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 是否存在关联独享</span><br>        <span class="hljs-type">uintptr_t</span> has_assoc         : <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 是否有析构函数</span><br>        <span class="hljs-type">uintptr_t</span> has_cxx_dtor      : <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 若开启指针优化，用33bits存储类指针的值，之前我们在init初始化isa的时候就看到</span><br>        <span class="hljs-type">uintptr_t</span> shiftcls          : <span class="hljs-number">33</span>; <span class="hljs-comment">// MACH_VM_MAX_ADDRESS 0x1000000000</span><br>        <span class="hljs-comment">// 调试器判断当前对象是否已初始化</span><br>        <span class="hljs-type">uintptr_t</span> magic             : <span class="hljs-number">6</span>;<br>        <span class="hljs-comment">// 是否是若weak引用，不是weak引用可以更快释放</span><br>        <span class="hljs-type">uintptr_t</span> weakly_referenced : <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 是否正在释放</span><br>        <span class="hljs-type">uintptr_t</span> deallocating      : <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 存当引用计数过大时，引用计数会存储在SideTable的类属性</span><br>        <span class="hljs-type">uintptr_t</span> has_sidetable_rc  : <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 存储引用计数</span><br>        <span class="hljs-type">uintptr_t</span> extra_rc          : <span class="hljs-number">19</span>;<br><span class="hljs-meta">#       <span class="hljs-keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span><br><span class="hljs-meta">#       <span class="hljs-keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span><br>    &#125;;<br><span class="hljs-meta"># <span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// SUPPORT_PACKED_ISA</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>nonpointer:<ul><li>0:不开启指针优化，isa就是cls，cls就是class</li><li>1:开启指针优化，isa是tagged pointer，包含类信息、对象的引用计数</li></ul></li><li>extra_rc：占用19bit，超过则需要side tables，side tbales包含引用计数表</li><li>为什么有extra_rc还需要side table？以前32bit值比较小，现在arm64基本够用，所以现在引用计数基本都存到isa中了</li></ul><h2 id="isa-t中的宏定义"><a href="#isa-t中的宏定义" class="headerlink" title="isa_t中的宏定义"></a>isa_t中的宏定义</h2><p><strong>SUPPORT_PACKED_ISA</strong></p><p>表示平台是否支持在isa中放入出class之外的信息：</p><ul><li>若支持：将class放入isa_t的struct中，并附加一些额外信息，如nonpointer</li><li>不支持：则不使用isa_t中的struct，isa_t只包含cls</li><li>一般是支持的</li></ul><p><strong>SUPPORT_INDEXED_ISA</strong></p><p>表示isa_t存放的class信息是class的地址，在initIsa中有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">if</span> SUPPORT_INDEXED_ISA</span><br>newisa.indexcls = (<span class="hljs-type">uintptr_t</span>)cls-&gt;<span class="hljs-built_in">classArrayIndex</span>();<br></code></pre></td></tr></table></figure><p>iOS上，该宏为0</p><h2 id="isa类型有关的宏"><a href="#isa类型有关的宏" class="headerlink" title="isa类型有关的宏"></a>isa类型有关的宏</h2><p><strong>SUPPORT_NONPOINTER_ISA</strong></p><p>用于标记是否支持优化的isa指针，其定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">if</span> !SUPPORT_INDEXED_ISA  &amp;&amp;  !SUPPORT_PACKED_ISA</span><br><span class="hljs-meta">#   <span class="hljs-keyword">define</span> SUPPORT_NONPOINTER_ISA 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#   <span class="hljs-keyword">define</span> SUPPORT_NONPOINTER_ISA 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>如何判断是否支持优化的isa指针：</p><ul><li>iOS中SUPPORT_PACKED_ISA为1，所以该宏也是1</li><li>环境变量中设置OBJC_DISABLE_NONPOINTER_ISA</li></ul><p>需要注意的是，即使在64bit下，优化的isa指针并不一定会存储引用计数，因为引用计数可能特比的大，可能需要存到side table</p><h2 id="SideTable"><a href="#SideTable" class="headerlink" title="SideTable"></a>SideTable</h2><p>其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SideTable</span> &#123;<br>    <span class="hljs-comment">// 线程安全锁</span><br>    <span class="hljs-type">spinlock_t</span> slock;<br>    <span class="hljs-comment">// 实际存储表</span><br>    RefcountMap refcnts;<br>    <span class="hljs-comment">// weak引用表</span><br>    <span class="hljs-type">weak_table_t</span> weak_table;<br><br>    <span class="hljs-comment">//省略其他代码</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>RefcountMap的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,<span class="hljs-type">size_t</span>,<span class="hljs-literal">true</span>&gt; RefcountMap;<br></code></pre></td></tr></table></figure><p>可以看出，以oc对象为key，size为value。</p><h2 id="引用计数的获取"><a href="#引用计数的获取" class="headerlink" title="引用计数的获取"></a>引用计数的获取</h2><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++">- (NSUInteger)retainCount &#123;<br>    <span class="hljs-keyword">return</span> ((id)self)-&gt;<span class="hljs-built_in">rootRetainCount</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">uintptr_t</span> <span class="hljs-title">objc_object::rootRetainCount</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isTaggedPointer</span>()) <span class="hljs-keyword">return</span> (<span class="hljs-type">uintptr_t</span>)<span class="hljs-keyword">this</span>;<br><br>    <span class="hljs-built_in">sidetable_lock</span>();<br>    <span class="hljs-comment">// 加锁，用汇编指令ldxr来保证原子性</span><br>    <span class="hljs-type">isa_t</span> bits = <span class="hljs-built_in">LoadExclusive</span>(&amp;isa.bits);<br>    <span class="hljs-comment">// 释放锁，使用汇编指令clrex</span><br>    <span class="hljs-built_in">ClearExclusive</span>(&amp;isa.bits);<br>    <span class="hljs-keyword">if</span> (bits.nonpointer) &#123;<br>        <span class="hljs-type">uintptr_t</span> rc = <span class="hljs-number">1</span> + bits.extra_rc;<br>        <span class="hljs-keyword">if</span> (bits.has_sidetable_rc) &#123;<br>            rc += <span class="hljs-built_in">sidetable_getExtraRC_nolock</span>();<br>        &#125;<br>        <span class="hljs-built_in">sidetable_unlock</span>();<br>        <span class="hljs-keyword">return</span> rc;<br>    &#125;<br><br>    <span class="hljs-built_in">sidetable_unlock</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sidetable_retainCount</span>();<br>&#125;<br><br><span class="hljs-comment">//sidetable_retainCount()函数实现</span><br><span class="hljs-function"><span class="hljs-type">uintptr_t</span> <span class="hljs-title">objc_object::sidetable_retainCount</span><span class="hljs-params">()</span> </span>&#123;<br>    SideTable&amp; table = <span class="hljs-built_in">SideTables</span>()[<span class="hljs-keyword">this</span>];<br><br>    <span class="hljs-type">size_t</span> refcnt_result = <span class="hljs-number">1</span>;<br>    <br>    table.<span class="hljs-built_in">lock</span>();<br>    RefcountMap::iterator it = table.refcnts.<span class="hljs-built_in">find</span>(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">if</span> (it != table.refcnts.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-comment">// this is valid for SIDE_TABLE_RC_PINNED too</span><br>        refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;<br>    &#125;<br>    table.<span class="hljs-built_in">unlock</span>();<br>    <span class="hljs-keyword">return</span> refcnt_result;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>若是tagged pointer，则直接返回指针本身</li><li>非tagged pointer，但开启指针优化，先从extra_rc获取，接着判断是否存在side table，若有则需要加上</li><li>非tagged pointer, 并且没有开启指针优化，则直接从side table获取</li></ul><h2 id="手动操作对引用计数的影响"><a href="#手动操作对引用计数的影响" class="headerlink" title="手动操作对引用计数的影响"></a>手动操作对引用计数的影响</h2><p><strong>objc_retain()</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">if</span> __OBJC2__</span><br>__attribute__((<span class="hljs-built_in">aligned</span>(<span class="hljs-number">16</span>))) <span class="hljs-function">id <span class="hljs-title">objc_retain</span><span class="hljs-params">(id obj)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span> obj;<br>    <span class="hljs-keyword">if</span> (obj-&gt;<span class="hljs-built_in">isTaggedPointer</span>()) <span class="hljs-keyword">return</span> obj;<br>    <span class="hljs-keyword">return</span> obj-&gt;<span class="hljs-built_in">retain</span>();<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-function">id <span class="hljs-title">objc_retain</span><span class="hljs-params">(id obj)</span> </span>&#123; <span class="hljs-keyword">return</span> [obj retain]; &#125;<br></code></pre></td></tr></table></figure><ul><li>判断是否为taggped pointer，若是，则返回对象本身，否则调用retain</li></ul><p><strong>retain()</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">inline</span> id <span class="hljs-title">objc_object::retain</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(!<span class="hljs-built_in">isTaggedPointer</span>());<br>    <span class="hljs-comment">// hasCustomRR方法检查类（包括其父类）中是否含有默认的方法</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fastpath</span>(!<span class="hljs-built_in">ISA</span>()-&gt;<span class="hljs-built_in">hasCustomRR</span>())) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rootRetain</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ((<span class="hljs-built_in">id</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="hljs-keyword">this</span>, SEL_retain);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>判断是否是tagged pointer，该函数不应处理tagged pointer</li><li>通过hasCustomRR判断类&#x2F;父类是否有覆盖了实现，有则调用自定义方法；没有则调用rootRetain</li></ul><p><strong>rootRetain()</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ALWAYS_INLINE id <span class="hljs-title">objc_object::rootRetain</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">rootRetain</span>(<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">//将源码精简后的逻辑</span><br><span class="hljs-function">ALWAYS_INLINE id </span><br><span class="hljs-function"><span class="hljs-title">objc_object::rootRetain</span><span class="hljs-params">(<span class="hljs-type">bool</span> tryRetain, <span class="hljs-type">bool</span> handleOverflow)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isTaggedPointer</span>()) <span class="hljs-keyword">return</span> (id)<span class="hljs-keyword">this</span>;<br>    <br>    <span class="hljs-type">isa_t</span> oldisa;<br>    <span class="hljs-type">isa_t</span> newisa;<br><br>    <span class="hljs-comment">// 加锁，用汇编指令ldxr来保证原子性</span><br>    oldisa = <span class="hljs-built_in">LoadExclusive</span>(&amp;isa.bits);<br>    newisa = oldisa;<br>    <br>    <span class="hljs-keyword">if</span> (newisa.nonpointer = <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// newisa.nonpointer = 0说明所有位数都是地址值</span><br>        <span class="hljs-comment">// 释放锁，使用汇编指令clrex</span><br>        <span class="hljs-built_in">ClearExclusive</span>(&amp;isa.bits);<br>        <br>        <span class="hljs-comment">// 由于所有位数都是地址值，直接使用SideTable来存储引用计数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sidetable_retain</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 存储extra_rc++后的结果</span><br>    <span class="hljs-type">uintptr_t</span> carry;<br>    <span class="hljs-comment">// extra_rc++</span><br>    newisa.bits = <span class="hljs-built_in">addc</span>(newisa.bits, RC_ONE, <span class="hljs-number">0</span>, &amp;carry);<br>    <br>    <span class="hljs-keyword">if</span> (carry == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// extra_rc++后溢出，进位到side table</span><br>        newisa.extra_rc = RC_HALF;<br>        newisa.has_sidetable_rc = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">sidetable_addExtraRC_nolock</span>(RC_HALF);<br>    &#125;<br>        <br>    <span class="hljs-comment">// 将newisa写入isa</span><br>    <span class="hljs-built_in">StoreExclusive</span>(&amp;isa.bits, oldisa.bits, newisa.bits)<br>    <span class="hljs-keyword">return</span> (id)<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>若是tagged pointer，不做任何处理直接返回</li><li>若没有开启指针优化，则直接使用side table存储</li><li>若开启指针优化，先使用extra_rc，超过后，使用side table存储</li></ul><p><strong>objc_release()</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">if</span> __OBJC2__</span><br>__attribute__((<span class="hljs-built_in">aligned</span>(<span class="hljs-number">16</span>)))<br><span class="hljs-function"><span class="hljs-type">void</span> </span><br><span class="hljs-function"><span class="hljs-title">objc_release</span><span class="hljs-params">(id obj)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (obj-&gt;<span class="hljs-built_in">isTaggedPointer</span>()) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">return</span> obj-&gt;<span class="hljs-built_in">release</span>();<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">objc_release</span><span class="hljs-params">(id obj)</span> </span>&#123; [obj release]; &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">//release()源码</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">objc_object::release</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(!<span class="hljs-built_in">isTaggedPointer</span>());<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fastpath</span>(!<span class="hljs-built_in">ISA</span>()-&gt;<span class="hljs-built_in">hasCustomRR</span>())) &#123;<br>        <span class="hljs-built_in">rootRelease</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    ((<span class="hljs-built_in">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="hljs-keyword">this</span>, SEL_release);<br>&#125;<br></code></pre></td></tr></table></figure><p>逻辑和objc_retain基本一致，直接看rootRelease</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ALWAYS_INLINE <span class="hljs-type">bool</span></span><br><span class="hljs-function"><span class="hljs-title">objc_object::rootRelease</span><span class="hljs-params">(<span class="hljs-type">bool</span> performDealloc, <span class="hljs-type">bool</span> handleUnderflow)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isTaggedPointer</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-type">isa_t</span> oldisa;<br>    <span class="hljs-type">isa_t</span> newisa;<br>    <br>retry:<br>    oldisa = <span class="hljs-built_in">LoadExclusive</span>(&amp;isa.bits);<br>    newisa = oldisa;<br>    <span class="hljs-keyword">if</span> (newisa.nonpointer == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">ClearExclusive</span>(&amp;isa.bits);<br>        <span class="hljs-keyword">if</span> (sideTableLocked) <span class="hljs-built_in">sidetable_unlock</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sidetable_release</span>(performDealloc);<br>    &#125;<br>    <br>    <span class="hljs-type">uintptr_t</span> carry;<br>    <span class="hljs-comment">// extra_rc--</span><br>    newisa.bits = <span class="hljs-built_in">subc</span>(newisa.bits, RC_ONE, <span class="hljs-number">0</span>, &amp;carry);<br>    <span class="hljs-keyword">if</span> (carry == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 需要从SideTable借位，或者引用计数为0</span><br>        <span class="hljs-keyword">goto</span> underflow;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 存储引用计数到isa</span><br>    <span class="hljs-built_in">StoreReleaseExclusive</span>(&amp;isa.bits,<br>                          oldisa.bits, newisa.bits)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>underflow:<br>    <span class="hljs-comment">// 从SideTable借位</span><br>    <span class="hljs-comment">// 或引用计数为0，调用delloc</span><br>    <br>    <span class="hljs-comment">// 此处省略N多代码</span><br>    <span class="hljs-comment">// 总结一下:修改Side Table与extra_rc，</span><br>    <br>    <span class="hljs-comment">// 引用计数减为0时，调用dealloc</span><br>    <span class="hljs-keyword">if</span> (performDealloc) &#123;<br>        ((<span class="hljs-built_in">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="hljs-keyword">this</span>, SEL_dealloc);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>判断是否是tagged pointer，若是，则直接返回</li><li>若没有开启指针优化，使用side table存储引用计数</li><li>若开启指针优化，需使用isa的extra_rc，结合side table</li><li>若引用计数归0，则调用dealloc进行释放</li></ul><p>ps：经过packed的isa并不单纯保存关于类的信息了，还保存关于对象的信息（如引用计数）！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>引用计数存储位置<ul><li>tagged pointer无需引用计数，直接将指针值作为引用计数</li><li>开启指针优化：会放在isa的extra_rc+side table中</li><li>不开启指针优化，则直接放在side table中</li></ul></li><li>retain&#x2F;release的实质<ul><li>tagged pointer不参与retain release</li><li>找到引用计数存储区域，进行相应加减</li><li>引用计数减成0，则调用dealloc</li></ul></li><li>isa相关<ul><li>oc对象的isa是个union，可能是class，也可能是个struct，包含额外信息（当然也包含class指针，只不过需要通过shiftcls获取），由于oc对象也可能是个tagged pointer，其本事就是一串bit，bit中包含类信息，所以不能直接通过访问isa的方式获取类指针，而是需要通过系统api才正确</li><li>tagged pointer并没有isa指针，本身就是用isa_t来表示</li><li>其他对象的isa还是类指针</li></ul></li><li>对象的值是什么：<ul><li>若是tagged pointer，则对象值是指针本身</li><li>若不是，对象值是指针指向的内存区域</li></ul></li></ul><h2 id="补充：ARC下经典的多线程对同一个属性赋值而造成崩溃"><a href="#补充：ARC下经典的多线程对同一个属性赋值而造成崩溃" class="headerlink" title="补充：ARC下经典的多线程对同一个属性赋值而造成崩溃"></a>补充：ARC下经典的多线程对同一个属性赋值而造成崩溃</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSString</span> *target;<br><span class="hljs-comment">//....</span><br><br><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">&quot;parallel&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span> ; i++) &#123;<br>    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>        <span class="hljs-keyword">self</span>.target = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;ksddkjalkjd%d&quot;</span>,i];<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>原因：<br>在对target进行赋值时，本质是调用storeStrong，将新对象retain，将原对象release；即</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">objc_storeStrong</span>(id *location, id obj) &#123;<br>    id prev = *location;<br>    <span class="hljs-keyword">if</span> (obj == prev) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">objc_retain</span>(obj);<br>    *location = obj;<br>    <span class="hljs-built_in">objc_release</span>(prev);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么可能出现，多个线程同时获取到了prev准备release，从而造成过度release，造成crash</p><h2 id="补充：Tagged-Pointer的内存布局"><a href="#补充：Tagged-Pointer的内存布局" class="headerlink" title="补充：Tagged Pointer的内存布局"></a>补充：Tagged Pointer的内存布局</h2><p><img src="/../images/image-62.png" alt="alt text"></p><ul><li>最前面表示是否是tagged pointer</li><li>1-3bit表示类信息：NSNumber&#x2F;NSString</li><li>中间是具体数据</li><li>最后是额外信息：数据类型，如NSNumber是int</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>ARC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS-对象生成和销毁</title>
    <link href="/2024/03/07/ios-oc-object-alloc/"/>
    <url>/2024/03/07/ios-oc-object-alloc/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在日常iOS开发中，频繁使用+alloc, -init来创建oc对象，我们知道，这个过程本质就是开辟内存空间，并且初始化的构成</p><h2 id="alloc"><a href="#alloc" class="headerlink" title="+alloc"></a>+alloc</h2><p>源码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC">+ (<span class="hljs-type">id</span>)alloc &#123;<br>    <span class="hljs-keyword">return</span> _objc_rootAlloc(<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-type">id</span> _objc_rootAlloc(Class cls) &#123;<br>    <span class="hljs-keyword">return</span> callAlloc(cls, <span class="hljs-literal">false</span><span class="hljs-comment">/*checkNil*/</span>, <span class="hljs-literal">true</span><span class="hljs-comment">/*allocWithZone*/</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>实际就是调用callAlloc方法</p><h2 id="callAlloc"><a href="#callAlloc" class="headerlink" title="callAlloc"></a>callAlloc</h2><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> cls:CustomClass</span><br><span class="hljs-comment"> checkNil:是否检查Cls</span><br><span class="hljs-comment"> allocWithZone：是否分配到指定空间，默认为false，内部会对其进行优化</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">static</span> ALWAYS_INLINE id</span><br><span class="hljs-function"><span class="hljs-title">callAlloc</span><span class="hljs-params">(Class cls, <span class="hljs-type">bool</span> checkNil, <span class="hljs-type">bool</span> allocWithZone=<span class="hljs-literal">false</span>)</span> </span>&#123;<br>    <span class="hljs-comment">//没有class或则checkNil为YES，返回空</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(checkNil &amp;&amp; !cls)) <span class="hljs-keyword">return</span> nil;<br><br><span class="hljs-comment">//确保只有Objective-C 2.0语言的文件所引用</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __OBJC2__</span><br>    <span class="hljs-comment">//判断class有没有默认的allocWithZone方法</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fastpath</span>(!cls-&gt;<span class="hljs-built_in">ISA</span>()-&gt;<span class="hljs-built_in">hasCustomAWZ</span>())) &#123;<br>        <span class="hljs-comment">// class可以快速分配</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fastpath</span>(cls-&gt;<span class="hljs-built_in">canAllocFast</span>())) &#123;<br>            <span class="hljs-comment">//hasCxxDtor();是C++析构函数，判断是否有析构函数</span><br>            <span class="hljs-type">bool</span> dtor = cls-&gt;<span class="hljs-built_in">hasCxxDtor</span>();<br>            <span class="hljs-comment">//申请class的内存空间</span><br>            id obj = (id)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, cls-&gt;bits.<span class="hljs-built_in">fastInstanceSize</span>());<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(!obj)) <span class="hljs-keyword">return</span> <span class="hljs-built_in">callBadAllocHandler</span>(cls);<br>            <span class="hljs-comment">//初始化isa指针</span><br>            obj-&gt;<span class="hljs-built_in">initInstanceIsa</span>(cls, dtor);<br>            <span class="hljs-keyword">return</span> obj;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//使用class_createInstance创建class</span><br>            id obj = <span class="hljs-built_in">class_createInstance</span>(cls, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(!obj)) <span class="hljs-keyword">return</span> <span class="hljs-built_in">callBadAllocHandler</span>(cls);<br>            <span class="hljs-keyword">return</span> obj;<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <br>    <span class="hljs-comment">//说明有默认的allocWithZone的方法，调用allocWithZone方法</span><br>    <span class="hljs-keyword">if</span> (allocWithZone) <span class="hljs-keyword">return</span> [cls allocWithZone:nil];<br>    <span class="hljs-keyword">return</span> [cls alloc];<br>&#125;<br></code></pre></td></tr></table></figure><p>在___OBJC2__下判断当前类没有默认的allocWithZone是通过hasCustomAWZ判断的。YES代表有，则调用allocWithZone。NO代表没有，此时会根据当前class是否可以快速分配，若可以，则直接分配内存并初始化isa指针，否则，调用class_createInstance</p><h2 id="allocWithZone"><a href="#allocWithZone" class="headerlink" title="allocWithZone"></a>allocWithZone</h2><p>源码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC">+ (<span class="hljs-type">id</span>)allocWithZone:(<span class="hljs-keyword">struct</span> _NSZone *)zone &#123;<br>    <span class="hljs-keyword">return</span> _objc_rootAllocWithZone(<span class="hljs-keyword">self</span>, (malloc_zone_t *)zone);<br>&#125;<br><br><span class="hljs-type">id</span> _objc_rootAllocWithZone(Class cls, malloc_zone_t *zone) &#123;<br>    <span class="hljs-type">id</span> obj;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __OBJC2__</span><br>    <span class="hljs-comment">// allocWithZone under __OBJC2__ ignores the zone parameter</span><br>    (<span class="hljs-type">void</span>)zone;<br>    obj = class_createInstance(cls, <span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-keyword">if</span> (!zone) &#123;<br>        obj = class_createInstance(cls, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        obj = class_createInstanceFromZone(cls, <span class="hljs-number">0</span>, zone);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">if</span> (slowpath(!obj)) obj = callBadAllocHandler(cls);<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><p>其本质是调用_objc_rootAllocWithZone函数，该函数分为两种case：</p><ul><li>判断是否是__OBJC2__，若是，则调用class_createInstance</li><li>判断zone是否为空，若为空，则调用class_createInstance，否则调用class_createInstanceFromZone</li></ul><p>这俩函数源码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-comment">//class_createInstance</span><br><span class="hljs-type">id</span> class_createInstance(Class cls, size_t extraBytes) &#123;<br>    <span class="hljs-keyword">return</span> _class_createInstanceFromZone(cls, extraBytes, <span class="hljs-literal">nil</span>);<br>&#125;<br><br><span class="hljs-comment">//class_createInstanceFromZone</span><br><span class="hljs-type">id</span> class_createInstanceFromZone(Class cls, size_t extraBytes, <span class="hljs-type">void</span> *zone) &#123;<br>    <span class="hljs-keyword">return</span> _class_createInstanceFromZone(cls, extraBytes, zone);<br>&#125;<br></code></pre></td></tr></table></figure><p>可见，最终都是调用到_class_createInstanceFromZone。</p><p>另外，通过上述源码可以知道：用alloc方式创建，只要点前类有allocWithZone，则最终是调用_class_createInstanceFromZone</p><h2 id="class-createInstanceFromZone"><a href="#class-createInstanceFromZone" class="headerlink" title="_class_createInstanceFromZone"></a>_class_createInstanceFromZone</h2><p>源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> __attribute__((always_inline)) <br>id<br>_class_createInstanceFromZone(Class cls, <span class="hljs-type">size_t</span> extraBytes, <span class="hljs-type">void</span> *zone, <br>                              <span class="hljs-type">bool</span> cxxConstruct = <span class="hljs-literal">true</span>, <br>                              <span class="hljs-type">size_t</span> *outAllocatedSize = nil) &#123;<br>    <span class="hljs-keyword">if</span> (!cls) <span class="hljs-keyword">return</span> nil;<br><br>    <span class="hljs-built_in">assert</span>(cls-&gt;<span class="hljs-built_in">isRealized</span>());<br><br>    <span class="hljs-type">bool</span> hasCxxCtor = cls-&gt;<span class="hljs-built_in">hasCxxCtor</span>();<span class="hljs-comment">//构造函数</span><br>    <span class="hljs-type">bool</span> hasCxxDtor = cls-&gt;<span class="hljs-built_in">hasCxxDtor</span>();<span class="hljs-comment">//析构函数</span><br>    <span class="hljs-type">bool</span> fast = cls-&gt;<span class="hljs-built_in">canAllocNonpointer</span>(); <span class="hljs-comment">//是对isa的类型的区分，如果一个类不能使用isa_t类型的isa的话，fast就为false，但是在Objective-C 2.0中，大部分类都是支持的</span><br>    <span class="hljs-comment">//在分配内存之前，需要知道对象在内存中的大小，也就是instanceSize的作用。对象必须大于等于16字节。</span><br>    <span class="hljs-type">size_t</span> size = cls-&gt;<span class="hljs-built_in">instanceSize</span>(extraBytes);<br>    <span class="hljs-keyword">if</span> (outAllocatedSize) *outAllocatedSize = size;<br><br>    id obj;<br>    <span class="hljs-keyword">if</span> (!zone  &amp;&amp;  fast) &#123;<br>        <span class="hljs-comment">//分配内存空间</span><br>        obj = (id)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, size);<br>        <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span> nil;<br>        <span class="hljs-comment">//初始化isa指针</span><br>        obj-&gt;<span class="hljs-built_in">initInstanceIsa</span>(cls, hasCxxDtor);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//此时的fast 为 false</span><br>        <span class="hljs-comment">//在C语言中，malloc表示在内存的动态存储区中分配一块长度为“size”字节的连续区域，返回该区域的首地址；calloc表示在内存的动态存储区中分配n块长度为“size”字节的连续区域，返回首地址。</span><br>        <span class="hljs-keyword">if</span> (zone) &#123;<br>            obj = (id)<span class="hljs-built_in">malloc_zone_calloc</span> ((<span class="hljs-type">malloc_zone_t</span> *)zone, <span class="hljs-number">1</span>, size);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            obj = (id)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, size);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span> nil;<br><br>        <span class="hljs-comment">//初始化isa指针</span><br>        obj-&gt;<span class="hljs-built_in">initIsa</span>(cls);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (cxxConstruct &amp;&amp; hasCxxCtor) &#123;<br>        obj = _objc_constructOrFree(obj, cls);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="初始化isa的过程"><a href="#初始化isa的过程" class="headerlink" title="初始化isa的过程"></a>初始化isa的过程</h2><p>我们知道_class_createInstanceFromZone中不仅开辟了内存，还初始化isa。初始化isa的方法有initInstanceIsa和initIsa，但是本质都是调用initIsa(Class cls, bool nonpointer, bool hasCxxDtor)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">objc_object::initIsa</span><span class="hljs-params">(Class cls, <span class="hljs-type">bool</span> nonpointer, <span class="hljs-type">bool</span> hasCxxDtor)</span> </span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-built_in">assert</span>(!<span class="hljs-built_in">isTaggedPointer</span>()); <br>    <br>    <span class="hljs-keyword">if</span> (!nonpointer) &#123;<br>        isa.cls = cls; <span class="hljs-comment">//obj-&gt;initIsa(cls)</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br>        <span class="hljs-built_in">assert</span>(!DisableNonpointerIsa);<br>        <span class="hljs-built_in">assert</span>(!cls-&gt;<span class="hljs-built_in">instancesRequireRawIsa</span>());<br><br>        <span class="hljs-function"><span class="hljs-type">isa_t</span> <span class="hljs-title">newisa</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> SUPPORT_INDEXED_ISA</span><br>        <span class="hljs-built_in">assert</span>(cls-&gt;<span class="hljs-built_in">classArrayIndex</span>() &gt; <span class="hljs-number">0</span>);<br>        newisa.bits = ISA_INDEX_MAGIC_VALUE;<br>        <span class="hljs-comment">// isa.magic is part of ISA_MAGIC_VALUE</span><br>        <span class="hljs-comment">// isa.nonpointer is part of ISA_MAGIC_VALUE</span><br>        newisa.has_cxx_dtor = hasCxxDtor;<br>        newisa.indexcls = (<span class="hljs-type">uintptr_t</span>)cls-&gt;<span class="hljs-built_in">classArrayIndex</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        newisa.bits = ISA_MAGIC_VALUE;<br>        <span class="hljs-comment">// isa.magic is part of ISA_MAGIC_VALUE</span><br>        <span class="hljs-comment">// isa.nonpointer is part of ISA_MAGIC_VALUE</span><br>        newisa.has_cxx_dtor = hasCxxDtor;<br>        newisa.shiftcls = (<span class="hljs-type">uintptr_t</span>)cls &gt;&gt; <span class="hljs-number">3</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-comment">// This write must be performed in a single store in some cases</span><br>        <span class="hljs-comment">// (for example when realizing a class because other threads</span><br>        <span class="hljs-comment">// may simultaneously try to use the class).</span><br>        <span class="hljs-comment">// fixme use atomics here to guarantee single-store and to</span><br>        <span class="hljs-comment">// guarantee memory order w.r.t. the class index table</span><br>        <span class="hljs-comment">// ...but not too atomic because we don&#x27;t want to hurt instantiation</span><br>        isa = newisa;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>nonpointer表示是否开启指针优化，若不优化，则oc对象大isa直接就是isa_t的cls，cls就是oc对象的class；若开启指针优化，则通过newisa(0)初始化一个isa，并根据SUPPORT_INDEXED_ISA分别设置对应的值。</li></ul><p>到这里，alloc的实现过程已经结束了，就是<code>开辟内存+初始化isa</code>。一张图表示：<br><img src="/../images/image-60.png" alt="alt text"></p><h2 id="init"><a href="#init" class="headerlink" title="-init"></a>-init</h2><p>源码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC">- (<span class="hljs-type">id</span>)init &#123;<br>    <span class="hljs-keyword">return</span> _objc_rootInit(<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-type">id</span> _objc_rootInit(<span class="hljs-type">id</span> obj) &#123;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，NSObject的init的默认实现仅仅是返回了当前对象。但是一般我们自己的init需要做一些初始化工作。</p><h2 id="new"><a href="#new" class="headerlink" title="+new"></a>+new</h2><p>源码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC">+ (<span class="hljs-type">id</span>)new &#123;<br>    <span class="hljs-keyword">return</span> [callAlloc(<span class="hljs-keyword">self</span>, <span class="hljs-literal">false</span><span class="hljs-comment">/*checkNil*/</span>) init];<br>&#125;<br></code></pre></td></tr></table></figure><p>等价于alloc init</p><h2 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a>dealloc</h2><p>源码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC">- (<span class="hljs-type">void</span>)dealloc &#123;<br>    _objc_rootDealloc(<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-type">void</span> _objc_rootDealloc(<span class="hljs-type">id</span> obj) &#123;<br>    assert(obj);<br>    obj-&gt;rootDealloc();<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span><br>objc_object::rootDealloc() &#123;<br>    <span class="hljs-keyword">if</span> (isTaggedPointer()) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// fixme necessary?</span><br><br>    <span class="hljs-keyword">if</span> (fastpath(isa.nonpointer  &amp;&amp;  <br>                 !isa.weakly_referenced  &amp;&amp;  <br>                 !isa.has_assoc  &amp;&amp;  <br>                 !isa.has_cxx_dtor  &amp;&amp;  <br>                 !isa.has_sidetable_rc))<br>    &#123;<br>        assert(!sidetable_present());<br>        free(<span class="hljs-variable language_">this</span>);<br>    &#125; <br>    <span class="hljs-keyword">else</span> &#123;<br>        object_dispose((<span class="hljs-type">id</span>)<span class="hljs-variable language_">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>rootDealloc分为三种case：</p><ul><li>若是TaggedPointer，直接return</li><li>进行一些关于isa的条件判断，若是则释放分配的内存</li><li>调用object_dispose</li></ul><h2 id="object-dispose"><a href="#object-dispose" class="headerlink" title="object_dispose"></a>object_dispose</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">id <span class="hljs-title">object_dispose</span><span class="hljs-params">(id obj)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span> nil;<br><br>    <span class="hljs-built_in">objc_destructInstance</span>(obj);    <br>    <span class="hljs-built_in">free</span>(obj);<br><br>    <span class="hljs-keyword">return</span> nil;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>调用objc_destructInstance</li><li>释放内存</li></ul><h2 id="objc-destructInstance"><a href="#objc-destructInstance" class="headerlink" title="objc_destructInstance"></a>objc_destructInstance</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/***********************************************************************</span><br><span class="hljs-comment">* objc_destructInstance</span><br><span class="hljs-comment">* Destroys an instance without freeing memory. </span><br><span class="hljs-comment">* Calls C++ destructors.</span><br><span class="hljs-comment">* Calls ARC ivar cleanup.</span><br><span class="hljs-comment">* Removes associative references.</span><br><span class="hljs-comment">* Returns `obj`. Does nothing if `obj` is nil.</span><br><span class="hljs-comment">**********************************************************************/</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">objc_destructInstance</span><span class="hljs-params">(id obj)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (obj) &#123;<br>        <span class="hljs-comment">// Read all of the flags at once for performance.</span><br>        <span class="hljs-type">bool</span> cxx = obj-&gt;<span class="hljs-built_in">hasCxxDtor</span>();<span class="hljs-comment">//是否有析构函数</span><br>        <span class="hljs-type">bool</span> assoc = obj-&gt;<span class="hljs-built_in">hasAssociatedObjects</span>();<span class="hljs-comment">//是否有关联对象</span><br><br>        <span class="hljs-comment">// This order is important.</span><br>        <span class="hljs-keyword">if</span> (cxx) <span class="hljs-built_in">object_cxxDestruct</span>(obj);<span class="hljs-comment">//调用析构函数</span><br>        <span class="hljs-keyword">if</span> (assoc) _object_remove_assocations(obj);<span class="hljs-comment">//删除关联对象</span><br>        obj-&gt;<span class="hljs-built_in">clearDeallocating</span>();<span class="hljs-comment">//清空引用计数表并清除弱引用表</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>执行object_cxxDestruct，调用oc对象的析构函数</li><li>_object_remove_assocations，删除关联对象</li><li>clearDeallocating清空引用计数表，并清除weak引用表，将所有weak引用设置为nil</li></ul><h2 id="object-cxxDestruct"><a href="#object-cxxDestruct" class="headerlink" title="object_cxxDestruct"></a>object_cxxDestruct</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">object_cxxDestructFromClass</span><span class="hljs-params">(id obj, Class cls)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">void</span> (*dtor)(id);<br><br>    <span class="hljs-comment">// Call cls&#x27;s dtor first, then superclasses&#x27;s dtors.</span><br><br>    <span class="hljs-keyword">for</span> ( ; cls; cls = cls-&gt;superclass) &#123;<br>        <span class="hljs-keyword">if</span> (!cls-&gt;<span class="hljs-built_in">hasCxxDtor</span>()) <span class="hljs-keyword">return</span>; <br>        dtor = (<span class="hljs-built_in">void</span>(*)(id))<br>            <span class="hljs-built_in">lookupMethodInClassAndLoadCache</span>(cls, SEL_cxx_destruct);<br>        <span class="hljs-keyword">if</span> (dtor != (<span class="hljs-built_in">void</span>(*)(id))_objc_msgForward_impcache) &#123;<br>            <span class="hljs-keyword">if</span> (PrintCxxCtors) &#123;<br>                _objc_inform(<span class="hljs-string">&quot;CXX: calling C++ destructors for class %s&quot;</span>, <br>                             cls-&gt;<span class="hljs-built_in">nameForLogging</span>());<br>            &#125;<br>            (*dtor)(obj);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>沿着继承链，向上搜索SEL_cxx_destruct这个selector，知道函数实现并执行，实际就是找到析构函数并执行</li><li>析构函数中如何处理成员变量<ul><li>对于strong来说，执行objc_storeStrong(&amp;ivar, nil)，release成员，ivar变成nil</li><li>对于weak来说，执行objc_destroyWeak(&amp;ivar)，将weak表中的ivar地址</li><li>这里再回忆下weak表的结构，每个strong对象都有一个weak表，表中存放着weak指针，那么当strong对象销毁时，直接删除对应的weak表即可。若对象释放时，将其中的weak指针从weak表中移除</li></ul></li></ul><p>一张图表示过程：<br><img src="/../images/image-61.png" alt="alt text"><br>实际就是，引用计数归0，触发dealloc-&gt;调用自己的析构函数&amp;父类的析构函数-&gt;根据成员是strong还是weak执行对应的释放逻辑</p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>alloc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS-RunLoop面试题分析</title>
    <link href="/2024/03/06/ios-runloop-innterview-question/"/>
    <url>/2024/03/06/ios-runloop-innterview-question/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在面试中，经常会问一些关于RunLoop的问题，需要做点总结，方便复习</p><h2 id="RunLoop的作用"><a href="#RunLoop的作用" class="headerlink" title="RunLoop的作用"></a>RunLoop的作用</h2><ul><li>本质是个结构体，结构体的核心函数就是循环</li><li>没有事件时，RunLoop会进入休眠状态，有时间时，RunLoop调用对应的item去处理事件</li><li>在其他框架中的消息循环</li></ul><h2 id="RunLoop与线程之间的关系"><a href="#RunLoop与线程之间的关系" class="headerlink" title="RunLoop与线程之间的关系"></a>RunLoop与线程之间的关系</h2><ul><li>一一对应，关系保存在全局字典和线程的tsd中</li><li>线程创建时，没有对应runloop，创建发生在第一次获取时，销毁发生在线程下回时</li></ul><h2 id="NSTimer在列表滑动时失效原因-解决"><a href="#NSTimer在列表滑动时失效原因-解决" class="headerlink" title="NSTimer在列表滑动时失效原因&amp;解决"></a>NSTimer在列表滑动时失效原因&amp;解决</h2><ul><li>NSTimer默认运行在runloop的default mode中</li><li>当列表滑动时，runloop切换到tracking mode，所以不会执行timer的回调</li><li>解决：将timer添加到common modes，由于tracking mode也是有common标记的，所以他会将timer添加进来执行</li></ul><h2 id="NSTimer不精准的原因"><a href="#NSTimer不精准的原因" class="headerlink" title="NSTimer不精准的原因"></a>NSTimer不精准的原因</h2><ul><li>NSTimer的回调时基于runloop的，但是runloop为了节省资源可能并不会在非常准确的时间点调用timer回调</li><li>当runloop处理比较繁重的任务时，可能会错过时间点</li></ul><h2 id="NSTimer不精准的解决方式"><a href="#NSTimer不精准的解决方式" class="headerlink" title="NSTimer不精准的解决方式"></a>NSTimer不精准的解决方式</h2><ul><li>使用GCDTimer作为定时器，其基于硬件时间，更加精准</li><li>在子线程中的runloop进行NSTimer的操作，在主线程修改UI</li></ul><h2 id="RunLoop的mode和Common-mode"><a href="#RunLoop的mode和Common-mode" class="headerlink" title="RunLoop的mode和Common mode"></a>RunLoop的mode和Common mode</h2><ul><li>mode是runloop的运行模式，每个runloop同一时间只能运行在特定的mode</li><li>若需要切换mode，则需要重新指定mode进入</li><li>mode可以隔离source0&#x2F;source1&#x2F;observer&#x2F;timer，可以做到互不影响</li><li>常用mode：default&#x2F;tracking</li><li>common mode不是具体mode，只是一个标记，将common mode items中的item添加到具有common标记的mode中，default&#x2F;tracking都有这种标记</li></ul><h2 id="RunLoop中Source0和Source1的区别"><a href="#RunLoop中Source0和Source1的区别" class="headerlink" title="RunLoop中Source0和Source1的区别"></a>RunLoop中Source0和Source1的区别</h2><ul><li>Source0用于app内部事件处理，使用时需要先调用CFRunLoopSourceSignal，将source0标记为待处理，然后手动调用CFRunLoopWakeUp唤醒runloop让其处理</li><li>Source1用于外部事件处理，包含mach_port_t,用于接收系统发来的消息</li><li>Source0的用途：<ul><li>app内部分发触摸事件</li><li>处理performSelector:onThread:withObject:waitUntilDone:</li></ul></li><li>Source1的用途：<ul><li>基于mach_port的线程通信</li><li>系统事件的处理，先分发到Source1，再分发到Source0</li></ul></li></ul><h2 id="RunLoop响应用户操作"><a href="#RunLoop响应用户操作" class="headerlink" title="RunLoop响应用户操作"></a>RunLoop响应用户操作</h2><ul><li>点击屏幕，系统生成事件，通过mach_port传递给app，调用source1处理，分发给source0处理</li></ul><h2 id="RunLoop与UI刷新"><a href="#RunLoop与UI刷新" class="headerlink" title="RunLoop与UI刷新"></a>RunLoop与UI刷新</h2><ul><li>当UI需要更新时，如改变frame，更新UIView，或者手动调用setNeedsLayout，则会标记为待处理</li><li>UIKit注册了beforewaiting的observer和exit的observer，在beforewaiting时，调用CA::Transaction::observer_callback(__CFRunLoopObserver*, unsigned long, void*)() ，遍历所有待处理的view，执行布局，并提交到渲染进程</li></ul><h2 id="RunLoop与AutoreleasePool"><a href="#RunLoop与AutoreleasePool" class="headerlink" title="RunLoop与AutoreleasePool"></a>RunLoop与AutoreleasePool</h2><ul><li>app启动后，主线程创建runloop，也会创建两个observer，回调在_wrapRunLoopWithAutoreleasePoolHandler</li><li>第一个observer金婷entry，回调_objc_autoreleasePoolPush，创建pool，优先级最高</li><li>第二个obser监听beforewaiting和exit，beforewaiting时调用_objc_autoreleasePoolPop释放pool并创建新pool，exit时_objc_autoreleasePoolPop释放pool</li></ul><h2 id="实现线程保活-控制线程生命周期"><a href="#实现线程保活-控制线程生命周期" class="headerlink" title="实现线程保活&amp;控制线程生命周期"></a>实现线程保活&amp;控制线程生命周期</h2><ul><li>一般线程执行完毕后就销毁</li><li>runloop实际就是循环，所以不会让线程销毁</li><li>停止runloop，可以退出线程，调用CFRunLoopStop</li><li>在AFNetworking2.x中就是使用runloop进行线程保活的<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC">+ (<span class="hljs-built_in">NSThread</span> *)networkRequestThread &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">NSThread</span> *_networkRequestThread = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> oncePredicate;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;<br>        _networkRequestThread = [[<span class="hljs-built_in">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="hljs-literal">nil</span>];<br>        [_networkRequestThread start];<br>    &#125;);<br>    <span class="hljs-keyword">return</span> _networkRequestThread;<br>&#125;<br><br>+ (<span class="hljs-type">void</span>)networkRequestThreadEntryPoint:(<span class="hljs-type">id</span>)__unused object &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        [[<span class="hljs-built_in">NSThread</span> currentThread] setName:<span class="hljs-string">@&quot;AFNetworking&quot;</span>];<br>        <span class="hljs-built_in">NSRunLoop</span> *runLoop = [<span class="hljs-built_in">NSRunLoop</span> currentRunLoop];<br>        [runLoop addPort:[<span class="hljs-built_in">NSMachPort</span> port] forMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>];<br>        [runLoop run];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>实现自己控制线程的生命周期</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">TestThreadViewController</span> ()</span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) TestThread *thread;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">TestThreadViewController</span></span><br><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    <br>    <span class="hljs-keyword">self</span>.view.backgroundColor = <span class="hljs-built_in">UIColor</span>.whiteColor;<br>    <br>    __<span class="hljs-keyword">weak</span> __<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) weakSelf = <span class="hljs-keyword">self</span>;<br>    <br>    <span class="hljs-comment">// 这里有个问题要注意: 线程内部会对target造成一个强引用</span><br>    <span class="hljs-comment">// 使用Block形式的API</span><br>    <span class="hljs-keyword">self</span>.thread = [[TestThread alloc] initWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s -----beigin-----&quot;</span>, __func__);<br>        <br>        <span class="hljs-built_in">NSRunLoop</span> *runLoop = [<span class="hljs-built_in">NSRunLoop</span> currentRunLoop];<br>        <span class="hljs-comment">// 添加一个Source1</span><br>        [runLoop addPort:[<span class="hljs-built_in">NSPort</span> port] forMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>];<br>        <span class="hljs-comment">// 调用runloop run, 则runloop就不能被停止，其内部是在不断调用runMode:beforeDate:</span><br>        <span class="hljs-comment">// 不能调用[runLoop run];</span><br>        <br>        <span class="hljs-keyword">while</span> (weakSelf) &#123;<br>            [runLoop runMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="hljs-built_in">NSDate</span> distantFuture]];<br>        &#125;<br>        <br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s -----end-----&quot;</span>, __func__);<br>    &#125;];<br>    <br>    [<span class="hljs-keyword">self</span>.thread start];<br>    <br>    <span class="hljs-built_in">UIButton</span> *button = [<span class="hljs-built_in">UIButton</span> buttonWithType:<span class="hljs-built_in">UIButtonTypeCustom</span>];<br>    button.frame = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">30</span>, <span class="hljs-number">20</span>);<br>    button.backgroundColor = <span class="hljs-built_in">UIColor</span>.redColor;<br>    [<span class="hljs-keyword">self</span>.view addSubview:button];<br>    [button addTarget:<span class="hljs-keyword">self</span> action:<span class="hljs-keyword">@selector</span>(_didButtonPressed:) forControlEvents:<span class="hljs-built_in">UIControlEventTouchUpInside</span>];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)dealloc &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ dealloc&quot;</span>, <span class="hljs-keyword">self</span>.class);<br>    <br>    <span class="hljs-comment">// 下面的代码就是说在子线程中执行threadStop方法</span><br>    <span class="hljs-comment">// 这里要注意waitUntilDone的用法</span><br>    <span class="hljs-comment">// 如果传入NO，该方法会直接返回执行后续的代码，这样会出现问题</span><br>    <span class="hljs-comment">// 如果传入YES，代表必须等到子线程执行完threadStop方法才能执行后面的代码</span><br>    [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(threadStop)<br>                 onThread:<span class="hljs-keyword">self</span>.thread<br>               withObject:<span class="hljs-literal">nil</span><br>            waitUntilDone:<span class="hljs-literal">YES</span>];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)_didButtonPressed:(<span class="hljs-type">id</span>)sender &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;开始销毁页面&quot;</span>);<br>    [<span class="hljs-keyword">self</span> dismissViewControllerAnimated:<span class="hljs-literal">YES</span> completion:<span class="hljs-literal">nil</span>];<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - 线程保活</span><br><br>- (<span class="hljs-type">void</span>)threadPerformingTasks &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ %s&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread], __func__);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)threadStop &#123;<br>    <span class="hljs-built_in">CFRunLoopStop</span>(<span class="hljs-built_in">CFRunLoopGetCurrent</span>());<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;触发点击事件&quot;</span>);<br>    [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(threadPerformingTasks)<br>                 onThread:<span class="hljs-keyword">self</span>.thread<br>               withObject:<span class="hljs-literal">nil</span><br>            waitUntilDone:<span class="hljs-literal">NO</span>];<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>核心就是调用[runLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];，该函数仅执行1次，方便我们控制</p><h2 id="RunLoop与NSURLSession"><a href="#RunLoop与NSURLSession" class="headerlink" title="RunLoop与NSURLSession"></a>RunLoop与NSURLSession</h2><ul><li>NSURLSession底层通过CFSokect请求</li><li>并发请求，请求完毕后通知常驻的子线程，子线程通知主线程结果</li></ul><h2 id="RunLoop相关的api"><a href="#RunLoop相关的api" class="headerlink" title="RunLoop相关的api"></a>RunLoop相关的api</h2><p>以下代码输出啥：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC">- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    <span class="hljs-built_in">NSInteger</span> number = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%zd&quot;</span>, number);<br>    <br>    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>        [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(printString) withObject:<span class="hljs-literal">nil</span> afterDelay:<span class="hljs-number">0</span>];<br>    &#125;);<br>    <br>    number = <span class="hljs-number">3</span>;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%zd&quot;</span>, number);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)printString &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;sdasdas&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>答案是只会输出1和3，因为performSelector这样的api依赖于runloop，而子线程默认没有runloop，因而不会执行</p><p>ps：与延迟有关的perform api，实际会被封装为timer加入到runloop中</p><h2 id="RunLoop休眠的实现"><a href="#RunLoop休眠的实现" class="headerlink" title="RunLoop休眠的实现"></a>RunLoop休眠的实现</h2><ul><li>runloop调用mach_msg使得线程进入休眠状态，等待被唤醒</li></ul><h2 id="RunLoop的执行流程"><a href="#RunLoop的执行流程" class="headerlink" title="RunLoop的执行流程"></a>RunLoop的执行流程</h2><p><img src="/../images/image-59.png" alt="alt text"></p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>RunLoop</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS-RunLoop复习</title>
    <link href="/2024/03/05/ios-runloop-review/"/>
    <url>/2024/03/05/ios-runloop-review/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前在深入理解RunLoop中已经看过了RunLoop源码，本文再付下下</p><h2 id="RunLoop获取"><a href="#RunLoop获取" class="headerlink" title="RunLoop获取"></a>RunLoop获取</h2><ul><li>主线程自带runloop</li><li>其他线程的runloop在第一次获取时被创建<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 获取主线程的RunLoop</span><br><span class="hljs-function">CFRunLoopRef <span class="hljs-title">CFRunLoopGetMain</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-built_in">CHECK_FOR_FORK</span>(); <span class="hljs-comment">// 判断是否需要fork进程</span><br>    <span class="hljs-type">static</span> CFRunLoopRef __main = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// no retain needed</span><br>    <span class="hljs-keyword">if</span> (!__main) __main = _CFRunLoopGet0(<span class="hljs-built_in">pthread_main_thread_np</span>()); <span class="hljs-comment">// no CAS needed</span><br>    <span class="hljs-keyword">return</span> __main;<br>&#125;<br><br><span class="hljs-comment">// 获取当前线程的RunLoop</span><br><span class="hljs-function">CFRunLoopRef <span class="hljs-title">CFRunLoopGetCurrent</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-built_in">CHECK_FOR_FORK</span>();<br>    <span class="hljs-comment">// 先从TSD中查找有没有相关的runloop信息，有则返回。</span><br>    <span class="hljs-comment">// 我们可以理解为runloop不光存在与全局字典中，也存在中TSD中。</span><br>    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);<br>    <span class="hljs-keyword">if</span> (rl) <span class="hljs-keyword">return</span> rl;<br>    <span class="hljs-keyword">return</span> _CFRunLoopGet0(<span class="hljs-built_in">pthread_self</span>());<br>&#125;<br></code></pre></td></tr></table></figure></li><li>获取主线程runloop，会将结果缓存到__main变量，下次直接获取</li><li>获取当前线程runloop，首先在tsd中获取，若tsd获取不到，则则全局dict获取，之后将其缓存到tsd</li></ul><h2 id="RunLoop与线程之间的关系"><a href="#RunLoop与线程之间的关系" class="headerlink" title="RunLoop与线程之间的关系"></a>RunLoop与线程之间的关系</h2><p>看_CFRunLoopGet0源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(<span class="hljs-type">pthread_t</span> t) &#123;<br>    <span class="hljs-comment">// 当前线程为0，则取主线程</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_equal</span>(t, kNilPthreadT)) &#123;<br>        t = <span class="hljs-built_in">pthread_main_thread_np</span>();<br>    &#125;<br>    __CFLock(&amp;loopsLock);<br>    <span class="hljs-comment">// __CFRunLoops是一个全局的静态字典。</span><br>    <span class="hljs-comment">// 如果该字典为空，就进行以下操作：</span><br>    <span class="hljs-comment">// 1.创建一个临时字典；</span><br>    <span class="hljs-comment">// 2.创建主线程的RunLoop，并将它存到临时字典里</span><br>    <span class="hljs-comment">// 3.OSAtomicCompareAndSwapPtrBarrier用来将这个临时字典复制到全局字典里；</span><br>    <span class="hljs-comment">// 并且使用了锁机制确保上述操作的安全性。</span><br>    <span class="hljs-keyword">if</span> (!__CFRunLoops) &#123;<br>        __CFUnlock(&amp;loopsLock);<br>        CFMutableDictionaryRef dict = <span class="hljs-built_in">CFDictionaryCreateMutable</span>(kCFAllocatorSystemDefault, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);<br>        CFRunLoopRef mainLoop = __CFRunLoopCreate(<span class="hljs-built_in">pthread_main_thread_np</span>());<br>        <span class="hljs-built_in">CFDictionarySetValue</span>(dict, <span class="hljs-built_in">pthreadPointer</span>(<span class="hljs-built_in">pthread_main_thread_np</span>()), mainLoop);<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">OSAtomicCompareAndSwapPtrBarrier</span>(<span class="hljs-literal">NULL</span>, dict, (<span class="hljs-type">void</span> * <span class="hljs-keyword">volatile</span> *)&amp;__CFRunLoops)) &#123;<br>            <span class="hljs-built_in">CFRelease</span>(dict);<br>        &#125;<br>        <span class="hljs-built_in">CFRelease</span>(mainLoop);<br>        __CFLock(&amp;loopsLock);<br>    &#125;<br>    <span class="hljs-comment">// 当前线程RunLoop的获取，获取不到就使用__CFRunLoopCreate创建一个RunLoop，并保存在全局字典里</span><br>    CFRunLoopRef loop = (CFRunLoopRef)<span class="hljs-built_in">CFDictionaryGetValue</span>(__CFRunLoops, <span class="hljs-built_in">pthreadPointer</span>(t));<br>    __CFUnlock(&amp;loopsLock);<br>    <span class="hljs-comment">// 此处创建runloop</span><br>    <span class="hljs-keyword">if</span> (!loop) &#123;<br>        CFRunLoopRef newLoop = __CFRunLoopCreate(t);<br>        __CFLock(&amp;loopsLock);<br>        <span class="hljs-comment">// 为啥要再取一次，实际就是double check，防止多线程同时进入了if，重复创建</span><br>        loop = (CFRunLoopRef)<span class="hljs-built_in">CFDictionaryGetValue</span>(__CFRunLoops, <span class="hljs-built_in">pthreadPointer</span>(t));<br>        <span class="hljs-keyword">if</span> (!loop) &#123;<br>            <span class="hljs-built_in">CFDictionarySetValue</span>(__CFRunLoops, <span class="hljs-built_in">pthreadPointer</span>(t), newLoop);<br>            loop = newLoop;<br>        &#125;<br>        <span class="hljs-comment">// don&#x27;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span><br>        __CFUnlock(&amp;loopsLock);<br>        <span class="hljs-built_in">CFRelease</span>(newLoop);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_equal</span>(t, <span class="hljs-built_in">pthread_self</span>())) &#123;<br>        <span class="hljs-comment">// t为当前线程的话，将loop保存在线程私有数据中</span><br>        _CFSetTSD(__CFTSDKeyRunLoop, (<span class="hljs-type">void</span> *)loop, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-comment">// __CFFinalizeRunLoop是RunLoop的析构函数，</span><br>        <span class="hljs-comment">// PTHREAD_DESTRUCTOR_ITERATIONS 表示是线程退出时销毁线程私有数据的最大次数</span><br>        <span class="hljs-comment">// 这也是RunLoop的释放时机--线程退出的时候</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;<br>            <span class="hljs-comment">// 注册一个回调，当线程销毁时，顺便也销毁其对应的RunLoop</span><br>            _CFSetTSD(__CFTSDKeyRunLoopCntr, (<span class="hljs-type">void</span> *)(PTHREAD_DESTRUCTOR_ITERATIONS<span class="hljs-number">-1</span>), (<span class="hljs-built_in">void</span> (*)(<span class="hljs-type">void</span> *))__CFFinalizeRunLoop);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> loop;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述源码可知：</p><ul><li>RunLoop和线程之间是意义对应，关系保存global dict和线程的tsd中</li><li>global dict以线程为key，runloop为value保存映射关系</li><li>线程创建时没有对应runloop，创建发生在首次获取runloop时</li><li>runloop的销毁在__CFFinalizeRunLoop</li></ul><h2 id="RunLoop的创建"><a href="#RunLoop的创建" class="headerlink" title="RunLoop的创建"></a>RunLoop的创建</h2><p>从_CFRunLoopGet0的实现可以知道，runloop的创建通过调用__CFRunLoopCreate返回一个CFRunLoopRef，函数分为两步：</p><ul><li>使用_CFRuntimeCreateInstance创建CFRunLoopRef实例</li><li>对CFRunLoopRef初始化，包括调用__CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, true);</li></ul><p>另外在__CFRunLoopFindMode用到了runloop定时器，用宏判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEPLOYMENT_TARGET_MACOSX</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> USE_DISPATCH_SOURCE_FOR_TIMERS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> USE_MK_TIMER_TOO 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> USE_DISPATCH_SOURCE_FOR_TIMERS 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> USE_MK_TIMER_TOO 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="RunLoop的释放"><a href="#RunLoop的释放" class="headerlink" title="RunLoop的释放"></a>RunLoop的释放</h2><p>runloop的释放发生在销毁时，在__CFTSDGetTable中包含代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">pthread_key_init_np</span>(CF_TSD_KEY, __CFTSDFinalize);<br></code></pre></td></tr></table></figure><p>该函数指定了析构函数，其源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __CFTSDFinalize(<span class="hljs-type">void</span> *arg) &#123;<br>    __CFTSDSetSpecific(arg);<br><br>    <span class="hljs-keyword">if</span> (!arg || arg == CF_TSD_BAD_PTR) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    __CFTSDTable *table = (__CFTSDTable *)arg;<br>    table-&gt;destructorCount++;<br>        <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int32_t</span> i = <span class="hljs-number">0</span>; i &lt; CF_TSD_MAX_SLOTS; i++) &#123;<br>        <span class="hljs-keyword">if</span> (table-&gt;data[i] &amp;&amp; table-&gt;destructors[i]) &#123;<br>            <span class="hljs-type">uintptr_t</span> old = table-&gt;data[i];<br>            table-&gt;data[i] = (<span class="hljs-type">uintptr_t</span>)<span class="hljs-literal">NULL</span>;<br>            table-&gt;destructors[i]((<span class="hljs-type">void</span> *)(old));<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (table-&gt;destructorCount == PTHREAD_DESTRUCTOR_ITERATIONS - <span class="hljs-number">1</span>) &#123;    <span class="hljs-comment">// On PTHREAD_DESTRUCTOR_ITERATIONS-1 call, destroy our data</span><br>        <span class="hljs-built_in">free</span>(table);<br>        <br>        __CFTSDSetSpecific(CF_TSD_BAD_PTR);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，tsd table会遍历data和destructors数据，把old变量作为destructors的参数，table-&gt;destructors[i]((void *)(old));相当于调用析构函数。所以runloop的析构函数是存到destructors的，线程退出是，就会调用析构函数释放runloop。<code>简单来说：线程结束-&gt;释放tsd-&gt;调用tsd中数据的析构函数</code></p><p>看下__CFFinalizeRunLoop源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Called for each thread as it exits</span><br>CF_PRIVATE <span class="hljs-type">void</span> __CFFinalizeRunLoop(<span class="hljs-type">uintptr_t</span> data) &#123;<br>    CFRunLoopRef rl = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (data &lt;= <span class="hljs-number">1</span>) &#123;<br>        __CFLock(&amp;loopsLock);<br>        <span class="hljs-keyword">if</span> (__CFRunLoops) &#123;<br>            rl = (CFRunLoopRef)<span class="hljs-built_in">CFDictionaryGetValue</span>(__CFRunLoops, <span class="hljs-built_in">pthreadPointer</span>(<span class="hljs-built_in">pthread_self</span>()));<br>            <span class="hljs-keyword">if</span> (rl) <span class="hljs-built_in">CFRetain</span>(rl);<br>            <span class="hljs-comment">// 移除全局字典中RunLoop与线程之间的映射关系</span><br>            <span class="hljs-built_in">CFDictionaryRemoveValue</span>(__CFRunLoops, <span class="hljs-built_in">pthreadPointer</span>(<span class="hljs-built_in">pthread_self</span>()));<br>        &#125;<br>        __CFUnlock(&amp;loopsLock);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 递归移除</span><br>        _CFSetTSD(__CFTSDKeyRunLoopCntr, (<span class="hljs-type">void</span> *)(data - <span class="hljs-number">1</span>), (<span class="hljs-built_in">void</span> (*)(<span class="hljs-type">void</span> *))__CFFinalizeRunLoop);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rl &amp;&amp; <span class="hljs-built_in">CFRunLoopGetMain</span>() != rl) &#123; <span class="hljs-comment">// protect against cooperative threads</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != rl-&gt;_counterpart) &#123;<br>            <span class="hljs-built_in">CFRelease</span>(rl-&gt;_counterpart);<br>            rl-&gt;_counterpart = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-comment">// purge all sources before deallocation</span><br>        CFArrayRef array = <span class="hljs-built_in">CFRunLoopCopyAllModes</span>(rl);<br>        <span class="hljs-keyword">for</span> (CFIndex idx = <span class="hljs-built_in">CFArrayGetCount</span>(array); idx--;) &#123;<br>            CFStringRef modeName = (CFStringRef)<span class="hljs-built_in">CFArrayGetValueAtIndex</span>(array, idx);<br>             <span class="hljs-comment">// 移除RunLoop中的mode</span><br>            __CFRunLoopRemoveAllSources(rl, modeName);<br>        &#125;<br>        <span class="hljs-comment">// 移除RunLoop中的common mode</span><br>        __CFRunLoopRemoveAllSources(rl, kCFRunLoopCommonModes);<br>        <span class="hljs-built_in">CFRelease</span>(array);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rl) <span class="hljs-built_in">CFRelease</span>(rl);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="RunLoop的相关类和作用"><a href="#RunLoop的相关类和作用" class="headerlink" title="RunLoop的相关类和作用"></a>RunLoop的相关类和作用</h2><p>我们之前，核心类包括CFRunLoopRef，CFRunLoopModeRef，CFRunLoopSourceRef，CFRunLoopObserverRef，CFRunLoopTimerRef，关系如图：<br><img src="/../images/image-56.png" alt="alt text"></p><h3 id="CFRunLoopRef"><a href="#CFRunLoopRef" class="headerlink" title="CFRunLoopRef"></a>CFRunLoopRef</h3><p>对应__CFRunLoop：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__CFRunLoop</span> &#123;<br>    <span class="hljs-comment">// 省略其他成员变量</span><br>    ...<br>    <span class="hljs-comment">// common mode的集合</span><br>    CFMutableSetRef _commonModes;<br>    <span class="hljs-comment">// 每个common mode都有的item(source,timer and observer)集合</span><br>    CFMutableSetRef _commonModeItems;<br>    <span class="hljs-comment">// 当前runloop的mode</span><br>    CFRunLoopModeRef _currentMode;<br>    <span class="hljs-comment">// 所有的mode的集合</span><br>    CFMutableSetRef _modes;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>一个runloop可以包含几个mode，但是只能指定一个mode执行，取决于currentMode。该变量赋值在CFRunLoopRunSpecific中</p><h3 id="CFRunLoopModeRef"><a href="#CFRunLoopModeRef" class="headerlink" title="CFRunLoopModeRef"></a>CFRunLoopModeRef</h3><p>对应__CFRunLoopMode:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__CFRunLoopMode</span> &#123;<br>    CFStringRef _name;<br>    <span class="hljs-comment">// source0的集合</span><br>    CFMutableSetRef _sources0;<br>    <span class="hljs-comment">// source1的集合</span><br>    CFMutableSetRef _sources1;<br>    <span class="hljs-comment">// observer的数组</span><br>    CFMutableArrayRef _observers;<br>    <span class="hljs-comment">// timer的数组</span><br>    CFMutableArrayRef _timers;<br>    <span class="hljs-comment">// 省略其他属性</span><br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>在mode中包含要处理的一些任务的封装，如source&#x2F;observer&#x2F;timer。runloop切换mode必须先退出loop，再重新指定mode，好处是不同的mode相互隔离，提高执行效率。</p><h3 id="RunLoop的Mode"><a href="#RunLoop的Mode" class="headerlink" title="RunLoop的Mode"></a>RunLoop的Mode</h3><p>5种：</p><ul><li>kCFRunLoopDefaultMode：默认</li><li>UITrackingRunLoopMode：优先追踪列表滑动</li><li>UIInitializationRunLoopMode：app启动时的第一个mode，后续切到default后不再使用</li><li>GSEventReceiveRunLoopMode：接受系统事件的内部mode</li><li>kCFRunLoopCommonModes：一种标记，并不是真正的mode，标记为commonMode的mode总是会执行commonModeItems中的任务</li></ul><h3 id="CommonModes"><a href="#CommonModes" class="headerlink" title="CommonModes"></a>CommonModes</h3><p>之前说过了，以CFRunLoopAddSource为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CFRunLoopAddSource</span><span class="hljs-params">(CFRunLoopRef rl, CFRunLoopSourceRef rls, CFStringRef modeName)</span> </span>&#123;<br>    <span class="hljs-comment">// 该Mode是CommonMode</span><br>    <span class="hljs-keyword">if</span> (modeName == kCFRunLoopCommonModes) &#123;<br>        <span class="hljs-comment">// _commonModes存在则获取一份数据拷贝</span><br>        CFSetRef set = rl-&gt;_commonModes ? <span class="hljs-built_in">CFSetCreateCopy</span>(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == rl-&gt;_commonModeItems) &#123;<br>            <span class="hljs-comment">// _commonModeItems不存在创建一个新的集合</span><br>            rl-&gt;_commonModeItems = <span class="hljs-built_in">CFSetCreateMutable</span>(kCFAllocatorSystemDefault, <span class="hljs-number">0</span>, &amp;kCFTypeSetCallBacks);<br>        &#125;<br>        <span class="hljs-comment">// 将source添加到_commonModeItems</span><br>        <span class="hljs-built_in">CFSetAddValue</span>(rl-&gt;_commonModeItems, rls);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != set) &#123;<br>            CFTypeRef context[<span class="hljs-number">2</span>] = &#123;rl, rls&#125;;<br>            <span class="hljs-comment">// 调用__CFRunLoopAddItemToCommonModes函数向_commonModes中所有的Mode添加这个source</span><br>            <span class="hljs-built_in">CFSetApplyFunction</span>(set, (__CFRunLoopAddItemToCommonModes), (<span class="hljs-type">void</span> *)context);<br>            <span class="hljs-built_in">CFRelease</span>(set);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可见，即使将其加入到commonModeItems中，确保无论哪个mode都能执行。<br>关于NSTimer为啥在列表滑动是失效，说烂了都，加到commonMode！</p><h2 id="CFRunLoopSourceRef"><a href="#CFRunLoopSourceRef" class="headerlink" title="CFRunLoopSourceRef"></a>CFRunLoopSourceRef</h2><p>对应__CFRunLoopSource：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__CFRunLoopSource</span> &#123;<br>    CFRuntimeBase _base;<br>    <span class="hljs-type">uint32_t</span> _bits;<br>    <span class="hljs-type">pthread_mutex_t</span> _lock;<br>    CFIndex _order;<span class="hljs-comment">/* immutable */</span><br>    CFMutableBagRef _runLoops;<br>    <span class="hljs-keyword">union</span> &#123;<br>        CFRunLoopSourceContext version0;<span class="hljs-comment">/* immutable, except invalidation */</span><br>        CFRunLoopSourceContext1 version1;<span class="hljs-comment">/* immutable, except invalidation */</span><br>    &#125; _context;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中version0和version1分别对应source0和source1</p><h3 id="Source0"><a href="#Source0" class="headerlink" title="Source0"></a>Source0</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    CFIndexversion;<br>    <span class="hljs-type">void</span> *info;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span> *(*retain)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *info);<br>    <span class="hljs-built_in">void</span>(*release)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *info);<br>    <span class="hljs-built_in">CFStringRef</span>(*copyDescription)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *info);<br>    <span class="hljs-built_in">Boolean</span>(*equal)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *info1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *info2);<br>    <span class="hljs-built_in">CFHashCode</span>(*hash)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *info);<br>    <span class="hljs-comment">// 当source被添加到RunLoop中后，会调用这个指针</span><br>    <span class="hljs-built_in">void</span>(*schedule)(<span class="hljs-type">void</span> *info, CFRunLoopRef rl, CFRunLoopMode mode);<br>    <span class="hljs-comment">// 当调CFRunLoopSourceInvalidate函数移除该source的时候，会调用这个指针</span><br>    <span class="hljs-built_in">void</span>(*cancel)(<span class="hljs-type">void</span> *info, CFRunLoopRef rl, CFRunLoopMode mode);<br>    <span class="hljs-comment">// RunLoop处理Source0的时候，会调用这个指针</span><br>    <span class="hljs-built_in">void</span>(*perform)(<span class="hljs-type">void</span> *info);<br>&#125; CFRunLoopSourceContext;<br></code></pre></td></tr></table></figure><p>Source0是内部传递事件调用的，使用时，需要调用CFRunLoopSourceSignal将该Source0标记为待处理，然后手动调用CFRunLoopWakeUp唤醒runloop，让其处理。</p><p>RunLoop通过__CFRunLoopDoSources0来处理Source0，实现源码中包含：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (__CFRunLoopSourceIsSignaled(rls)) &#123;<br>    __CFRunLoopSourceUnsetSignaled(rls);<br>    <span class="hljs-keyword">if</span> (__CFIsValid(rls)) &#123;<br>        __CFRunLoopSourceUnlock(rls);<br>        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(rls-&gt;_context.version0.perform, rls-&gt;_context.version0.info);<br>        <span class="hljs-built_in">CHECK_FOR_FORK</span>();<br>        sourceHandled = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        __CFRunLoopSourceUnlock(rls);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>即先判断Source0是否被标记，若标记，先取消标记并处理。所以必须先标记，该标记函数为__CFRunLoopSourceSetSignaled：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// CFRunLoopSourceSignal函数是对外公开的。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CFRunLoopSourceSignal</span><span class="hljs-params">(CFRunLoopSourceRef rls)</span> </span>&#123;<br>    <span class="hljs-built_in">CHECK_FOR_FORK</span>();<br>    __CFRunLoopSourceLock(rls);<br>    <span class="hljs-keyword">if</span> (__CFIsValid(rls)) &#123;<br>        __CFRunLoopSourceSetSignaled(rls);<br>    &#125;<br>    __CFRunLoopSourceUnlock(rls);<br>&#125;<br></code></pre></td></tr></table></figure><p>一般调用Source0的情况：</p><ul><li>触摸事件的分发</li><li>调用performSelector:onThread:withObject:waitUntilDone:</li></ul><h3 id="Source1"><a href="#Source1" class="headerlink" title="Source1"></a>Source1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    CFIndexversion;<br>    <span class="hljs-type">void</span> *info;<br>    <span class="hljs-type">const</span> <span class="hljs-type">void</span> *(*retain)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *info);<br>    <span class="hljs-built_in">void</span>(*release)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *info);<br>    <span class="hljs-built_in">CFStringRef</span>(*copyDescription)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *info);<br>    <span class="hljs-built_in">Boolean</span>(*equal)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *info1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *info2);<br>    <span class="hljs-built_in">CFHashCode</span>(*hash)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *info);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (TARGET_OS_MAC &amp;&amp; !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)) || (TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)</span><br>    <span class="hljs-built_in">mach_port_t</span>(*getPort)(<span class="hljs-type">void</span> *info);<br>    <span class="hljs-type">void</span> *(*perform)(<span class="hljs-type">void</span> *msg, CFIndex size, CFAllocatorRef allocator, <span class="hljs-type">void</span> *info);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-type">void</span> *(*getPort)(<span class="hljs-type">void</span> *info);<br>    <span class="hljs-built_in">void</span>(*perform)(<span class="hljs-type">void</span> *info);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125; CFRunLoopSourceContext1;<br></code></pre></td></tr></table></figure><p>Source1中有个mach_port_t,用于接收系统事件。<br>一般source1的情况：</p><ul><li>进程内不同线程基于mach port通信</li><li>系统进程和app进程基于mach port进行ipc通信，如触摸屏事件，系统发到app进程，使用source0处理，然后分发到source1</li></ul><h2 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h2><p>对应__CFRunLoopObserver，其实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__CFRunLoopObserver</span> &#123;<br>    CFRuntimeBase _base;<br>    <span class="hljs-type">pthread_mutex_t</span> _lock;<br>    CFRunLoopRef _runLoop;<br>    CFIndex _rlCount;<br>    CFOptionFlags _activities;<span class="hljs-comment">/* immutable */</span><br>    CFIndex _order;<span class="hljs-comment">/* immutable */</span><br>    CFRunLoopObserverCallBack _callout;<span class="hljs-comment">/* immutable */</span><br>    CFRunLoopObserverContext _context;<span class="hljs-comment">/* immutable, except invalidation */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>每个observer都包含回调，当runloop状态变化时，会调用对应observer，runloop状态包含：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">CF_OPTIONS</span><span class="hljs-params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;<br>    kCFRunLoopEntry = (<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">0</span>), <span class="hljs-comment">// 即将进入loop</span><br>    kCFRunLoopBeforeTimers = (<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">1</span>), <span class="hljs-comment">// 即将处理Timer</span><br>    kCFRunLoopBeforeSources = (<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">2</span>), <span class="hljs-comment">// 即将处理Source</span><br>    kCFRunLoopBeforeWaiting = (<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">5</span>), <span class="hljs-comment">// 即将进入休眠</span><br>    kCFRunLoopAfterWaiting = (<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">6</span>), <span class="hljs-comment">// 结束休眠或被唤醒</span><br>    kCFRunLoopExit = (<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">7</span>), <span class="hljs-comment">// 退出loop</span><br>    kCFRunLoopAllActivities = <span class="hljs-number">0x0FFFFFFF</span>U<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用observer的情况：</p><ul><li>监听runloop状态</li><li>ui刷新（在beforewaiting之前将事务提交到渲染进程）</li><li>autorelease pool释放</li></ul><h2 id="CFRunLoopTimerRef"><a href="#CFRunLoopTimerRef" class="headerlink" title="CFRunLoopTimerRef"></a>CFRunLoopTimerRef</h2><p>对应着__CFRunLoopTimer，实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__CFRunLoopTimer</span> &#123;<br>    CFRuntimeBase _base;<br>    <span class="hljs-type">uint16_t</span> _bits;<br>    <span class="hljs-type">pthread_mutex_t</span> _lock;<br>    CFRunLoopRef _runLoop;<br>    CFMutableSetRef _rlModes;<br>    CFAbsoluteTime _nextFireDate;<br>    CFTimeInterval _interval;<span class="hljs-comment">/* immutable */</span><br>    CFTimeInterval _tolerance;          <span class="hljs-comment">/* mutable */</span><br>    <span class="hljs-type">uint64_t</span> _fireTSR;<span class="hljs-comment">/* TSR units */</span><br>    CFIndex _order;<span class="hljs-comment">/* immutable */</span><br>    CFRunLoopTimerCallBack _callout;<span class="hljs-comment">/* immutable */</span><br>    CFRunLoopTimerContext _context;<span class="hljs-comment">/* immutable, except invalidation */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>使用timer的情况：</p><ul><li>NSTimer</li><li>performSelector:withObject:afterDelay:</li></ul><h2 id="RunLoop运行"><a href="#RunLoop运行" class="headerlink" title="RunLoop运行"></a>RunLoop运行</h2><h3 id="CFRunLoopRun"><a href="#CFRunLoopRun" class="headerlink" title="CFRunLoopRun"></a>CFRunLoopRun</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CFRunLoopRun</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">int32_t</span> result;<br>    <span class="hljs-keyword">do</span> &#123;<br>        result = <span class="hljs-built_in">CFRunLoopRunSpecific</span>(<span class="hljs-built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class="hljs-number">1.0e10</span>, <span class="hljs-literal">false</span>);<br>        <span class="hljs-built_in">CHECK_FOR_FORK</span>();<br>    &#125; <span class="hljs-keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);<br>&#125;<br></code></pre></td></tr></table></figure><p>在default mode下运行，一旦开启就会无限循环</p><h3 id="CFRunLoopRunInMode"><a href="#CFRunLoopRunInMode" class="headerlink" title="CFRunLoopRunInMode"></a>CFRunLoopRunInMode</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">SInt32 <span class="hljs-title">CFRunLoopRunInMode</span><span class="hljs-params">(CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span> </span>&#123;     <span class="hljs-comment">/* DOES CALLOUT */</span><br>    <span class="hljs-built_in">CHECK_FOR_FORK</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">CFRunLoopRunSpecific</span>(<span class="hljs-built_in">CFRunLoopGetCurrent</span>(), modeName, seconds, returnAfterSourceHandled);<br>&#125;<br></code></pre></td></tr></table></figure><p>可见，无论是哪种，都会调用CFRunLoopRunSpecific</p><h3 id="CFRunLoopRunSpecific"><a href="#CFRunLoopRunSpecific" class="headerlink" title="CFRunLoopRunSpecific"></a>CFRunLoopRunSpecific</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">SInt32 <span class="hljs-title">CFRunLoopRunSpecific</span><span class="hljs-params">(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span> </span>&#123;<br>    <span class="hljs-comment">// 第1步：通知Observers，进入loop</span><br>    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);<br>    <span class="hljs-comment">// 具体要做的事情</span><br>    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);<br>    <span class="hljs-comment">// 第10步：通知Observers，退出loop</span><br>    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);<br>    <br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CFRunLoopRun-1"><a href="#CFRunLoopRun-1" class="headerlink" title="__CFRunLoopRun"></a>__CFRunLoopRun</h3><p>是runloop的核心逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-type">int32_t</span> __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;<br>    <span class="hljs-type">int32_t</span> retVal = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">// 第2步：通知Observers，即将处理Timers</span><br>        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);<br>        <span class="hljs-comment">// 第3步：通知Observers，即将处理Source</span><br>        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);<br>        <span class="hljs-comment">// 处理Blocks</span><br>        __CFRunLoopDoBlocks(rl, rlm);<br>        <br>        <span class="hljs-comment">// 第4步：处理Source0</span><br>        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);<br>        <span class="hljs-keyword">if</span> (sourceHandledThisLoop) &#123;<br>            <span class="hljs-comment">// 处理Blocks</span><br>            __CFRunLoopDoBlocks(rl, rlm);<br>        &#125;<br>        <br>        Boolean poll = sourceHandledThisLoop || (<span class="hljs-number">0ULL</span> == timeout_context-&gt;termTSR);<br>        <br>        <span class="hljs-comment">// 第5步：判断有无Source1，有Source1，跳转到handle_msg</span><br>        <span class="hljs-keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="hljs-built_in">sizeof</span>(msg_buffer), &amp;livePort, <span class="hljs-number">0</span>, &amp;voucherState, <span class="hljs-literal">NULL</span>)) &#123;<br>            <span class="hljs-comment">// </span><br>            <span class="hljs-keyword">goto</span> handle_msg;<br>        &#125;<br>        <br>        didDispatchPortLastTime = <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-comment">// 第6步：通知Observers，即将进入休眠</span><br>        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);<br>        <br>        <span class="hljs-comment">// RunLoop休眠</span><br>        __CFRunLoopSetSleeping(rl);<br>        <br>        CFAbsoluteTime sleepStart = poll ? <span class="hljs-number">0.0</span> : <span class="hljs-built_in">CFAbsoluteTimeGetCurrent</span>();<br>        <br>        <span class="hljs-comment">// 第7步：等待别的消息来唤醒，如果没有被唤醒那就不会执行下面的代码</span><br>        <span class="hljs-comment">// 这些消息可能是：</span><br>        <span class="hljs-comment">// 一个基于port的Source的事件。</span><br>        <span class="hljs-comment">// 一个Timer到时间了</span><br>        <span class="hljs-comment">// RunLoop自身的超时时间到了</span><br>        <span class="hljs-comment">// 被其他什么调用者手动唤醒</span><br>        __CFRunLoopServiceMachPort(waitSet,<br>                                   &amp;msg,<br>                                   <span class="hljs-built_in">sizeof</span>(msg_buffer),<br>                                   &amp;livePort, poll ? <span class="hljs-number">0</span> : TIMEOUT_INFINITY,<br>                                   &amp;voucherState,<br>                                   &amp;voucherCopy);<br>        <br>        rl-&gt;_sleepTime += (poll ? <span class="hljs-number">0.0</span> : (<span class="hljs-built_in">CFAbsoluteTimeGetCurrent</span>() - sleepStart));<br>        <br>        <span class="hljs-comment">// 取消RunLoop的休眠</span><br>        __CFRunLoopUnsetSleeping(rl);<br>        <br>        <span class="hljs-comment">// 第8步：通知Observers，结束休眠</span><br>        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);<br>    <br>    <span class="hljs-comment">// 判断RunLoop被唤醒的方式，并处理对应的事件</span><br>    handle_msg:;<br>        <span class="hljs-comment">// 判断RunLoop被唤醒的方式</span><br>        <span class="hljs-comment">// MACH_PORT_NULL == livePort和livePort == rl-&gt;_wakeUpPort两种情况什么都不做，省略</span><br>        <span class="hljs-comment">// 被timer唤醒</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;<br>            <span class="hljs-comment">// 处理timer</span><br>            __CFRunLoopDoTimers(rl, rlm, <span class="hljs-built_in">mach_absolute_time</span>());<br>        &#125;<br>        <span class="hljs-comment">// 被GCD唤醒</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (livePort == dispatchPort) &#123;<br>            <span class="hljs-comment">// 处理GCD</span><br>            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);<br>        &#125;<br>        <span class="hljs-comment">// 被Source1唤醒</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 处理Source1</span><br>            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 处理Blocks</span><br>        __CFRunLoopDoBlocks(rl, rlm);<br>        <br>        <span class="hljs-comment">// 第9步：决定RunLoop的返回值</span><br>        <span class="hljs-keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;<br>            <span class="hljs-comment">// 处理完事件就返回</span><br>            retVal = kCFRunLoopRunHandledSource;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timeout_context-&gt;termTSR &lt; <span class="hljs-built_in">mach_absolute_time</span>()) &#123;<br>            <span class="hljs-comment">// 超时</span><br>            retVal = kCFRunLoopRunTimedOut;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;<br>            <span class="hljs-comment">// RunLoop终止</span><br>            __CFRunLoopUnsetStopped(rl);<br>            retVal = kCFRunLoopRunStopped;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rlm-&gt;_stopped) &#123;<br>            <span class="hljs-comment">// mode终止</span><br>            rlm-&gt;_stopped = <span class="hljs-literal">false</span>;<br>            retVal = kCFRunLoopRunStopped;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;<br>            retVal = kCFRunLoopRunFinished;<br>        &#125;    <br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span> == retVal);<br>    <br>    <span class="hljs-keyword">return</span> retVal;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行流程可以总结如下图：<br><img src="/../images/image-57.png" alt="alt text"></p><p>上述两个地方注意：</p><ul><li><p>runloop处理gcd事件：一般来说，runloop和gcd是独立的，runloop调用gcd，gcd去执行，但是有一种情况，即gcd唤醒主线程的runloop，此时runloop就会调用函数去处理一些关于gcd的逻辑，即内部固定调用gcd的api，让其处理派发到main queue的任务</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1111111&quot;</span>);<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>函数调用栈：<br><img src="/../images/image-58.png" alt="alt text"></p></li><li><p>PS：如果runloop执行时，gcd中存在未完成的任务，则runloop不会休眠，仍然是调用上述gcd的api执行，休眠和不休眠的调用栈是一样的！</p></li><li><p>runloop休眠<br>当runloop休眠，线程会进入等待被唤醒状态，使用mach_msg进入，等待被系统唤醒（其实就是线程状态切换）</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>RunLoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OC Runtime-关联对象</title>
    <link href="/2024/03/05/oc-runtime-associated-object/"/>
    <url>/2024/03/05/oc-runtime-associated-object/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们知道，在类中，我们可以使用</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br></code></pre></td></tr></table></figure><p>生成一个属性，它主要干了三件事情</p><ul><li>生成一个_name成员变量</li><li>生成setName和getName方法</li><li>提供默认的setter&#x2F;getter实现<br>但如果我们是Category中写，则只会提供setter&#x2F;getter声明，并不会生成成员变量和提供setter&#x2F;getter的实现，如果想要在Category中完整实现类的@property语义，则需要使用关联对象</li></ul><h2 id="关联对象的使用"><a href="#关联对象的使用" class="headerlink" title="关联对象的使用"></a>关联对象的使用</h2><p>首先需要明白为啥要使用关联对象，上面说了，因为Category中的@property并不会生成实例变量和提供setter&#x2F;getter实现，并且也不能存放成员变量，所以需要使用关联对象。</p><p>使用如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-comment">// .h</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">FatherA</span> : <span class="hljs-title">NSObject</span></span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">// .m</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">FatherA</span></span><br><br>- (<span class="hljs-type">void</span>)setName:(<span class="hljs-built_in">NSString</span> *)name &#123;<br>    <span class="hljs-comment">// 设置关联对象</span><br>    objc_setAssociatedObject(<span class="hljs-keyword">self</span>,<br>                             <span class="hljs-keyword">@selector</span>(name),<br>                             name,<br>                             OBJC_ASSOCIATION_COPY_NONATOMIC);<br>&#125;<br><br>- (<span class="hljs-built_in">NSString</span> *)name &#123;<br>    <span class="hljs-comment">// 取出关联对象</span><br>    <span class="hljs-keyword">return</span> objc_getAssociatedObject(<span class="hljs-keyword">self</span>, _cmd);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><h2 id="关联对象的实现"><a href="#关联对象的实现" class="headerlink" title="关联对象的实现"></a>关联对象的实现</h2><p>我们一般使用的api一般如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-comment">// 设置关联对象</span><br><span class="hljs-type">void</span> objc_setAssociatedObject(<span class="hljs-type">id</span> object, <span class="hljs-keyword">const</span> <span class="hljs-type">void</span> *key, <span class="hljs-type">id</span> value, objc_AssociationPolicy policy);<br><span class="hljs-comment">// 获取关联对象</span><br><span class="hljs-type">id</span> objc_getAssociatedObject(<span class="hljs-type">id</span> object, <span class="hljs-keyword">const</span> <span class="hljs-type">void</span> *key);<br><span class="hljs-comment">// 移除关联对象</span><br><span class="hljs-type">void</span> objc_removeAssociatedObjects(<span class="hljs-type">id</span> object);<br></code></pre></td></tr></table></figure><h2 id="关联对象的核心"><a href="#关联对象的核心" class="headerlink" title="关联对象的核心"></a>关联对象的核心</h2><h3 id="AssociationsManager"><a href="#AssociationsManager" class="headerlink" title="AssociationsManager"></a>AssociationsManager</h3><p>其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">spinlock_t</span> AssociationsManagerLock;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AssociationsManager</span> &#123;<br>    <span class="hljs-comment">// associative references: object pointer -&gt; PtrPtrHashMap.</span><br>    <span class="hljs-type">static</span> AssociationsHashMap *_map;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">AssociationsManager</span>()   &#123; AssociationsManagerLock.<span class="hljs-built_in">lock</span>(); &#125;<br>    ~<span class="hljs-built_in">AssociationsManager</span>()  &#123; AssociationsManagerLock.<span class="hljs-built_in">unlock</span>(); &#125;<br>    <br>    <span class="hljs-function">AssociationsHashMap &amp;<span class="hljs-title">associations</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (_map == <span class="hljs-literal">NULL</span>)<br>            _map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AssociationsHashMap</span>();<br>        <span class="hljs-keyword">return</span> *_map;<br>    &#125;<br>&#125;;<br><br>AssociationsHashMap *AssociationsManager::_map = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>在该对象中，会维护一个AssociationsHashMap，初始化时，调用AssociationsManagerLock.lock()，析构时，调用AssociationsManagerLock.unlock()，而associations方法用于获取一个全局的AssociationsHashMap。</p><p>另外在该manager中通过自旋锁spinlock_t AssociationsManagerLock来确保对map的操作是线程安全的</p><h3 id="AssociationsHashMap"><a href="#AssociationsHashMap" class="headerlink" title="AssociationsHashMap"></a>AssociationsHashMap</h3><p>其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AssociationsHashMap</span> : <span class="hljs-keyword">public</span> unordered_map&lt;<span class="hljs-type">disguised_ptr_t</span>, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n)</span> </span>&#123; <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">malloc</span>(n); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span> </span>&#123; ::<span class="hljs-built_in">free</span>(ptr); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>该map继承自unordered_map，该map的key是disguised_ptr_t，而value是ObjectAssociationMap</p><h3 id="ObjectAssociationMap"><a href="#ObjectAssociationMap" class="headerlink" title="ObjectAssociationMap"></a>ObjectAssociationMap</h3><p>其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectAssociationMap</span> : <span class="hljs-keyword">public</span> std::map&lt;<span class="hljs-type">void</span> *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n)</span> </span>&#123; <span class="hljs-keyword">return</span> ::<span class="hljs-built_in">malloc</span>(n); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span> </span>&#123; ::<span class="hljs-built_in">free</span>(ptr); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>该map保存了key到ObjcAssociation的映射，即某个具体的对象所有关联对象</p><h3 id="ObjcAssociation"><a href="#ObjcAssociation" class="headerlink" title="ObjcAssociation"></a>ObjcAssociation</h3><p>其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjcAssociation</span> &#123;<br>    <span class="hljs-type">uintptr_t</span> _policy;<br>    id _value;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ObjcAssociation</span>(<span class="hljs-type">uintptr_t</span> policy, id value) : _policy(policy), _value(value) &#123;&#125;<br>    <span class="hljs-built_in">ObjcAssociation</span>() : _policy(<span class="hljs-number">0</span>), _value(nil) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">uintptr_t</span> <span class="hljs-title">policy</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _policy; &#125;<br>    <span class="hljs-function">id <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _value; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasValue</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _value != nil; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>ObjcAssociation是关联对象的封装，_policy和_value就是我们使用objc_setAssociatedObject传进来的参数</p><h3 id="objc-setAssociatedObject"><a href="#objc-setAssociatedObject" class="headerlink" title="objc_setAssociatedObject"></a>objc_setAssociatedObject</h3><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">objc_setAssociatedObject</span><span class="hljs-params">(id object, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key, id value, objc_AssociationPolicy policy)</span> </span>&#123;<br>    _object_set_associative_reference(object, (<span class="hljs-type">void</span> *)key, value, policy);<br>&#125;<br></code></pre></td></tr></table></figure><p>_object_set_associative_reference源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">void</span> _object_set_associative_reference(id object, <span class="hljs-type">void</span> *key, id value, <span class="hljs-type">uintptr_t</span> policy) &#123;<br>    <span class="hljs-comment">// retain the new value (if any) outside the lock.</span><br>    <span class="hljs-comment">// 创建一个ObjcAssociation局部变量，持有原有的关联对象和最后的释放</span><br>    <span class="hljs-function">ObjcAssociation <span class="hljs-title">old_association</span><span class="hljs-params">(<span class="hljs-number">0</span>, nil)</span></span>;<br>    <span class="hljs-comment">// 调用acquireValue对new_value进行retain或者copy</span><br>    id new_value = value ? <span class="hljs-built_in">acquireValue</span>(value, policy) : nil;<br>    &#123;<br>        <span class="hljs-comment">// 初始化一个AssociationsManager，并获取AssociationsHashMap</span><br>        AssociationsManager manager;<br>        <span class="hljs-function">AssociationsHashMap &amp;<span class="hljs-title">associations</span><span class="hljs-params">(manager.associations())</span></span>;<br>        <span class="hljs-comment">// disguised_ptr_t是AssociationsHashMap中的key，通过传入的object得到</span><br>        <span class="hljs-type">disguised_ptr_t</span> disguised_object = <span class="hljs-built_in">DISGUISE</span>(object);<br>        <br>        <span class="hljs-comment">// new_value有值代表设置或者更新关联对象的值，否则表示删除一个关联对象</span><br>        <span class="hljs-keyword">if</span> (new_value) &#123;<br>            <span class="hljs-comment">// break any existing association.</span><br>            <span class="hljs-comment">// 查找ObjectAssociationMap</span><br>            AssociationsHashMap::iterator i = associations.<span class="hljs-built_in">find</span>(disguised_object);<br>            <span class="hljs-keyword">if</span> (i != associations.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-comment">// secondary table exists</span><br>                <span class="hljs-comment">// ObjectAssociationMap存在</span><br>                <span class="hljs-comment">// 判断key是否存在，key存在更新原有的关联对象，key不存在，则新增，并且新增的位置需要结合end()</span><br>                ObjectAssociationMap *refs = i-&gt;second;<br>                ObjectAssociationMap::iterator j = refs-&gt;<span class="hljs-built_in">find</span>(key);<br>                <span class="hljs-keyword">if</span> (j != refs-&gt;<span class="hljs-built_in">end</span>()) &#123;<br>                    old_association = j-&gt;second;<br>                    j-&gt;second = <span class="hljs-built_in">ObjcAssociation</span>(policy, new_value);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    (*refs)[key] = <span class="hljs-built_in">ObjcAssociation</span>(policy, new_value);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// create the new association (first time).</span><br>                <span class="hljs-comment">// ObjectAssociationMap不存在</span><br>                <span class="hljs-comment">// 初始化一个ObjectAssociationMap，再实例化ObjcAssociation对象添加到Map中，并调用 setHasAssociatedObjects函数</span><br>                <span class="hljs-comment">// setHasAssociatedObjects标明当前类具有关联类 </span><br>                <span class="hljs-comment">// 它会将isa结构体中的has_assoc标记为true</span><br>                ObjectAssociationMap *refs = <span class="hljs-keyword">new</span> ObjectAssociationMap;<br>                associations[disguised_object] = refs;<br>                (*refs)[key] = <span class="hljs-built_in">ObjcAssociation</span>(policy, new_value);<br>                object-&gt;<span class="hljs-built_in">setHasAssociatedObjects</span>();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// setting the association to nil breaks the association.</span><br>            <span class="hljs-comment">// 查找ObjectAssociationMap</span><br>            AssociationsHashMap::iterator i = associations.<span class="hljs-built_in">find</span>(disguised_object);<br>            <span class="hljs-keyword">if</span> (i !=  associations.<span class="hljs-built_in">end</span>()) &#123;<br>                ObjectAssociationMap *refs = i-&gt;second;<br>                <span class="hljs-comment">// ObjectAssociationMap存在</span><br>                <span class="hljs-comment">// 判断key是否存在，key存在则调用erase函数来删除ObjectAssociationMap中key对应的节点</span><br>                ObjectAssociationMap::iterator j = refs-&gt;<span class="hljs-built_in">find</span>(key);<br>                <span class="hljs-keyword">if</span> (j != refs-&gt;<span class="hljs-built_in">end</span>()) &#123;<br>                    old_association = j-&gt;second;<br>                    refs-&gt;<span class="hljs-built_in">erase</span>(j);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// release the old value (outside of the lock).</span><br>    <span class="hljs-comment">// 原来的关联对象有值，调用ReleaseValue函数释放关联对象的值</span><br>    <span class="hljs-keyword">if</span> (old_association.<span class="hljs-built_in">hasValue</span>()) <span class="hljs-built_in">ReleaseValue</span>()(old_association);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过源码以及注释，可以梳理流程如下：<br>先在manager中获取map，map中以self作为key获取关联map，以设置的key从关联map中找到关联对象，还是很容易理解的，就是查表操作<br><img src="/../images/image-55.png" alt="alt text"></p><h3 id="objc-getAssociatedObject"><a href="#objc-getAssociatedObject" class="headerlink" title="objc_getAssociatedObject"></a>objc_getAssociatedObject</h3><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">id <span class="hljs-title">objc_getAssociatedObject</span><span class="hljs-params">(id object, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *key)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> _object_get_associative_reference(object, (<span class="hljs-type">void</span> *)key);<br>&#125;<br></code></pre></td></tr></table></figure><p>看下_object_get_associative_reference的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++">id _object_get_associative_reference(id object, <span class="hljs-type">void</span> *key) &#123;<br>    id value = nil;<br>    <span class="hljs-type">uintptr_t</span> policy = OBJC_ASSOCIATION_ASSIGN;<br>    &#123;<br>        <span class="hljs-comment">// 初始化一个AssociationsManager，并获取AssociationsHashMap</span><br>        AssociationsManager manager;<br>        <span class="hljs-function">AssociationsHashMap &amp;<span class="hljs-title">associations</span><span class="hljs-params">(manager.associations())</span></span>;<br>        <span class="hljs-comment">// 通过object获得disguised_ptr_t，用作在AssociationsHashMap的key</span><br>        <span class="hljs-type">disguised_ptr_t</span> disguised_object = <span class="hljs-built_in">DISGUISE</span>(object);<br>        <span class="hljs-comment">// 查找ObjectAssociationMap的位置</span><br>        AssociationsHashMap::iterator i = associations.<span class="hljs-built_in">find</span>(disguised_object);<br>        <span class="hljs-keyword">if</span> (i != associations.<span class="hljs-built_in">end</span>()) &#123;<br>            ObjectAssociationMap *refs = i-&gt;second;<br>            ObjectAssociationMap::iterator j = refs-&gt;<span class="hljs-built_in">find</span>(key);<br>            <span class="hljs-comment">// 查找ObjcAssociation对象</span><br>            <span class="hljs-keyword">if</span> (j != refs-&gt;<span class="hljs-built_in">end</span>()) &#123;<br>                ObjcAssociation &amp;entry = j-&gt;second;<br>                value = entry.<span class="hljs-built_in">value</span>();<br>                policy = entry.<span class="hljs-built_in">policy</span>();<br>                <span class="hljs-comment">// 说明是强类型，retain操作</span><br>                <span class="hljs-keyword">if</span> (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) &#123;<br>                    <span class="hljs-built_in">objc_retain</span>(value);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;<br>        <span class="hljs-comment">// autorelease</span><br>        <span class="hljs-built_in">objc_autorelease</span>(value);<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="objc-removeAssociatedObjects"><a href="#objc-removeAssociatedObjects" class="headerlink" title="objc_removeAssociatedObjects"></a>objc_removeAssociatedObjects</h3><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">objc_removeAssociatedObjects</span><span class="hljs-params">(id object)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (object &amp;&amp; object-&gt;<span class="hljs-built_in">hasAssociatedObjects</span>()) &#123;<br>        _object_remove_assocations(object);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看下_object_remove_assocations：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">void</span> _object_remove_assocations(id object) &#123;<br>    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;<br>    &#123;<br>        AssociationsManager manager;<br>        <span class="hljs-function">AssociationsHashMap &amp;<span class="hljs-title">associations</span><span class="hljs-params">(manager.associations())</span></span>;<br>        <span class="hljs-keyword">if</span> (associations.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">disguised_ptr_t</span> disguised_object = <span class="hljs-built_in">DISGUISE</span>(object);<br>        AssociationsHashMap::iterator i = associations.<span class="hljs-built_in">find</span>(disguised_object);<br>        <span class="hljs-keyword">if</span> (i != associations.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-comment">// copy all of the associations that need to be removed.</span><br>            ObjectAssociationMap *refs = i-&gt;second;<br>            <span class="hljs-keyword">for</span> (ObjectAssociationMap::iterator j = refs-&gt;<span class="hljs-built_in">begin</span>(), end = refs-&gt;<span class="hljs-built_in">end</span>(); j != end; ++j) &#123;<br>                elements.<span class="hljs-built_in">push_back</span>(j-&gt;second);<br>            &#125;<br>            <span class="hljs-comment">// remove the secondary table.</span><br>            <span class="hljs-keyword">delete</span> refs;<br>            associations.<span class="hljs-built_in">erase</span>(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// the calls to releaseValue() happen outside of the lock.</span><br>    for_each(elements.<span class="hljs-built_in">begin</span>(), elements.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">ReleaseValue</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>将对象包含的所有关联对象加入到vector，删除map中对应的节点，然后对所有关联对象释放</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>关联对象的实现<ul><li>本质是封装到了ObjcAssociation</li><li>每个对象都有一个ObjectAssociationMap，通过key查找到ObjcAssociation</li><li>对象中has_assoc用来确定是否含有关联对象，对象本身和ObjectAssociationMap的对应关系存储在AssociationsHashMap</li><li>AssociationsHashMap是全局的，在AssociationsManager中管理</li></ul></li><li>Category中是否能完整实现@property<ul><li>默认不行，需要自行使用关联对象实现</li></ul></li><li>weak类型的关联对象<ul><li>默认没有这种policy</li><li>若必须使用，可使用一个wrapper对象，wrapper对象里放weak对象</li></ul></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - Weak Associated Object</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">_NNWeakAssociatedWrapper</span> : <span class="hljs-title">NSObject</span></span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">weak</span>) <span class="hljs-type">id</span> associatedObject;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">_NNWeakAssociatedWrapper</span></span><br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-type">void</span> nn_objc_setWeakAssociatedObject(<span class="hljs-type">id</span> object, <span class="hljs-keyword">const</span> <span class="hljs-type">void</span> * key, <span class="hljs-type">id</span> value) &#123;<br>    _NNWeakAssociatedWrapper *wrapper = objc_getAssociatedObject(object, key);<br>    <span class="hljs-keyword">if</span> (!wrapper) &#123;<br>        wrapper = [_NNWeakAssociatedWrapper new];<br>        objc_setAssociatedObject(object, key, wrapper, OBJC_ASSOCIATION_RETAIN_NONATOMIC);<br>    &#125;<br>    wrapper.associatedObject = value;<br>&#125;<br><br><span class="hljs-type">id</span> nn_objc_getWeakAssociatedObject(<span class="hljs-type">id</span> object, <span class="hljs-keyword">const</span> <span class="hljs-type">void</span> * key) &#123;<br>    <span class="hljs-type">id</span> wrapper = objc_getAssociatedObject(object, key);<br>    <br>    <span class="hljs-type">id</span> objc = wrapper &amp;&amp; [wrapper isKindOfClass:_NNWeakAssociatedWrapper.class] ?<br>    [(_NNWeakAssociatedWrapper *)wrapper associatedObject] :<br>    <span class="hljs-literal">nil</span>;<br>    <br>    <span class="hljs-keyword">return</span> objc;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Runtime</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OC Runtime-Category、+load、+initialize的原理</title>
    <link href="/2024/03/04/oc-runtime-category-load-initialize/"/>
    <url>/2024/03/04/oc-runtime-category-load-initialize/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文回忆下Category、+load和+initialize的内部实现</p><h1 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h1><p>Category一般用于给已有的类，在不改变原有类的情况下，对类动态添加methods，它实际是一种装饰模式的实现</p><p>先看代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-comment">// CategoryTestModel.h </span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">CategoryTestModel</span> : <span class="hljs-title">NSObject</span></span><br><br>- (<span class="hljs-type">void</span>)ins_method1;<br>+ (<span class="hljs-type">void</span>)cls_method1;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">CategoryTestModel</span>(<span class="hljs-title">NN</span>)</span><br><br>- (<span class="hljs-type">void</span>)ins_method2;<br>- (<span class="hljs-type">void</span>)ins_method22;<br>+ (<span class="hljs-type">void</span>)cls_method2;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">CategoryTestModel</span>(<span class="hljs-title">Nero</span>)</span><br><br>- (<span class="hljs-type">void</span>)ins_method3;<br>+ (<span class="hljs-type">void</span>)cls_method3;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">// CategoryTestModel.m</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">CategoryTestModel</span></span><br><br>- (<span class="hljs-type">void</span>)ins_method1 &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br>&#125;<br><br>+ (<span class="hljs-type">void</span>)cls_method1 &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">CategoryTestModel</span>(<span class="hljs-title">NN</span>)</span><br><br>- (<span class="hljs-type">void</span>)ins_method2 &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)ins_method22 &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br>&#125;<br><br>+ (<span class="hljs-type">void</span>)cls_method2 &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">CategoryTestModel</span>(<span class="hljs-title">Nero</span>)</span><br><br>- (<span class="hljs-type">void</span>)ins_method3 &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br>&#125;<br><br>+ (<span class="hljs-type">void</span>)cls_method3 &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>我们创建了一个主类CategoryTestModel和两个分类NN和Nero，将其改写为C++代码，看下发生了什么</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">xcrun -sdk iphoneos clang -<span class="hljs-built_in">arch</span> arm64 -rewrite-objc CategoryTestModel.m<br></code></pre></td></tr></table></figure><h2 id="Category的底层结构"><a href="#Category的底层结构" class="headerlink" title="Category的底层结构"></a>Category的底层结构</h2><p>在C++嗲am中，有以下关键代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// NN分类</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_category_t</span> _OBJC_$_CATEGORY_CategoryTestModel_$_NN __attribute__ ((used, <span class="hljs-built_in">section</span> (<span class="hljs-string">&quot;__DATA,__objc_const&quot;</span>))) = <br>&#123;<br><span class="hljs-string">&quot;CategoryTestModel&quot;</span>,<br><span class="hljs-number">0</span>, <span class="hljs-comment">// &amp;OBJC_CLASS_$_CategoryTestModel,</span><br>(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-type">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_CategoryTestModel_$_NN,<br>(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-type">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_CategoryTestModel_$_NN,<br><span class="hljs-number">0</span>,<br><span class="hljs-number">0</span>,<br>&#125;;<br><br><span class="hljs-comment">// Nero分类</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_category_t</span> _OBJC_$_CATEGORY_CategoryTestModel_$_Nero __attribute__ ((used, <span class="hljs-built_in">section</span> (<span class="hljs-string">&quot;__DATA,__objc_const&quot;</span>))) = <br>&#123;<br><span class="hljs-string">&quot;CategoryTestModel&quot;</span>,<br><span class="hljs-number">0</span>, <span class="hljs-comment">// &amp;OBJC_CLASS_$_CategoryTestModel,</span><br>(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-type">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_CategoryTestModel_$_Nero,<br>(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-type">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_CategoryTestModel_$_Nero,<br><span class="hljs-number">0</span>,<br><span class="hljs-number">0</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>从源码看出，分类转换为了_category_t结构体，此处注意转换后的和runtime源码中的category_t略有差异</p><p>_category_t定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">_category_t</span> &#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name; <span class="hljs-comment">// 主类名字符串</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">_class_t</span> *cls; <span class="hljs-comment">// 主类</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_method_list_t</span> *instance_methods; <span class="hljs-comment">// 实例方法列表</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_method_list_t</span> *class_methods; <span class="hljs-comment">// 类方法列表</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_protocol_list_t</span> *protocols; <span class="hljs-comment">// 协议列表</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_prop_list_t</span> *properties; <span class="hljs-comment">// 属性列表</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在我们声明的分类中，只有实例方法和类方法，看下_method_list_t定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 对象方法存储</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-comment">/*_method_list_t*/</span> &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> entsize;  <span class="hljs-comment">// sizeof(struct _objc_method)</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> method_count;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">_objc_method</span> method_list[<span class="hljs-number">2</span>];<br>&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_CategoryTestModel_$_NN __attribute__ ((used, <span class="hljs-built_in">section</span> (<span class="hljs-string">&quot;__DATA,__objc_const&quot;</span>))) = &#123;<br><span class="hljs-built_in">sizeof</span>(_objc_method),<br><span class="hljs-number">2</span>,<br>&#123;&#123;(<span class="hljs-keyword">struct</span> objc_selector *)<span class="hljs-string">&quot;ins_method2&quot;</span>, <span class="hljs-string">&quot;v16@0:8&quot;</span>, (<span class="hljs-type">void</span> *)_I_CategoryTestModel_NN_ins_method2&#125;,<br>&#123;(<span class="hljs-keyword">struct</span> objc_selector *)<span class="hljs-string">&quot;ins_method22&quot;</span>, <span class="hljs-string">&quot;v16@0:8&quot;</span>, (<span class="hljs-type">void</span> *)_I_CategoryTestModel_NN_ins_method22&#125;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 类方法存储</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-comment">/*_method_list_t*/</span> &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> entsize;  <span class="hljs-comment">// sizeof(struct _objc_method)</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> method_count;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">_objc_method</span> method_list[<span class="hljs-number">1</span>];<br>&#125; _OBJC_$_CATEGORY_CLASS_METHODS_CategoryTestModel_$_NN __attribute__ ((used, <span class="hljs-built_in">section</span> (<span class="hljs-string">&quot;__DATA,__objc_const&quot;</span>))) = &#123;<br><span class="hljs-built_in">sizeof</span>(_objc_method),<br><span class="hljs-number">1</span>,<br>&#123;&#123;(<span class="hljs-keyword">struct</span> objc_selector *)<span class="hljs-string">&quot;cls_method2&quot;</span>, <span class="hljs-string">&quot;v16@0:8&quot;</span>, (<span class="hljs-type">void</span> *)_C_CategoryTestModel_NN_cls_method2&#125;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>通过上述源码，我们知道：</p><ul><li>category底层是个_category_t，我们在其中声明的方法、属性等都会存储到其中</li><li>每个category对应一个_category_t</li></ul><p>上述是说了编译器做的工作，我们知道，专门打印主类的时候，category方法也会被输出；category的方法可以覆盖主类的方法，这是如何做到的呢？这就是runtime的工作了</p><h2 id="Category在Runtime中"><a href="#Category在Runtime中" class="headerlink" title="Category在Runtime中"></a>Category在Runtime中</h2><p>在runtime源码的objc-runtime-new.m，有个_read_images，其中涉及到category的加载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">void</span> _read_images(header_info **hList, <span class="hljs-type">uint32_t</span> hCount, <span class="hljs-type">int</span> totalClasses, <span class="hljs-type">int</span> unoptimizedTotalClasses)<br>&#123;<br>    <span class="hljs-comment">// 这里只显示category的实现</span><br>        <span class="hljs-comment">// Discover categories. </span><br>    <span class="hljs-keyword">for</span> (EACH_HEADER) &#123;<br>        <span class="hljs-comment">// 二维数组存在分类结构体变量</span><br>        <span class="hljs-type">category_t</span> **catlist = <br>            _getObjc2CategoryList(hi, &amp;count);<br>        <span class="hljs-comment">// 判断是否有类属性</span><br>        <span class="hljs-type">bool</span> hasClassProperties = hi-&gt;<span class="hljs-built_in">info</span>()-&gt;<span class="hljs-built_in">hasCategoryClassProperties</span>();<br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            <span class="hljs-type">category_t</span> *cat = catlist[i];<br>            <span class="hljs-comment">// 获取分类的主类</span><br>            Class cls = <span class="hljs-built_in">remapClass</span>(cat-&gt;cls);<br>            <span class="hljs-comment">// 主类不存在进行下一次循环</span><br>            <span class="hljs-keyword">if</span> (!cls) &#123;<br>                <span class="hljs-comment">// Category&#x27;s target class is missing (probably weak-linked).</span><br>                <span class="hljs-comment">// Disavow any knowledge of this category.</span><br>                catlist[i] = nil;<br>                <span class="hljs-keyword">if</span> (PrintConnecting) &#123;<br>                    _objc_inform(<span class="hljs-string">&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span><br>                                 <span class="hljs-string">&quot;missing weak-linked target class&quot;</span>, <br>                                 cat-&gt;name, cat);<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// Process this category. </span><br>            <span class="hljs-comment">// First, register the category with its target class. </span><br>            <span class="hljs-comment">// Then, rebuild the class&#x27;s method lists (etc) if </span><br>            <span class="hljs-comment">// the class is realized. </span><br>            <span class="hljs-type">bool</span> classExists = NO;<br>            <span class="hljs-comment">// 分类中存在对象方法，协议或者属性，</span><br>            <span class="hljs-keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols  <br>                ||  cat-&gt;instanceProperties) <br>            &#123;<br>                <span class="hljs-comment">// 给主类添加独立的分类</span><br>                <span class="hljs-built_in">addUnattachedCategoryForClass</span>(cat, cls, hi);<br>                <span class="hljs-comment">// 类是否实现</span><br>                <span class="hljs-keyword">if</span> (cls-&gt;<span class="hljs-built_in">isRealized</span>()) &#123;<br>                    <span class="hljs-comment">// 对类进行方法化</span><br>                    <span class="hljs-built_in">remethodizeClass</span>(cls);<br>                    classExists = YES;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (PrintConnecting) &#123;<br>                    _objc_inform(<span class="hljs-string">&quot;CLASS: found category -%s(%s) %s&quot;</span>, <br>                                 cls-&gt;<span class="hljs-built_in">nameForLogging</span>(), cat-&gt;name, <br>                                 classExists ? <span class="hljs-string">&quot;on existing class&quot;</span> : <span class="hljs-string">&quot;&quot;</span>);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 分类中存在类方法，协议或者类属性</span><br>            <span class="hljs-keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols  <br>                ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) <br>            &#123;<br>                <span class="hljs-comment">// 给主类的元类添加独立的分类</span><br>                <span class="hljs-built_in">addUnattachedCategoryForClass</span>(cat, cls-&gt;<span class="hljs-built_in">ISA</span>(), hi);<br>                <span class="hljs-comment">// 主类的元类是否实现</span><br>                <span class="hljs-keyword">if</span> (cls-&gt;<span class="hljs-built_in">ISA</span>()-&gt;<span class="hljs-built_in">isRealized</span>()) &#123;<br>                    <span class="hljs-comment">// 对元类进行方法化</span><br>                    <span class="hljs-built_in">remethodizeClass</span>(cls-&gt;<span class="hljs-built_in">ISA</span>());<br>                &#125;<br>                <span class="hljs-keyword">if</span> (PrintConnecting) &#123;<br>                    _objc_inform(<span class="hljs-string">&quot;CLASS: found category +%s(%s)&quot;</span>, <br>                                 cls-&gt;<span class="hljs-built_in">nameForLogging</span>(), cat-&gt;name);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ts.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;IMAGE TIMES: discover categories&quot;</span>);  <br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的主要作用：</p><ul><li>通过_getObjc2CategoryList获取到category列表</li><li>遍历category列表获取其中的方法、协议、属性</li><li>调用remethodizeClass(cls)对主类重新方法化</li><li>remethodizeClass(cls-&gt;ISA())对主类的元类重新方法化</li></ul><p>可以看到，最终都调用了remethodizeClass函数，我们看下其实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">remethodizeClass</span><span class="hljs-params">(Class cls)</span></span><br><span class="hljs-function"></span>&#123;<br>    category_list *cats;<br>    <span class="hljs-type">bool</span> isMeta;<br><br>    runtimeLock.<span class="hljs-built_in">assertLocked</span>();<br><br>    isMeta = cls-&gt;<span class="hljs-built_in">isMetaClass</span>();<br><br>    <span class="hljs-comment">// Re-methodizing: check for more categories</span><br>    <span class="hljs-keyword">if</span> ((cats = <span class="hljs-built_in">unattachedCategoriesForClass</span>(cls, <span class="hljs-literal">false</span><span class="hljs-comment">/*not realizing*/</span>))) &#123;<br>        <span class="hljs-keyword">if</span> (PrintConnecting) &#123;<br>            _objc_inform(<span class="hljs-string">&quot;CLASS: attaching categories to class &#x27;%s&#x27; %s&quot;</span>, <br>                         cls-&gt;<span class="hljs-built_in">nameForLogging</span>(), isMeta ? <span class="hljs-string">&quot;(meta)&quot;</span> : <span class="hljs-string">&quot;&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 附加分类</span><br>        <span class="hljs-built_in">attachCategories</span>(cls, cats, <span class="hljs-literal">true</span> <span class="hljs-comment">/*flush caches*/</span>);        <br>        <span class="hljs-built_in">free</span>(cats);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法的实现调用了attachCategories，该函数用于给主类、主元类添加分类中存放的数据，实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> </span><br><span class="hljs-function"><span class="hljs-title">attachCategories</span><span class="hljs-params">(Class cls, category_list *cats, <span class="hljs-type">bool</span> flush_caches)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!cats) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (PrintReplacedMethods) <span class="hljs-built_in">printReplacements</span>(cls, cats);<br><br>    <span class="hljs-type">bool</span> isMeta = cls-&gt;<span class="hljs-built_in">isMetaClass</span>();<br><br>    <span class="hljs-comment">// fixme rearrange to remove these intermediate allocations</span><br>    <span class="hljs-comment">// 方法列表 [[方法],[方法，方法],[方法]]</span><br>    <span class="hljs-type">method_list_t</span> **mlists = (<span class="hljs-type">method_list_t</span> **)<br>        <span class="hljs-built_in">malloc</span>(cats-&gt;count * <span class="hljs-built_in">sizeof</span>(*mlists));<br>    <span class="hljs-comment">// 属性列表</span><br>    <span class="hljs-type">property_list_t</span> **proplists = (<span class="hljs-type">property_list_t</span> **)<br>        <span class="hljs-built_in">malloc</span>(cats-&gt;count * <span class="hljs-built_in">sizeof</span>(*proplists));<br>    <span class="hljs-comment">// 协议列表</span><br>    <span class="hljs-type">protocol_list_t</span> **protolists = (<span class="hljs-type">protocol_list_t</span> **)<br>        <span class="hljs-built_in">malloc</span>(cats-&gt;count * <span class="hljs-built_in">sizeof</span>(*protolists));<br><br>    <span class="hljs-comment">// Count backwards through cats to get newest categories first</span><br>    <span class="hljs-type">int</span> mcount = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> propcount = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> protocount = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 分类列表的个数代表有多少个分类</span><br>    <span class="hljs-type">int</span> i = cats-&gt;count;<br>    <span class="hljs-type">bool</span> fromBundle = NO;<br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>        <span class="hljs-keyword">auto</span>&amp; entry = cats-&gt;list[i];<br><br>        <span class="hljs-comment">// 根据是否是元类返回分类结构体中的类方法列表或者对象方法列表</span><br>        <span class="hljs-type">method_list_t</span> *mlist = entry.cat-&gt;<span class="hljs-built_in">methodsForMeta</span>(isMeta);<br>        <span class="hljs-keyword">if</span> (mlist) &#123;<br>            mlists[mcount++] = mlist;<br>            fromBundle |= entry.hi-&gt;<span class="hljs-built_in">isBundle</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 根据是否是元类返回分类结构体中的类属性列表或者属性列表</span><br>        <span class="hljs-type">property_list_t</span> *proplist = <br>            entry.cat-&gt;<span class="hljs-built_in">propertiesForMeta</span>(isMeta, entry.hi);<br>        <span class="hljs-keyword">if</span> (proplist) &#123;<br>            proplists[propcount++] = proplist;<br>        &#125;<br>     <br>        <span class="hljs-type">protocol_list_t</span> *protolist = entry.cat-&gt;protocols;<br>        <span class="hljs-keyword">if</span> (protolist) &#123;<br>            protolists[protocount++] = protolist;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// rw代表类对象，里面有一个方法列表和属性列表的字段</span><br>    <span class="hljs-keyword">auto</span> rw = cls-&gt;<span class="hljs-built_in">data</span>();<br><br>    <span class="hljs-built_in">prepareMethodLists</span>(cls, mlists, mcount, NO, fromBundle);<br>    <span class="hljs-comment">// 将上面合并后的分类方法合并到类对象的方法列表中，并释放mlists</span><br>    rw-&gt;methods.<span class="hljs-built_in">attachLists</span>(mlists, mcount);<br>    <span class="hljs-built_in">free</span>(mlists);<br>    <span class="hljs-comment">// 是否刷新缓存</span><br>    <span class="hljs-keyword">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class="hljs-number">0</span>) <span class="hljs-built_in">flushCaches</span>(cls);<br><br>    <span class="hljs-comment">// 将所有分类属性合并到类对象的属性列表中</span><br>    rw-&gt;properties.<span class="hljs-built_in">attachLists</span>(proplists, propcount);<br>    <span class="hljs-built_in">free</span>(proplists);<br><br>    <span class="hljs-comment">// 协议也是如此</span><br>    rw-&gt;protocols.<span class="hljs-built_in">attachLists</span>(protolists, protocount);<br>    <span class="hljs-built_in">free</span>(protolists);<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的代码可以看到，所有category的方法、属性、协议会被合并，并且调用attachLists添加到主类&#x2F;主元类中，其实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">attachLists</span><span class="hljs-params">(List* <span class="hljs-type">const</span> * addedLists, <span class="hljs-type">uint32_t</span> addedCount)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (addedCount == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">hasArray</span>()) &#123;<br>        <span class="hljs-comment">// many lists -&gt; many lists</span><br>        <span class="hljs-type">uint32_t</span> oldCount = <span class="hljs-built_in">array</span>()-&gt;count;<br>        <span class="hljs-type">uint32_t</span> newCount = oldCount + addedCount;<br>        <span class="hljs-comment">// 重新分配内存，数组扩容</span><br>        <span class="hljs-built_in">setArray</span>((<span class="hljs-type">array_t</span> *)<span class="hljs-built_in">realloc</span>(<span class="hljs-built_in">array</span>(), <span class="hljs-type">array_t</span>::<span class="hljs-built_in">byteSize</span>(newCount)));<br>        <span class="hljs-built_in">array</span>()-&gt;count = newCount;<br>        <span class="hljs-comment">// array()-&gt;lists是原来的数组</span><br>        <span class="hljs-comment">// memmove的作用就是内存移动，将原来的数组向后拖动oldCount * sizeof(array()-&gt;lists[0])个位置</span><br>        <span class="hljs-built_in">memmove</span>(<span class="hljs-built_in">array</span>()-&gt;lists + addedCount, <span class="hljs-built_in">array</span>()-&gt;lists,<br>                oldCount * <span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">array</span>()-&gt;lists[<span class="hljs-number">0</span>]));<br>        <span class="hljs-comment">// memcpy的作用是内存拷贝，将新数组拷贝到前面空出的位置</span><br>        <span class="hljs-built_in">memcpy</span>(<span class="hljs-built_in">array</span>()-&gt;lists, addedLists,<br>               addedCount * <span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">array</span>()-&gt;lists[<span class="hljs-number">0</span>]));<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!list  &amp;&amp;  addedCount == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 0 lists -&gt; 1 list</span><br>        list = addedLists[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 1 list -&gt; many lists</span><br>        List* oldList = list;<br>        <span class="hljs-type">uint32_t</span> oldCount = oldList ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-type">uint32_t</span> newCount = oldCount + addedCount;<br>        <span class="hljs-built_in">setArray</span>((<span class="hljs-type">array_t</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-type">array_t</span>::<span class="hljs-built_in">byteSize</span>(newCount)));<br>        <span class="hljs-built_in">array</span>()-&gt;count = newCount;<br>        <span class="hljs-keyword">if</span> (oldList) <span class="hljs-built_in">array</span>()-&gt;lists[addedCount] = oldList;<br>        <span class="hljs-built_in">memcpy</span>(<span class="hljs-built_in">array</span>()-&gt;lists, addedLists,<br>               addedCount * <span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">array</span>()-&gt;lists[<span class="hljs-number">0</span>]));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述的实现分成3种case，但是思想接近，简单来说就是数组合并，分析这段代码可以理解为什么category中的方法可以覆盖主类的实现，以many lists -&gt; many list为例：</p><ul><li>首页分配内存做数组扩容</li><li>调用mememove，将原方法列表向后移动</li><li>调用memcpy，将category中的方法赋值到前面</li></ul><p>所以，我们就理解了，原来是category中的方法移动到了前面，那么在查找的时候自然会优先调用category的方法了，从而形成所谓的<code>方法覆盖</code>的现象</p><h2 id="Category总结"><a href="#Category总结" class="headerlink" title="Category总结"></a>Category总结</h2><ul><li>Category在编译期转换为_category_t，我们声明的方法、属性都会存在于该结构体中</li><li>在运行时，runtime将Category中的方法属性合并到主类&#x2F;主元类中</li><li>由于合并时，Category的方法排在了前面，所以会造成Category的同名方法覆盖原方法</li><li>越往后编译的category，其方法越排在前面，这是由runtime的加载决定的</li><li>category中的属性也是运行时添加到主类的，这和private category（或者说是extension）不同，extension中的属性是在编译时直接包含在类中的</li></ul><h1 id="load"><a href="#load" class="headerlink" title="+load"></a>+load</h1><p>首先看一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// FatherA</span><br>@implementation FatherA<br><br>+ (<span class="hljs-type">void</span>)load &#123;<br>    <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;%s&quot;</span>, __func__);<br>&#125;<br><br>@end<br><br>@<span class="hljs-function">implementation <span class="hljs-title">FatherA</span><span class="hljs-params">(NN)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">+ <span class="hljs-params">(<span class="hljs-type">void</span>)</span>load </span>&#123;<br>    <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;%s&quot;</span>, __func__);<br>&#125;<br><br>@end<br><br>@<span class="hljs-function">implementation <span class="hljs-title">FatherA</span><span class="hljs-params">(Nero)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">+ <span class="hljs-params">(<span class="hljs-type">void</span>)</span>load </span>&#123;<br>    <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;%s&quot;</span>, __func__);<br>&#125;<br><br>@end<br><br><span class="hljs-comment">// SonA</span><br>@implementation SonA<br><br>+ (<span class="hljs-type">void</span>)load &#123;<br>    <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;%s&quot;</span>, __func__);<br>&#125;<br><br>@end<br><br>@<span class="hljs-function">implementation <span class="hljs-title">SonA</span><span class="hljs-params">(NN)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">+ <span class="hljs-params">(<span class="hljs-type">void</span>)</span>load </span>&#123;<br>    <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;%s&quot;</span>, __func__);<br>&#125;<br><br>@end<br><br>@<span class="hljs-function">implementation <span class="hljs-title">SonA</span><span class="hljs-params">(Nero)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">+ <span class="hljs-params">(<span class="hljs-type">void</span>)</span>load </span>&#123;<br>    <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;%s&quot;</span>, __func__);<br>&#125;<br><br>@end<br><br><span class="hljs-comment">// FatherB</span><br>@implementation FatherB<br><br>+ (<span class="hljs-type">void</span>)load &#123;<br>    <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;%s&quot;</span>, __func__);<br>&#125;<br><br><span class="hljs-comment">// SonB</span><br>@implementation SonB<br><br>+ (<span class="hljs-type">void</span>)load &#123;<br>    <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;%s&quot;</span>, __func__);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译顺序如下：<br><img src="/../images/image-51.png" alt="alt text"><br>执行结果如下：<br><img src="/../images/image-52.png" alt="alt text"></p><p>以FatherA为例，我们知道+load方法是在rutime加载类、category的时候自动调用的，但是+load的调用是不走消息分发机制的，而是直接通过函数地址调用，所以不存在category的+load覆盖主类+load的说法，都会被调用，调用顺序等会说</p><p>+load的实现是在objc-runtime-new.m的load_images中，实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// load_images</span><br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">load_images</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path __unused, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> mach_header *mh)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Return without taking locks if there are no +load methods here.</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">hasLoadMethods</span>((<span class="hljs-type">const</span> headerType *)mh)) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">recursive_mutex_locker_t</span> <span class="hljs-title">lock</span><span class="hljs-params">(loadMethodLock)</span></span>;<br><br>    <span class="hljs-comment">// Discover load methods</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-type">mutex_locker_t</span> <span class="hljs-title">lock2</span><span class="hljs-params">(runtimeLock)</span></span>;<br>        <span class="hljs-comment">// 查找+load方法并确定调用顺序</span><br>        <span class="hljs-built_in">prepare_load_methods</span>((<span class="hljs-type">const</span> headerType *)mh);<br>    &#125;<br><br>    <span class="hljs-comment">// Call +load methods (without runtimeLock - re-entrant)</span><br>    <span class="hljs-comment">// 实际调用+load方法</span><br>    <span class="hljs-built_in">call_load_methods</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="prepare-load-methods实现"><a href="#prepare-load-methods实现" class="headerlink" title="prepare_load_methods实现"></a>prepare_load_methods实现</h2><p>该函数用于确定+load调用顺序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prepare_load_methods</span><span class="hljs-params">(<span class="hljs-type">const</span> headerType *mhdr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">size_t</span> count, i;<br><br>    runtimeLock.<span class="hljs-built_in">assertLocked</span>();<br><br>    <span class="hljs-comment">// 获取所有的类，classlist中类的顺序按照谁先编译，谁就在数组的前面</span><br>    <span class="hljs-type">classref_t</span> *classlist = <br>        _getObjc2NonlazyClassList(mhdr, &amp;count);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        <span class="hljs-comment">// 规划类的加载，即确定+load方法的调用顺序</span><br>        <span class="hljs-built_in">schedule_class_load</span>(<span class="hljs-built_in">remapClass</span>(classlist[i]));<br>    &#125;<br><br>    <span class="hljs-comment">// 获取所有的分类</span><br>    <span class="hljs-type">category_t</span> **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        <span class="hljs-type">category_t</span> *cat = categorylist[i];<br>        Class cls = <span class="hljs-built_in">remapClass</span>(cat-&gt;cls);<br>        <span class="hljs-keyword">if</span> (!cls) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// category for ignored weak-linked class</span><br>        <span class="hljs-built_in">realizeClass</span>(cls);<br>        <span class="hljs-built_in">assert</span>(cls-&gt;<span class="hljs-built_in">ISA</span>()-&gt;<span class="hljs-built_in">isRealized</span>());<br>        <span class="hljs-comment">// 将实现了+load方法的分类添加到loadable_categories数组的最后面</span><br>        <span class="hljs-built_in">add_category_to_loadable_list</span>(cat);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>获取所有类，调用schedule_class_load</li><li>获取所有caregory，调用add_category_to_loadable_list，该方法将实现了+load方法的category添加到loadable_categories数组的最后面</li><li>call_load_methods调用loadable_categories中的+load方法</li></ul><p>而class_list和categorylist中数组元素的顺序都是按照类、category的编译顺序添加到数组中的</p><h2 id="类中-load的调用顺序"><a href="#类中-load的调用顺序" class="headerlink" title="类中+load的调用顺序"></a>类中+load的调用顺序</h2><p>由schedule_class_load决定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// schedule_class_load是一个递归函数</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">schedule_class_load</span><span class="hljs-params">(Class cls)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!cls) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">assert</span>(cls-&gt;<span class="hljs-built_in">isRealized</span>());  <span class="hljs-comment">// _read_images should realize</span><br><br>    <span class="hljs-keyword">if</span> (cls-&gt;<span class="hljs-built_in">data</span>()-&gt;flags &amp; RW_LOADED) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// Ensure superclass-first ordering</span><br>    <span class="hljs-comment">// 沿着cls的父类一直往上查找知道NSObject</span><br>    <span class="hljs-built_in">schedule_class_load</span>(cls-&gt;superclass);<br><br>    <span class="hljs-comment">// 将实现了+load的cls添加到loadable_classes的最后面</span><br>    <span class="hljs-built_in">add_class_to_loadable_list</span>(cls);<br>    cls-&gt;<span class="hljs-built_in">setInfo</span>(RW_LOADED); <br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，该函数是个递归函数，首先获取父类的有+load的类列表，然后将本类添加到列表中，所以这就是<code>父类的+load方法优先于子类+load方法执行</code></p><p>再看下add_class_to_loadable_list的具体实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 这个结构体中的method专门存放类中的+load方法</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">loadable_class</span> &#123;<br>    Class cls;  <span class="hljs-comment">// may be nil</span><br>    IMP method;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_class_to_loadable_list</span><span class="hljs-params">(Class cls)</span></span><br><span class="hljs-function"></span>&#123;<br>    IMP method;<br><br>    loadMethodLock.<span class="hljs-built_in">assertLocked</span>();<br><br>    method = cls-&gt;<span class="hljs-built_in">getLoadMethod</span>();<br>    <span class="hljs-keyword">if</span> (!method) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Don&#x27;t bother if cls has no +load method</span><br>    <br>    <span class="hljs-keyword">if</span> (PrintLoading) &#123;<br>        _objc_inform(<span class="hljs-string">&quot;LOAD: class &#x27;%s&#x27; scheduled for +load&quot;</span>, <br>                     cls-&gt;<span class="hljs-built_in">nameForLogging</span>());<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;<br>        loadable_classes_allocated = loadable_classes_allocated*<span class="hljs-number">2</span> + <span class="hljs-number">16</span>;<br>        loadable_classes = (<span class="hljs-keyword">struct</span> loadable_class *)<br>            <span class="hljs-built_in">realloc</span>(loadable_classes,<br>                              loadable_classes_allocated *<br>                              <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> loadable_class));<br>    &#125;<br>    <br>    loadable_classes[loadable_classes_used].cls = cls;<br>    loadable_classes[loadable_classes_used].method = method;<br>    loadable_classes_used++;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然很长，但是本质就是将传入的cls生成一个loadable_class结构体，奖盖结构体放在loadable_classes后面，loadable_class中的method专门存放类的+load方法</p><h2 id="Category的-load调用顺序"><a href="#Category的-load调用顺序" class="headerlink" title="Category的+load调用顺序"></a>Category的+load调用顺序</h2><p>比类简单，就是遍历获取到的category列表，然后调用add_category_to_loadable_list，其源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 这个结构体中的method专门存放分类中的+load方法</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">loadable_category</span> &#123;<br>    Category cat;  <span class="hljs-comment">// may be nil</span><br>    IMP method;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_category_to_loadable_list</span><span class="hljs-params">(Category cat)</span></span><br><span class="hljs-function"></span>&#123;<br>    IMP method;<br><br>    loadMethodLock.<span class="hljs-built_in">assertLocked</span>();<br><br>    method = _category_getLoadMethod(cat);<br><br>    <span class="hljs-comment">// Don&#x27;t bother if cat has no +load method</span><br>    <span class="hljs-keyword">if</span> (!method) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span> (PrintLoading) &#123;<br>        _objc_inform(<span class="hljs-string">&quot;LOAD: category &#x27;%s(%s)&#x27; scheduled for +load&quot;</span>, <br>                     _category_getClassName(cat), _category_getName(cat));<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (loadable_categories_used == loadable_categories_allocated) &#123;<br>        loadable_categories_allocated = loadable_categories_allocated*<span class="hljs-number">2</span> + <span class="hljs-number">16</span>;<br>        loadable_categories = (<span class="hljs-keyword">struct</span> loadable_category *)<br>            <span class="hljs-built_in">realloc</span>(loadable_categories,<br>                              loadable_categories_allocated *<br>                              <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> loadable_category));<br>    &#125;<br><br>    loadable_categories[loadable_categories_used].cat = cat;<br>    loadable_categories[loadable_categories_used].method = method;<br>    loadable_categories_used++;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结下+load的调用顺序：</p><ul><li>对于重写了+load的类，先编译的父类&gt;先编译的子类&gt;后编译的父类&gt;后编译的子类（即保证父类的+load优先于子类+load，在这个大前提下看编译顺序）</li><li>对于重写了+load的category，调用顺序取决于编译顺序</li></ul><h2 id="call-load-methods"><a href="#call-load-methods" class="headerlink" title="call_load_methods"></a>call_load_methods</h2><p>如何调用+load呢，看源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">call_load_methods</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">bool</span> loading = NO;<br>    <span class="hljs-type">bool</span> more_categories;<br><br>    loadMethodLock.<span class="hljs-built_in">assertLocked</span>();<br><br>    <span class="hljs-comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span><br>    <span class="hljs-keyword">if</span> (loading) <span class="hljs-keyword">return</span>;<br>    loading = YES;<br><br>    <span class="hljs-type">void</span> *pool = <span class="hljs-built_in">objc_autoreleasePoolPush</span>();<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">// 1. Repeatedly call class +loads until there aren&#x27;t any more</span><br>        <span class="hljs-keyword">while</span> (loadable_classes_used &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 调用类的load方法</span><br>            <span class="hljs-built_in">call_class_loads</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 2. Call category +loads ONCE</span><br>        <span class="hljs-comment">// 调用分类的load方法</span><br>        more_categories = <span class="hljs-built_in">call_category_loads</span>();<br><br>        <span class="hljs-comment">// 3. Run more +loads if there are classes OR more untried categories</span><br>    &#125; <span class="hljs-keyword">while</span> (loadable_classes_used &gt; <span class="hljs-number">0</span>  ||  more_categories);<br><br>    <span class="hljs-built_in">objc_autoreleasePoolPop</span>(pool);<br><br>    loading = NO;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>调用call_class_loads调用类的+load</li><li>调用call_category_loads调用category的+load</li></ul><h2 id="call-class-loads"><a href="#call-class-loads" class="headerlink" title="call_class_loads"></a>call_class_loads</h2><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">call_class_loads</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <br>    <span class="hljs-comment">// Detach current loadable list.</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">loadable_class</span> *classes = loadable_classes;<br>    <span class="hljs-type">int</span> used = loadable_classes_used;<br>    loadable_classes = nil;<br>    loadable_classes_allocated = <span class="hljs-number">0</span>;<br>    loadable_classes_used = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// Call all +loads for the detached list.</span><br>    <span class="hljs-comment">// 遍历loadable_classes列表调用+load方法，数组中越前面的元素越先被调用</span><br>    <span class="hljs-comment">// 根据schedule_class_load的递归查找还可以知道，父类的load方法要先于子类进行调用</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; used; i++) &#123;<br>        Class cls = classes[i].cls;<br>        <span class="hljs-comment">// 取出类中的load方法</span><br>        <span class="hljs-type">load_method_t</span> load_method = (<span class="hljs-type">load_method_t</span>)classes[i].method;<br>        <span class="hljs-keyword">if</span> (!cls) <span class="hljs-keyword">continue</span>; <br><br>        <span class="hljs-keyword">if</span> (PrintLoading) &#123;<br>            _objc_inform(<span class="hljs-string">&quot;LOAD: +[%s load]\n&quot;</span>, cls-&gt;<span class="hljs-built_in">nameForLogging</span>());<br>        &#125;<br>        <span class="hljs-comment">// 使用指针进行调用</span><br>        (*load_method)(cls, SEL_load);<br>    &#125;<br>    <br>    <span class="hljs-comment">// Destroy the detached list.</span><br>    <span class="hljs-keyword">if</span> (classes) <span class="hljs-built_in">free</span>(classes);<br>&#125;<br></code></pre></td></tr></table></figure><p>本质就是通过便利之前我们创建的loadable_classes调用+load，越前面的元素越先被调用，load_method_t是直接取出+load方法，所以不走消息机制！！！（runtime里面不走消息机制，很正常啊~~~~</p><h2 id="call-category-loads"><a href="#call-category-loads" class="headerlink" title="call_category_loads"></a>call_category_loads</h2><p>调用category的+load</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">call_category_loads</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, shift;<br>    <span class="hljs-type">bool</span> new_categories_added = NO;<br>    <br>    <span class="hljs-comment">// Detach current loadable list.</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">loadable_category</span> *cats = loadable_categories;<br>    <span class="hljs-type">int</span> used = loadable_categories_used;<br>    <span class="hljs-type">int</span> allocated = loadable_categories_allocated;<br>    loadable_categories = nil;<br>    loadable_categories_allocated = <span class="hljs-number">0</span>;<br>    loadable_categories_used = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// Call all +loads for the detached list.</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; used; i++) &#123;<br>        Category cat = cats[i].cat;<br>        <span class="hljs-comment">// 取出分类中的load方法，返回值是一个函数地址</span><br>        <span class="hljs-type">load_method_t</span> load_method = (<span class="hljs-type">load_method_t</span>)cats[i].method;<br>        Class cls;<br>        <span class="hljs-keyword">if</span> (!cat) <span class="hljs-keyword">continue</span>;<br><br>        cls = _category_getClass(cat);<br>        <span class="hljs-keyword">if</span> (cls  &amp;&amp;  cls-&gt;<span class="hljs-built_in">isLoadable</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (PrintLoading) &#123;<br>                _objc_inform(<span class="hljs-string">&quot;LOAD: +[%s(%s) load]\n&quot;</span>, <br>                             cls-&gt;<span class="hljs-built_in">nameForLogging</span>(), <br>                             _category_getName(cat));<br>            &#125;<br>            <span class="hljs-comment">// 使用指针进行调用</span><br>            (*load_method)(cls, SEL_load);<br>            cats[i].cat = nil;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Compact detached list (order-preserving)</span><br>    shift = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; used; i++) &#123;<br>        <span class="hljs-keyword">if</span> (cats[i].cat) &#123;<br>            cats[i-shift] = cats[i];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            shift++;<br>        &#125;<br>    &#125;<br>    used -= shift;<br><br>    <span class="hljs-comment">// Copy any new +load candidates from the new list to the detached list.</span><br>    new_categories_added = (loadable_categories_used &gt; <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; loadable_categories_used; i++) &#123;<br>        <span class="hljs-keyword">if</span> (used == allocated) &#123;<br>            allocated = allocated*<span class="hljs-number">2</span> + <span class="hljs-number">16</span>;<br>            cats = (<span class="hljs-keyword">struct</span> loadable_category *)<br>                <span class="hljs-built_in">realloc</span>(cats, allocated *<br>                                  <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> loadable_category));<br>        &#125;<br>        cats[used++] = loadable_categories[i];<br>    &#125;<br><br>    <span class="hljs-comment">// 以下代码是一些释放代码，可以忽略</span><br>    <span class="hljs-comment">// Destroy the new list.</span><br>    <span class="hljs-keyword">if</span> (loadable_categories) <span class="hljs-built_in">free</span>(loadable_categories);<br><br>    <span class="hljs-comment">// Reattach the (now augmented) detached list. </span><br>    <span class="hljs-comment">// But if there&#x27;s nothing left to load, destroy the list.</span><br>    <span class="hljs-keyword">if</span> (used) &#123;<br>        loadable_categories = cats;<br>        loadable_categories_used = used;<br>        loadable_categories_allocated = allocated;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (cats) <span class="hljs-built_in">free</span>(cats);<br>        loadable_categories = nil;<br>        loadable_categories_used = <span class="hljs-number">0</span>;<br>        loadable_categories_allocated = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (PrintLoading) &#123;<br>        <span class="hljs-keyword">if</span> (loadable_categories_used != <span class="hljs-number">0</span>) &#123;<br>            _objc_inform(<span class="hljs-string">&quot;LOAD: %d categories still waiting for +load\n&quot;</span>,<br>                         loadable_categories_used);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> new_categories_added;<br>&#125;<br></code></pre></td></tr></table></figure><p>不用再说了吧</p><h2 id="load总结"><a href="#load总结" class="headerlink" title="+load总结"></a>+load总结</h2><ul><li>+load会在rutime加载类、category时自动调用</li><li>每个类、category的+load只会执行1次</li><li>类的+load顺序：父类总是优先于子类，在该原则基础上取决于编译顺序</li><li>category的+load顺序：在类之后，取决于编译顺序</li><li>同一个image中，类总是优先于category的+load</li><li>+load是直接调用函数地址，不是通过消息转发</li></ul><h1 id="initialize"><a href="#initialize" class="headerlink" title="+initialize"></a>+initialize</h1><p>该方法是在类首次收到消息时被触发，看以下代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-comment">// FatherA</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">FatherA</span></span><br><br>+ (<span class="hljs-type">void</span>)initialize &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">FatherA</span>(<span class="hljs-title">NN</span>)</span><br><br>+ (<span class="hljs-type">void</span>)initialize &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">FatherA</span>(<span class="hljs-title">Nero</span>)</span><br><br>+ (<span class="hljs-type">void</span>)initialize &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">// SonA</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">SonA</span></span><br><br>+ (<span class="hljs-type">void</span>)initialize &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">SonA</span>(<span class="hljs-title">NN</span>)</span><br><br>+ (<span class="hljs-type">void</span>)initialize &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">SonA</span>(<span class="hljs-title">Nero</span>)</span><br><br>+ (<span class="hljs-type">void</span>)initialize &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">// FatherB</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">FatherB</span></span><br><br>+ (<span class="hljs-type">void</span>)initialize &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br>&#125;<br><br><span class="hljs-comment">// SonB</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">SonB</span></span><br><br>+ (<span class="hljs-type">void</span>)initialize &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br>&#125;<br></code></pre></td></tr></table></figure><p>测试调用：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-comment">// 测试代码</span><br>[SonA alloc];<br>[SonA alloc];<br>[SonA alloc];<br>    <br>[FatherB alloc];<br></code></pre></td></tr></table></figure><p>测试输出：<br><img src="/../images/image-53.png" alt="alt text"></p><ul><li>由于+initialize是走消息机制的，所以category的方法能够覆盖主类的方法</li><li>由于类可能不会收到消息，所以+initialzie可能永远不会被调用</li><li>父类的+initialize优先于子类调用(子类的initialize不会覆盖父类！！！)</li></ul><h2 id="initialize的实现"><a href="#initialize的实现" class="headerlink" title="+initialize的实现"></a>+initialize的实现</h2><p>该方法实际是走消息机制，在objc-runtime-new.m，找到lookUpImpOrForward，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (initialize  &amp;&amp;  !cls-&gt;<span class="hljs-built_in">isInitialized</span>()) &#123;<br>    runtimeLock.<span class="hljs-built_in">unlock</span>();<br>    _class_initialize (_class_getNonMetaClass(cls, inst));<br>    runtimeLock.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-comment">// If sel == initialize, _class_initialize will send +initialize and</span><br>    <span class="hljs-comment">// then the messenger will send +initialize again after this</span><br>    <span class="hljs-comment">// procedure finishes. Of course, if this is not being called</span><br>    <span class="hljs-comment">// from the messenger then it won&#x27;t happen. 2778172</span><br>&#125;<br></code></pre></td></tr></table></figure><p>若类没有被初始化，则调用_class_initialize，源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/***********************************************************************</span><br><span class="hljs-comment">* class_initialize.  Send the &#x27;+initialize&#x27; message on demand to any</span><br><span class="hljs-comment">* uninitialized class. Force initialization of superclasses first.</span><br><span class="hljs-comment">**********************************************************************/</span><br><span class="hljs-type">void</span> _class_initialize(Class cls)<br>&#123;<br>    ...<br>    <br>    <span class="hljs-comment">// Make sure super is done initializing BEFORE beginning to initialize cls.</span><br>    <span class="hljs-comment">// See note about deadlock above.</span><br>    supercls = cls-&gt;superclass;<br>    <span class="hljs-keyword">if</span> (supercls  &amp;&amp;  !supercls-&gt;<span class="hljs-built_in">isInitialized</span>()) &#123;<br>        <span class="hljs-comment">// 沿着cls的父类一直往上查找知道NSObject</span><br>        _class_initialize(supercls);<br>    &#125;<br>    <br>    ...<br>            <span class="hljs-comment">//  使用objc_msgSend调用initialize方法</span><br>            <span class="hljs-built_in">callInitialize</span>(cls);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>_class_initialize实际也会递归调用，先确保父类层级的+initialize调用，然后调用自己方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callInitialize</span><span class="hljs-params">(Class cls)</span></span><br><span class="hljs-function"></span>&#123;<br>    ((<span class="hljs-built_in">void</span>(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);<br>    <span class="hljs-built_in">asm</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>和+load方法不同，对于+initialize调用，内部还是走得消息机制</p><h2 id="initialize总结"><a href="#initialize总结" class="headerlink" title="+initialize总结"></a>+initialize总结</h2><ul><li>该方法在类第一次收到消息时被调用，所以该方法可能永远不会调用</li><li>调用顺序：父类优先于子类，且分类会覆盖主类</li><li>若子类继承父类，但是没有覆盖该方法，则由于每个子类在初次使用时都每初始化，那么也都会调用1次该方法，从而造成该方法可能多次调用</li><li>若想确保只执行1次，那么可以如下判断：<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC">+ (<span class="hljs-type">void</span>)initialize &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> == [ClassName <span class="hljs-keyword">self</span>]) &#123;<br>    <span class="hljs-comment">// ... do the initialization ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>+load和+initialize的区别总结：<br><img src="/../images/image-54.png" alt="alt text"></p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Runtime</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OC Runtime-消息机制和super关键字</title>
    <link href="/2024/03/04/oc-runtime-message-super/"/>
    <url>/2024/03/04/oc-runtime-message-super/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要回忆下OC Runtime中消息机制和super关键字的实现</p><h1 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h1><p>我们知道，在OC中调用方法，不是直接调用函数地址，而是通过Runtime的消息机制，在调用[object method]时，编译器会将其转换为对objc_msgSend(id self, SEL op, …)的函数调用<br>具体的消息发送机制，可以翻看之前的深入理解OC Runtime</p><h1 id="关于super关键字"><a href="#关于super关键字" class="headerlink" title="关于super关键字"></a>关于super关键字</h1><p>直接看下面的问题：</p><p>1.下面的输出是啥？</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Son</span> : <span class="hljs-title">Father</span></span><br>- (<span class="hljs-type">id</span>)init &#123;<br>    <span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>)  &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>]));<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>([<span class="hljs-variable language_">super</span> <span class="hljs-keyword">class</span>]));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>答案：输出的都是Son，解释如下：</p><p>因为对于super关键字的调用，编译器会将其转换为objc_msgSendSuper</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">id <span class="hljs-title">objc_msgSendSuper</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> objc_super *super, SEL op, ...)</span></span><br></code></pre></td></tr></table></figure><p>其中，第一个参数是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">objc_super</span> &#123;<br>id receiver; <span class="hljs-comment">// 当前调用实例</span><br>Class superClass; <span class="hljs-comment">// 当前调用实例的父类</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>该函数会从superClass的methodList中查找对应方法，找到后，将receiver传递进去。由于Father和Son均没有覆盖class方法，<code>所以最终调用到的是NSObject的class方法，该方法的源码在runtime中是取出传递进来的receiver的isa，也就是Son</code>！</p><p>当然，如果Father或者Son覆盖了class方法，还是会走到覆盖的方法中.</p><p>2.下面的输出是啥？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++">@interface Father : NSObject<br>- (<span class="hljs-type">void</span>)printCurrentClass;<br>@end<br><br>@implementation Father<br><br>- (<span class="hljs-type">void</span>)printCurrentClass &#123;<br>    <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;printCurrentClass:%@&quot;</span>, [self <span class="hljs-keyword">class</span>]);<br>&#125;<br><br>@end<br><br><br>@interface Son : Father<br>- (<span class="hljs-type">void</span>)printSuperClass;<br>@end<br><br>@implementation Son<br><br>- (<span class="hljs-type">void</span>)printSuperClass &#123;<br>    [super printCurrentClass];<br>&#125;<br><br>@end<br><br><span class="hljs-comment">// 调用方法</span><br>Son *son = [Son <span class="hljs-keyword">new</span>];<br>[son printCurrentClass]; <span class="hljs-comment">// 直接调用父类方法，子类没有重载</span><br>    <br>[son printSuperClass]; <span class="hljs-comment">// 间接调用父类方法</span><br></code></pre></td></tr></table></figure><p>答：也都是Son。原因同上，只要记住，<code>调用super，只是找到的super中的方法，但是super方法中传递的实例仍然是self</code>！</p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Runtime</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解GCD-Dispatch Group</title>
    <link href="/2024/02/29/think-deep-in-gcd-dispatch-group/"/>
    <url>/2024/02/29/think-deep-in-gcd-dispatch-group/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前已经了解了dispatch_semaphore的底层实现，而dispatch_group的实现时基于前者。dispatch_group通常应用在控制并发任务的执行顺序。例如：有A、B、C三个并发任务，要求在A、B、C都执行完毕后后，才能刷新页面，此时就可以使用dispatch_group控制：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC">- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    <br>    __block <span class="hljs-built_in">NSInteger</span> number = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 创建dispatch group</span><br>    dispatch_group_t group = dispatch_group_create();<br>    <br>    <span class="hljs-comment">//A耗时操作</span><br>    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>        sleep(<span class="hljs-number">3</span>);<br>        number += <span class="hljs-number">2222</span>;<br>    &#125;);<br>    <br>    <span class="hljs-comment">//B网络请求</span><br>    dispatch_group_enter(group);<br>    [<span class="hljs-keyword">self</span> sendRequestWithCompletion:^(<span class="hljs-type">id</span> response) &#123;<br>        number += [response integerValue];<br>        dispatch_group_leave(group);<br>    &#125;];<br>    <br>    <span class="hljs-comment">//C网络请求</span><br>    dispatch_group_enter(group);<br>    [<span class="hljs-keyword">self</span> sendRequestWithCompletion:^(<span class="hljs-type">id</span> response) &#123;<br>        number += [response integerValue];<br>        dispatch_group_leave(group);<br>    &#125;];<br>    <br>    <span class="hljs-comment">// 注意此处，只有当A、B、C任务执行完毕后，notify中的任务才能执行</span><br>    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%zd&quot;</span>, number);<br>    &#125;);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)sendRequestWithCompletion:(<span class="hljs-type">void</span> (^)(<span class="hljs-type">id</span> response))completion &#123;<br>    <span class="hljs-comment">//模拟一个网络请求</span><br>    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>        sleep(<span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br>            <span class="hljs-keyword">if</span> (completion) completion(@<span class="hljs-number">1111</span>);<br>        &#125;);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>根据上面的流程，看下dispatch_group相关的api的内部实现</p><h2 id="dispatch-group-create"><a href="#dispatch-group-create" class="headerlink" title="dispatch_group_create"></a>dispatch_group_create</h2><p>创建dispatch_group</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">dispatch_group_t</span></span><br><span class="hljs-function"><span class="hljs-title">dispatch_group_create</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">dispatch_group_t</span>)<span class="hljs-built_in">dispatch_semaphore_create</span>(LONG_MAX);<br>&#125;<br></code></pre></td></tr></table></figure><p>欸？是不是很熟悉，dispatch_group的本质实际就是信号量！只不过这个信号量的初始值是LONG_MAX</p><h2 id="dispatch-group-async"><a href="#dispatch-group-async" class="headerlink" title="dispatch_group_async"></a>dispatch_group_async</h2><p>该函数用于将异步任务与group关联起来，源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">dispatch_group_async</span><span class="hljs-params">(<span class="hljs-type">dispatch_group_t</span> dg, <span class="hljs-type">dispatch_queue_t</span> dq,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">dispatch_block_t</span> db)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">dispatch_group_async_f</span>(dg, dq, _dispatch_Block_copy(db),<br>_dispatch_call_block_and_release);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="dispatch-group-async-f"><a href="#dispatch-group-async-f" class="headerlink" title="dispatch_group_async_f"></a>dispatch_group_async_f</h2><p>该函数的源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">dispatch_group_async_f</span><span class="hljs-params">(<span class="hljs-type">dispatch_group_t</span> dg, <span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> *ctxt,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">dispatch_function_t</span> func)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">dispatch_continuation_t</span> dc;<br><br>_dispatch_retain(dg);<br><span class="hljs-built_in">dispatch_group_enter</span>(dg);<br><br>dc = <span class="hljs-built_in">fastpath</span>(_dispatch_continuation_alloc_cacheonly());<br><span class="hljs-keyword">if</span> (!dc) &#123;<br>dc = _dispatch_continuation_alloc_from_heap();<br>&#125;<br><br>dc-&gt;do_vtable = (<span class="hljs-type">void</span> *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_GROUP_BIT);<br>dc-&gt;dc_func = func;<br>dc-&gt;dc_ctxt = ctxt;<br>dc-&gt;dc_group = dg;<br><br><span class="hljs-comment">// No fastpath/slowpath hint because we simply don&#x27;t know</span><br><span class="hljs-keyword">if</span> (dq-&gt;dq_width != <span class="hljs-number">1</span> &amp;&amp; dq-&gt;do_targetq) &#123;<br><span class="hljs-keyword">return</span> _dispatch_async_f2(dq, dc);<br>&#125;<br><br>_dispatch_queue_push(dq, dc);<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的代码中我们看出，dispatch_group_async_f和之前在说queue的时候的dispatch_async_f是类似的。只不过刚开始多了个dispatch_group_enter(dg)的操作。另外在封装dc时，vtable中多了个DISPATCH_OBJ_GROUP_BIT的标志位，说明该dc是group中的任务。既然有enter，那么也有leave，这个leave在哪呢？在我们之前了解queue的时候，在_dispatch_continuation_pop中，有这么一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">_dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);<br><span class="hljs-keyword">if</span> (dg) &#123;<br><span class="hljs-comment">//group需要进行调用dispatch_group_leave并释放信号</span><br><span class="hljs-built_in">dispatch_group_leave</span>(dg);<br>_dispatch_release(dg);<br>&#125;<br></code></pre></td></tr></table></figure><p>原来如此，如果任务是在group中，那么在执行完block之后，会调用leave。</p><p>概括下dispatch_group_async_f的工作流程：</p><ul><li>调用dispatch_group_enter</li><li>将任务和queue封装到dispatch_continuation_t，并将其加入到group的链表中</li><li>_dispatch_continuation_pop会在执行时判断任务是否是group中的任务，若是，则执行dispatch_group_leave以释放信号量</li></ul><h2 id="dispatch-group-enter"><a href="#dispatch-group-enter" class="headerlink" title="dispatch_group_enter"></a>dispatch_group_enter</h2><p>实际就是dispatch_semaphore_wait的封装：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">dispatch_group_enter</span><span class="hljs-params">(<span class="hljs-type">dispatch_group_t</span> dg)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">dispatch_semaphore_t</span> dsema = (<span class="hljs-type">dispatch_semaphore_t</span>)dg;<br><br>(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_semaphore_wait</span>(dsema, DISPATCH_TIME_FOREVER);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="dispatch-group-leave"><a href="#dispatch-group-leave" class="headerlink" title="dispatch_group_leave"></a>dispatch_group_leave</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">dispatch_group_leave</span><span class="hljs-params">(<span class="hljs-type">dispatch_group_t</span> dg)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">dispatch_semaphore_t</span> dsema = (<span class="hljs-type">dispatch_semaphore_t</span>)dg;<br><span class="hljs-built_in">dispatch_atomic_release_barrier</span>();<br><span class="hljs-type">long</span> value = <span class="hljs-built_in">dispatch_atomic_inc2o</span>(dsema, dsema_value);<span class="hljs-comment">//dsema_value原子性加1</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(value == LONG_MIN)) &#123;<span class="hljs-comment">//内存溢出，由于dispatch_group_leave在dispatch_group_enter之前调用</span><br><span class="hljs-built_in">DISPATCH_CLIENT_CRASH</span>(<span class="hljs-string">&quot;Unbalanced call to dispatch_group_leave()&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(value == dsema-&gt;dsema_orig)) &#123;<span class="hljs-comment">//表示所有任务已经完成，唤醒group</span><br>(<span class="hljs-type">void</span>)_dispatch_group_wake(dsema);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的源码中可以看出，leave就是将信号量值原子加1，若value为LONG_MIN说明leave数量超过enter。如果信号值等于原始值，则说明所有的任务已完成，需要尝试唤醒notify中的任务。</p><p>这里说明下enter和leave的关系</p><ul><li>enter&#x2F;leave需要成对使用，若enter超过leave，则notify不会被唤醒；若enter小于leave，则会崩溃</li><li>enter必须在leave之前出现，否则崩溃</li></ul><h2 id="dispatch-group-notify"><a href="#dispatch-group-notify" class="headerlink" title="dispatch_group_notify"></a>dispatch_group_notify</h2><p>该函数用于我们指定在group中所有任务执行完毕后执行的操作，源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">dispatch_group_notify</span><span class="hljs-params">(<span class="hljs-type">dispatch_group_t</span> dg, <span class="hljs-type">dispatch_queue_t</span> dq,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">dispatch_block_t</span> db)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">dispatch_group_notify_f</span>(dg, dq, _dispatch_Block_copy(db),<br>_dispatch_call_block_and_release);<br>&#125;<br></code></pre></td></tr></table></figure><p>看具体实现</p><h2 id="dispatch-group-notify-f"><a href="#dispatch-group-notify-f" class="headerlink" title="dispatch_group_notify_f"></a>dispatch_group_notify_f</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">dispatch_group_notify_f</span><span class="hljs-params">(<span class="hljs-type">dispatch_group_t</span> dg, <span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> *ctxt,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">void</span> (*func)(<span class="hljs-type">void</span> *))</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">dispatch_semaphore_t</span> dsema = (<span class="hljs-type">dispatch_semaphore_t</span>)dg;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_sema_notify_s</span> *dsn, *prev;<br><br><span class="hljs-comment">//封装dispatch_continuation_t结构体</span><br><span class="hljs-comment">// FIXME -- this should be updated to use the continuation cache</span><br><span class="hljs-keyword">while</span> (!(dsn = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">sizeof</span>(*dsn)))) &#123;<br><span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br>dsn-&gt;dsn_queue = dq;<br>dsn-&gt;dsn_ctxt = ctxt;<br>dsn-&gt;dsn_func = func;<br>_dispatch_retain(dq);<br><span class="hljs-built_in">dispatch_atomic_store_barrier</span>();<br><span class="hljs-comment">//将结构体放到链表尾部，如果链表为空同时设置链表头部节点并唤醒group</span><br>prev = <span class="hljs-built_in">dispatch_atomic_xchg2o</span>(dsema, dsema_notify_tail, dsn);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fastpath</span>(prev)) &#123;<br>prev-&gt;dsn_next = dsn;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>_dispatch_retain(dg);<br>(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_atomic_xchg2o</span>(dsema, dsema_notify_head, dsn);<br><span class="hljs-keyword">if</span> (dsema-&gt;dsema_value == dsema-&gt;dsema_orig) &#123;<span class="hljs-comment">//任务已经完成，唤醒group</span><br>_dispatch_group_wake(dsema);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的主要作用是将传入dc用notify的链表保存到起来（因为可以将多个dc加入到链表中）</p><h2 id="dispatch-group-wake"><a href="#dispatch-group-wake" class="headerlink" title="_dispatch_group_wake"></a>_dispatch_group_wake</h2><p>该函数用于唤醒在notfiy链表上等待的任务</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-type">long</span><br>_dispatch_group_wake(<span class="hljs-type">dispatch_semaphore_t</span> dsema)<br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_sema_notify_s</span> *next, *head, *tail = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">long</span> rval;<br><span class="hljs-comment">//将dsema的dsema_notify_head赋值为NULL，同时将之前的内容赋给head</span><br>head = <span class="hljs-built_in">dispatch_atomic_xchg2o</span>(dsema, dsema_notify_head, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">if</span> (head) &#123;<br><span class="hljs-comment">// snapshot before anything is notified/woken &lt;rdar://problem/8554546&gt;</span><br><span class="hljs-comment">//将dsema的dsema_notify_tail赋值为NULL，同时将之前的内容赋给tail</span><br>tail = <span class="hljs-built_in">dispatch_atomic_xchg2o</span>(dsema, dsema_notify_tail, <span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-comment">//将dsema的dsema_group_waiters设置为0，并返回原来的值</span><br>rval = <span class="hljs-built_in">dispatch_atomic_xchg2o</span>(dsema, dsema_group_waiters, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (rval) &#123;<br><span class="hljs-comment">//循环调用semaphore_signal唤醒当初等待group的信号量，使得dispatch_group_wait函数返回。</span><br><span class="hljs-comment">// wake group waiters</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_MACH_SEM</span><br>_dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_waiter_port);<br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-type">kern_return_t</span> kr = <span class="hljs-built_in">semaphore_signal</span>(dsema-&gt;dsema_waiter_port);<br><span class="hljs-built_in">DISPATCH_SEMAPHORE_VERIFY_KR</span>(kr);<br>&#125; <span class="hljs-keyword">while</span> (--rval);<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> USE_POSIX_SEM</span><br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">sem_post</span>(&amp;dsema-&gt;dsema_sem);<br><span class="hljs-built_in">DISPATCH_SEMAPHORE_VERIFY_RET</span>(ret);<br>&#125; <span class="hljs-keyword">while</span> (--rval);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><span class="hljs-keyword">if</span> (head) &#123;<br><span class="hljs-comment">//获取链表，依次调用dispatch_async_f异步执行在notify函数中的任务即Block。</span><br><span class="hljs-comment">// async group notify blocks</span><br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-built_in">dispatch_async_f</span>(head-&gt;dsn_queue, head-&gt;dsn_ctxt, head-&gt;dsn_func);<br>_dispatch_release(head-&gt;dsn_queue);<br>next = <span class="hljs-built_in">fastpath</span>(head-&gt;dsn_next);<br><span class="hljs-keyword">if</span> (!next &amp;&amp; head != tail) &#123;<br><span class="hljs-keyword">while</span> (!(next = <span class="hljs-built_in">fastpath</span>(head-&gt;dsn_next))) &#123;<br>_dispatch_hardware_pause();<br>&#125;<br>&#125;<br><span class="hljs-built_in">free</span>(head);<br>&#125; <span class="hljs-keyword">while</span> ((head = next));<br>_dispatch_release(dsema);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的主要作用：</p><ul><li>用内核函数semaphore_signal来唤醒等待group的信号量，使得dispatch_group_wait返回（因为有可能我们直接调用dispatch_group_wait来等待group中的任务执行完毕，而不是采用notify的方式）</li><li>获取链表，依次调用dispatch_async_f执行在notify聊表中的任务（这是notify的方式）</li></ul><p>PS：除了可以使用dispathc_group_async，我们也可以手动调用enter和leave，实现更加灵活的控制。</p><p>到这里，我们基本上对dispatch_group的工作机制有了更深的认识，一张图表示：<br><img src="/../images/image-50.png" alt="Alt text"></p><h2 id="dispatch-group-wait"><a href="#dispatch-group-wait" class="headerlink" title="dispatch_group_wait"></a>dispatch_group_wait</h2><p>这个函数是我们直接等待group执行完毕，不使用notify链表，其源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">long</span></span><br><span class="hljs-function"><span class="hljs-title">dispatch_group_wait</span><span class="hljs-params">(<span class="hljs-type">dispatch_group_t</span> dg, <span class="hljs-type">dispatch_time_t</span> timeout)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">dispatch_semaphore_t</span> dsema = (<span class="hljs-type">dispatch_semaphore_t</span>)dg;<br><br><span class="hljs-keyword">if</span> (dsema-&gt;dsema_value == dsema-&gt;dsema_orig) &#123;<span class="hljs-comment">//没有需要执行的任务</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (timeout == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//返回超时</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_MACH_SEM</span><br><span class="hljs-keyword">return</span> KERN_OPERATION_TIMED_OUT;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> USE_POSIX_SEM</span><br>errno = ETIMEDOUT;<br><span class="hljs-keyword">return</span> (<span class="hljs-number">-1</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><span class="hljs-keyword">return</span> _dispatch_group_wait_slow(dsema, timeout);<br>&#125;<br></code></pre></td></tr></table></figure><p>具体逻辑看下面：</p><h2 id="dispatch-group-wait-slow"><a href="#dispatch-group-wait-slow" class="headerlink" title="_dispatch_group_wait_slow"></a>_dispatch_group_wait_slow</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-type">long</span><br>_dispatch_group_wait_slow(<span class="hljs-type">dispatch_semaphore_t</span> dsema, <span class="hljs-type">dispatch_time_t</span> timeout)<br>&#123;<br><span class="hljs-type">long</span> orig;<br><br>again:<br><span class="hljs-comment">// check before we cause another signal to be sent by incrementing</span><br><span class="hljs-comment">// dsema-&gt;dsema_group_waiters</span><br><span class="hljs-keyword">if</span> (dsema-&gt;dsema_value == dsema-&gt;dsema_orig) &#123;<br><span class="hljs-keyword">return</span> _dispatch_group_wake(dsema);<br>&#125;<br><span class="hljs-comment">// Mach semaphores appear to sometimes spuriously wake up. Therefore,</span><br><span class="hljs-comment">// we keep a parallel count of the number of times a Mach semaphore is</span><br><span class="hljs-comment">// signaled (6880961).</span><br>(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_atomic_inc2o</span>(dsema, dsema_group_waiters);<br><span class="hljs-comment">// check the values again in case we need to wake any threads</span><br><span class="hljs-keyword">if</span> (dsema-&gt;dsema_value == dsema-&gt;dsema_orig) &#123;<br><span class="hljs-keyword">return</span> _dispatch_group_wake(dsema);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_MACH_SEM</span><br><span class="hljs-type">mach_timespec_t</span> _timeout;<br><span class="hljs-type">kern_return_t</span> kr;<br><br>_dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_waiter_port);<br><br><span class="hljs-comment">// From xnu/osfmk/kern/sync_sema.c:</span><br><span class="hljs-comment">// wait_semaphore-&gt;count = -1; /* we don&#x27;t keep an actual count */</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The code above does not match the documentation, and that fact is</span><br><span class="hljs-comment">// not surprising. The documented semantics are clumsy to use in any</span><br><span class="hljs-comment">// practical way. The above hack effectively tricks the rest of the</span><br><span class="hljs-comment">// Mach semaphore logic to behave like the libdispatch algorithm.</span><br><br><span class="hljs-keyword">switch</span> (timeout) &#123;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-type">uint64_t</span> nsec = _dispatch_timeout(timeout);<br>_timeout.tv_sec = (<span class="hljs-built_in">typeof</span>(_timeout.tv_sec))(nsec / NSEC_PER_SEC);<br>_timeout.tv_nsec = (<span class="hljs-built_in">typeof</span>(_timeout.tv_nsec))(nsec % NSEC_PER_SEC);<br>kr = <span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">semaphore_timedwait</span>(dsema-&gt;dsema_waiter_port,<br>_timeout));<br>&#125; <span class="hljs-keyword">while</span> (kr == KERN_ABORTED);<br><br><span class="hljs-keyword">if</span> (kr != KERN_OPERATION_TIMED_OUT) &#123;<br><span class="hljs-built_in">DISPATCH_SEMAPHORE_VERIFY_KR</span>(kr);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">// Fall through and try to undo the earlier change to</span><br><span class="hljs-comment">// dsema-&gt;dsema_group_waiters</span><br><span class="hljs-keyword">case</span> DISPATCH_TIME_NOW:<br><span class="hljs-keyword">while</span> ((orig = dsema-&gt;dsema_group_waiters)) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">dispatch_atomic_cmpxchg2o</span>(dsema, dsema_group_waiters, orig,<br>orig - <span class="hljs-number">1</span>)) &#123;<br><span class="hljs-keyword">return</span> KERN_OPERATION_TIMED_OUT;<br>&#125;<br>&#125;<br><span class="hljs-comment">// Another thread called semaphore_signal().</span><br><span class="hljs-comment">// Fall through and drain the wakeup.</span><br><span class="hljs-keyword">case</span> DISPATCH_TIME_FOREVER:<br><span class="hljs-keyword">do</span> &#123;<br>kr = <span class="hljs-built_in">semaphore_wait</span>(dsema-&gt;dsema_waiter_port);<br>&#125; <span class="hljs-keyword">while</span> (kr == KERN_ABORTED);<br><span class="hljs-built_in">DISPATCH_SEMAPHORE_VERIFY_KR</span>(kr);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> USE_POSIX_SEM</span><br><span class="hljs-comment">//这部分代码省略</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">goto</span> again;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，该函数和之前在信号量中说到的_dispatch_semaphore_wait_slow非常类似，都是基于mach内核的semaphore_wait。区别在于后者在等待结束后是return，直接继续执行后续逻辑，而group在被唤醒之后是调用_dispatch_group_wake来唤醒整个group（因为semaphore_signal一次只能唤醒一个任务，如果有多个任务，则需要执行多次才能全部唤醒，吐槽：感觉gcd实现的耦合性好高，没有设计思路自己理解真的很难理解他的设计初衷…）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>dispatch_group实际就是个初始值为LONG_MAX的信号量，判断任务是否完成的条件是看信号量是否恢复为初始值</li><li>enter和levave必须成对出现</li><li>若enter超过leave，则不会被唤醒；若leave超过enter，则会崩溃</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>GCD</tag>
      
      <tag>Dispatch Group</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解GCD-Dispatch Semaphore</title>
    <link href="/2024/02/28/think-deep-in-gcd-dispatch-seamphore/"/>
    <url>/2024/02/28/think-deep-in-gcd-dispatch-seamphore/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前我们了解了gcd queue的实现，现在来回忆下gcd中的信号量机制，gcd的group基本是围绕着seamphore实现的</p><p>信号量，使用都说烂了，可以就认为是共享资源的数量，数量大于0时，则可以获取到，直接执行，执行完后归还获取的数量，如有必要唤醒其他等待线程；数量小于0时，资源不够用要等待</p><p>gcd的信号量机制实际仍然是基于mach kernel的系统调用和mach port</p><h2 id="dispatch-semaphore-t"><a href="#dispatch-semaphore-t" class="headerlink" title="dispatch_semaphore_t"></a>dispatch_semaphore_t</h2><p>dispatch_semaphore_s是信号量的结构体，它可以当做dispatch_semaphore_t来使用，源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_semaphore_s</span> &#123;<br><span class="hljs-built_in">DISPATCH_STRUCT_HEADER</span>(dispatch_semaphore_s, dispatch_semaphore_vtable_s);<br><span class="hljs-type">long</span> dsema_value;<span class="hljs-comment">//当前信号量</span><br><span class="hljs-type">long</span> dsema_orig;<span class="hljs-comment">//初始化信号量</span><br><span class="hljs-type">size_t</span> dsema_sent_ksignals;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_MACH_SEM &amp;&amp; USE_POSIX_SEM</span><br><span class="hljs-meta">#<span class="hljs-keyword">error</span> <span class="hljs-string">&quot;Too many supported semaphore types&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> USE_MACH_SEM</span><br><span class="hljs-type">semaphore_t</span> dsema_port;<br><span class="hljs-type">semaphore_t</span> dsema_waiter_port;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> USE_POSIX_SEM</span><br><span class="hljs-type">sem_t</span> dsema_sem;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">error</span> <span class="hljs-string">&quot;No supported semaphore type&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">size_t</span> dsema_group_waiters;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_sema_notify_s</span> *dsema_notify_head; <span class="hljs-comment">//notify链表头部</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_sema_notify_s</span> *dsema_notify_tail; <span class="hljs-comment">//notify链表尾部</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">mach_port_t</span><span class="hljs-type">semaphore_t</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_sema_notify_s</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_sema_notify_s</span> *<span class="hljs-keyword">volatile</span> dsn_next; <span class="hljs-comment">//下一个信号节点</span><br><span class="hljs-type">dispatch_queue_t</span> dsn_queue;<span class="hljs-comment">//操作的队列</span><br><span class="hljs-type">void</span> *dsn_ctxt;<span class="hljs-comment">//上下文</span><br><span class="hljs-built_in">void</span> (*dsn_func)(<span class="hljs-type">void</span> *);<span class="hljs-comment">//执行函数</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="dispatch-semaphore-create"><a href="#dispatch-semaphore-create" class="headerlink" title="dispatch_semaphore_create"></a>dispatch_semaphore_create</h2><p>该函数用于信号量的创建，即创建一个dispatch_semaphore_t，源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">dispatch_semaphore_t</span></span><br><span class="hljs-function"><span class="hljs-title">dispatch_semaphore_create</span><span class="hljs-params">(<span class="hljs-type">long</span> value)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">dispatch_semaphore_t</span> dsema;<br><br><span class="hljs-comment">// If the internal value is negative, then the absolute of the value is</span><br><span class="hljs-comment">// equal to the number of waiting threads. Therefore it is bogus to</span><br><span class="hljs-comment">// initialize the semaphore with a negative value.</span><br><span class="hljs-keyword">if</span> (value &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//value必须大于等于0</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//申请dispatch_semaphore_s的内存</span><br>dsema = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> dispatch_semaphore_s));<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fastpath</span>(dsema)) &#123;<br><span class="hljs-comment">//设置dispatch_semaphore_s 的操作函数</span><br>dsema-&gt;do_vtable = &amp;_dispatch_semaphore_vtable;<br><span class="hljs-comment">//设置链表尾部</span><br>dsema-&gt;do_next = DISPATCH_OBJECT_LISTLESS;<br><span class="hljs-comment">//引用计数</span><br>dsema-&gt;do_ref_cnt = <span class="hljs-number">1</span>;<br>dsema-&gt;do_xref_cnt = <span class="hljs-number">1</span>;<br><span class="hljs-comment">//目标队列的设置</span><br>dsema-&gt;do_targetq = <span class="hljs-built_in">dispatch_get_global_queue</span>(<br>DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);<br><span class="hljs-comment">//当前信号量和初始化信号的赋值</span><br>dsema-&gt;dsema_value = value;<br>dsema-&gt;dsema_orig = value;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_POSIX_SEM</span><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">sem_init</span>(&amp;dsema-&gt;dsema_sem, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">DISPATCH_SEMAPHORE_VERIFY_RET</span>(ret);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br><span class="hljs-keyword">return</span> dsema;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的源码中，信号量的操作函数dsema-&gt;do_vtable &#x3D; &amp;_dispatch_semaphore_vtable定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_semaphore_vtable_s</span> _dispatch_semaphore_vtable = &#123;<br>.do_type = DISPATCH_SEMAPHORE_TYPE,<br>.do_kind = <span class="hljs-string">&quot;semaphore&quot;</span>,<br>    <span class="hljs-comment">// 信号量的销毁函数</span><br>.do_dispose = _dispatch_semaphore_dispose,<br>.do_debug = _dispatch_semaphore_debug,<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中_dispatch_semaphore_dispose是信号量的销毁函数，其源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br>_dispatch_semaphore_dispose(<span class="hljs-type">dispatch_semaphore_t</span> dsema)<br>&#123;<br><span class="hljs-comment">//信号量的当前值小于初始化，会发生闪退。因为信号量已经被释放了</span><br><span class="hljs-keyword">if</span> (dsema-&gt;dsema_value &lt; dsema-&gt;dsema_orig) &#123;<br><span class="hljs-built_in">DISPATCH_CLIENT_CRASH</span>(<br><span class="hljs-string">&quot;Semaphore/group object deallocated while in use&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_MACH_SEM</span><br><span class="hljs-type">kern_return_t</span> kr;<br><span class="hljs-comment">//释放信号，这个信号是dispatch_semaphore使用的信号</span><br><span class="hljs-keyword">if</span> (dsema-&gt;dsema_port) &#123;<br>kr = <span class="hljs-built_in">semaphore_destroy</span>(<span class="hljs-built_in">mach_task_self</span>(), dsema-&gt;dsema_port);<br><span class="hljs-built_in">DISPATCH_SEMAPHORE_VERIFY_KR</span>(kr);<br>&#125;<br><span class="hljs-comment">//释放信号，这个信号是dispatch_group使用的信号</span><br><span class="hljs-keyword">if</span> (dsema-&gt;dsema_waiter_port) &#123;<br>kr = <span class="hljs-built_in">semaphore_destroy</span>(<span class="hljs-built_in">mach_task_self</span>(), dsema-&gt;dsema_waiter_port);<br><span class="hljs-built_in">DISPATCH_SEMAPHORE_VERIFY_KR</span>(kr);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> USE_POSIX_SEM</span><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">sem_destroy</span>(&amp;dsema-&gt;dsema_sem);<br><span class="hljs-built_in">DISPATCH_SEMAPHORE_VERIFY_RET</span>(ret);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>_dispatch_dispose(dsema);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="dispatch-semaphore-wait"><a href="#dispatch-semaphore-wait" class="headerlink" title="dispatch_semaphore_wait"></a>dispatch_semaphore_wait</h2><p>该函数用于，创建好seamphore之后，可以进行wait申请信号量资源，源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">long</span></span><br><span class="hljs-function"><span class="hljs-title">dispatch_semaphore_wait</span><span class="hljs-params">(<span class="hljs-type">dispatch_semaphore_t</span> dsema, <span class="hljs-type">dispatch_time_t</span> timeout)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//原子性减1，这里说明dsema_value是当前信号值，并将新值赋给value</span><br><span class="hljs-type">long</span> value = <span class="hljs-built_in">dispatch_atomic_dec2o</span>(dsema, dsema_value);<br><span class="hljs-built_in">dispatch_atomic_acquire_barrier</span>();<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fastpath</span>(value &gt;= <span class="hljs-number">0</span>)) &#123;<br><span class="hljs-comment">//说明有资源可用，直接返回0，表示等到信号量的信息了</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//等待信号量唤醒或者timeout超时</span><br><span class="hljs-keyword">return</span> _dispatch_semaphore_wait_slow(dsema, timeout);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，若wait之后信号量是大于等于0的，说明资源可用，则无需等待，否则线程进入等待，等待信号量释放被唤醒</p><h2 id="dispatch-semaphore-wait-slow"><a href="#dispatch-semaphore-wait-slow" class="headerlink" title="_dispatch_semaphore_wait_slow"></a>_dispatch_semaphore_wait_slow</h2><p>在上面我们知道，当信号量value小于0，则线程进入wait等待被唤醒或者等待超时，该函数源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-type">long</span><br>_dispatch_semaphore_wait_slow(<span class="hljs-type">dispatch_semaphore_t</span> dsema,<br><span class="hljs-type">dispatch_time_t</span> timeout)<br>&#123;<br><span class="hljs-type">long</span> orig;<br><br>again:<br><span class="hljs-comment">// Mach semaphores appear to sometimes spuriously wake up. Therefore,</span><br><span class="hljs-comment">// we keep a parallel count of the number of times a Mach semaphore is</span><br><span class="hljs-comment">// signaled (6880961).</span><br><span class="hljs-comment">//第一部分：</span><br><span class="hljs-comment">//只要dsema-&gt;dsema_sent_ksignals不为零就会进入循环</span><br><span class="hljs-comment">//dispatch_atomic_cmpxchg2o(dsema, dsema_sent_ksignals, orig,orig - 1)的意思是</span><br><span class="hljs-comment">//dsema-&gt;dsema_sent_ksignals如果等于orig，则将orig - 1赋值给dsema_sent_ksignals，</span><br><span class="hljs-comment">//并且返回true，否则返回false。</span><br><span class="hljs-comment">//如果返回true，说明又获取了资源</span><br><span class="hljs-keyword">while</span> ((orig = dsema-&gt;dsema_sent_ksignals)) &#123; <span class="hljs-comment">// 先获取当前的ksignals，若不为0，进入判断，若等于0，则退出while循环，执行后续逻辑（由于信号量初始化时就是0，所以一开始是跳过while循环的）</span><br>        <span class="hljs-comment">// 这里是CAS操作，可以认为是原子操作，将当前ksignals的之前的值和之前获取到的ksignals进行比较，若比较成功，则将ksignal-1,并返回true</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">dispatch_atomic_cmpxchg2o</span>(dsema, dsema_sent_ksignals, orig,<br>orig - <span class="hljs-number">1</span>)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_MACH_SEM</span><br><span class="hljs-type">mach_timespec_t</span> _timeout;<br><span class="hljs-type">kern_return_t</span> kr;<br><br><span class="hljs-comment">//第二部分：dispatch_semaphore_s中的dsema_port赋值，以懒加载的形式</span><br>_dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port);<br><br><span class="hljs-comment">// From xnu/osfmk/kern/sync_sema.c:</span><br><span class="hljs-comment">// wait_semaphore-&gt;count = -1; /* we don&#x27;t keep an actual count */</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The code above does not match the documentation, and that fact is</span><br><span class="hljs-comment">// not surprising. The documented semantics are clumsy to use in any</span><br><span class="hljs-comment">// practical way. The above hack effectively tricks the rest of the</span><br><span class="hljs-comment">// Mach semaphore logic to behave like the libdispatch algorithm.</span><br><br><span class="hljs-comment">//第三部分：</span><br><span class="hljs-keyword">switch</span> (timeout) &#123;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">//计算剩余时间，调用mach内核的等待函数semaphore_timedwait()进行等待。</span><br><span class="hljs-comment">//如果在指定时间内没有得到通知，则会一直阻塞住，监听dsema_port等待其通知；</span><br><span class="hljs-comment">//当超时的时候，会执行下面的case代码（这个default没有break）。</span><br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-type">uint64_t</span> nsec = _dispatch_timeout(timeout);<br>_timeout.tv_sec = (<span class="hljs-built_in">typeof</span>(_timeout.tv_sec))(nsec / NSEC_PER_SEC);<br>_timeout.tv_nsec = (<span class="hljs-built_in">typeof</span>(_timeout.tv_nsec))(nsec % NSEC_PER_SEC);<br>kr = <span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">semaphore_timedwait</span>(dsema-&gt;dsema_port, _timeout));<br>&#125; <span class="hljs-keyword">while</span> (kr == KERN_ABORTED);<br><br><span class="hljs-keyword">if</span> (kr != KERN_OPERATION_TIMED_OUT) &#123;<br><span class="hljs-built_in">DISPATCH_SEMAPHORE_VERIFY_KR</span>(kr);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">// Fall through and try to undo what the fast path did to</span><br><span class="hljs-comment">// dsema-&gt;dsema_value</span><br><span class="hljs-keyword">case</span> DISPATCH_TIME_NOW:<br><span class="hljs-comment">//若当前信号量desma_value小于0，对其加一并返回超时信号KERN_OPERATION_TIMED_OUT。</span><br><span class="hljs-comment">//KERN_OPERATION_TIMED_OUT代表等待超时而返回</span><br><span class="hljs-comment">//由于一开始在第一部分代码中进行了减1操作，所以需要加1以撤销之前的操作。</span><br><span class="hljs-keyword">while</span> ((orig = dsema-&gt;dsema_value) &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">dispatch_atomic_cmpxchg2o</span>(dsema, dsema_value, orig, orig + <span class="hljs-number">1</span>)) &#123;<br><span class="hljs-keyword">return</span> KERN_OPERATION_TIMED_OUT;<br>&#125;<br>&#125;<br><span class="hljs-comment">// Another thread called semaphore_signal().</span><br><span class="hljs-comment">// Fall through and drain the wakeup.</span><br><span class="hljs-keyword">case</span> DISPATCH_TIME_FOREVER:<br><span class="hljs-comment">//一直等待直到有信号。当有信号的时候说明dsema_value大于0，会跳转到again，重新执行本函数的流程</span><br><span class="hljs-keyword">do</span> &#123;<br>kr = <span class="hljs-built_in">semaphore_wait</span>(dsema-&gt;dsema_port);<br>&#125; <span class="hljs-keyword">while</span> (kr == KERN_ABORTED);<br><span class="hljs-built_in">DISPATCH_SEMAPHORE_VERIFY_KR</span>(kr);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> USE_POSIX_SEM</span><br>    <span class="hljs-comment">//此处的代码省略，跟上面USE_MACH_SEM代码类似</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">goto</span> again;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的源码中，有几个地方需要注意：</p><ul><li>第一部分的while循环和if条件，在dsema_sent_ksignals非0的情况下会进入while循环，if条件是使用CAS操作判断当前的dsema-&gt;dsema_sent_ksignals是否等于进入循环时的orig，若相等，则将dsema_sent_ksignals进行减1操作，并返回，表示获取到了信号量资源。但是由于一开始初始化seamphore的时候并没有对dsema_sent_ksignals进行赋值，所以不会进入while</li><li>在上面出现了semaphore_timedwait和semaphore_wait，这些方法定义在seamphore.h中，所以dispatch_semaphore<code>是基于mach kernel的信号量接口实现的</code>。另外，这两个方法传入的参数是dsema_port。即dsema_port被mach kernel的semaphore监听，线程的唤醒实际是基于mach port的</li><li>之前我们看到dispatch_semaphore_s中有dsema_waiter_port。全局搜索下，该属性用于dispatch_group中。而dispatch_group是基于dispatch_semaphore，在dispatch_group的semaphore_wait并不是监听的dsema_port，而是dsema_waiter_port</li></ul><p>dispatch_semaphore_wait的流程图如下：<br><img src="/../images/image-48.png" alt="Alt text"></p><h2 id="dispatch-semaphore-signal"><a href="#dispatch-semaphore-signal" class="headerlink" title="dispatch_semaphore_signal"></a>dispatch_semaphore_signal</h2><p>释放信号量的代码相对等待信号信号量的代码要简单，无需阻塞，只做释放操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">long</span></span><br><span class="hljs-function"><span class="hljs-title">dispatch_semaphore_signal</span><span class="hljs-params">(<span class="hljs-type">dispatch_semaphore_t</span> dsema)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">dispatch_atomic_release_barrier</span>();<br><span class="hljs-comment">//原子性加1，value大于0 说明有资源立即返回</span><br><span class="hljs-type">long</span> value = <span class="hljs-built_in">dispatch_atomic_inc2o</span>(dsema, dsema_value);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fastpath</span>(value &gt; <span class="hljs-number">0</span>)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(value == LONG_MIN)) &#123;<br><span class="hljs-built_in">DISPATCH_CLIENT_CRASH</span>(<span class="hljs-string">&quot;Unbalanced call to dispatch_semaphore_signal()&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> _dispatch_semaphore_signal_slow(dsema);<br>&#125;<br></code></pre></td></tr></table></figure><p>可见，如果释放后value&lt;&#x3D;0，则说明有其他地方再等待，需要调用kernel执行唤醒操作</p><h2 id="dispatch-semaphore-signal-slow"><a href="#dispatch-semaphore-signal-slow" class="headerlink" title="_dispatch_semaphore_signal_slow"></a>_dispatch_semaphore_signal_slow</h2><p>该函数作用，调用内核semaphore_signal唤醒在dispatch_semaphore_wait等待的线程，然后返回1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">long</span><br>_dispatch_semaphore_signal_slow(<span class="hljs-type">dispatch_semaphore_t</span> dsema)<br>&#123;<br><span class="hljs-comment">// Before dsema_sent_ksignals is incremented we can rely on the reference</span><br><span class="hljs-comment">// held by the waiter. However, once this value is incremented the waiter</span><br><span class="hljs-comment">// may return between the atomic increment and the semaphore_signal(),</span><br><span class="hljs-comment">// therefore an explicit reference must be held in order to safely access</span><br><span class="hljs-comment">// dsema after the atomic increment.</span><br>_dispatch_retain(dsema);<br>    <span class="hljs-comment">// 注意在唤醒其他线程时，增加了dsema_sent_ksignals的值，每唤醒1次就+1，而被唤醒线程在刚开始时会判断dsema_sent_ksignals，如果不为0，说明是被唤醒的，此时通过原子操作进行减1，减1之后如果是0，则说明争用到了信号量（此时其他线程会失败，重新进入wait操作）</span><br>(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_atomic_inc2o</span>(dsema, dsema_sent_ksignals);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_MACH_SEM</span><br>_dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port);<br><span class="hljs-type">kern_return_t</span> kr = <span class="hljs-built_in">semaphore_signal</span>(dsema-&gt;dsema_port);<br><span class="hljs-built_in">DISPATCH_SEMAPHORE_VERIFY_KR</span>(kr);<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> USE_POSIX_SEM</span><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">sem_post</span>(&amp;dsema-&gt;dsema_sem);<br><span class="hljs-built_in">DISPATCH_SEMAPHORE_VERIFY_RET</span>(ret);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>_dispatch_release(dsema);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>dispatch_semaphore_signal的流程如下：<br><img src="/../images/image-49.png" alt="Alt text"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>dispatch_semaphore是基于mach kernel的信号量接口实现</li><li>dispatch_semaphore_wait信号量减1，dispatch_semaphore_signal信号量加1</li><li>在wait中，原子减1后，信号量大于等于0，说明获取到了资源，否则进入等待被唤醒或者超时；在signal中，原子加1后，信号量大于0说明没有其他线程在等待被唤醒，否则执行唤醒</li><li>dispatch_semaphore利用两个变量来处理wait和signal，即desma_value和dsema_sent_ksignals。如果signal时，如果不需要唤醒其他等待线程，则只需要使用desma_value。当需要唤醒线程时，发送的信号是dsema_sent_ksignals，此时会重新执行wait的流程。<code>所以在wait中一开始是判断dsema_sent_ksignals，通过原子操作争用，争用不到的，重新进入wait进行等待</code></li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>Q:如何控制线程并发数？<br>A:使用信号量，创建指定数值的信号量，那么执行async时wait，任务之后完毕后signal，这样创建出来的线程数不会超过信号量数值</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="hljs-string">&quot;concurrentQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br><span class="hljs-built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="hljs-string">&quot;serialQueue&quot;</span>,DISPATCH_QUEUE_SERIAL);<br>dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="hljs-number">4</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">15</span>; i++) &#123;<br>    <span class="hljs-built_in">dispatch_async</span>(serialQueue, ^&#123;<br>        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>        <span class="hljs-built_in">dispatch_async</span>(concurrentQueue, ^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;thread:%@开始执行任务%d&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread],(<span class="hljs-type">int</span>)i);<br>            sleep(<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;thread:%@结束执行任务%d&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread],(<span class="hljs-type">int</span>)i);<br>            dispatch_semaphore_signal(semaphore);&#125;);<br>    &#125;);<br>&#125;<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;主线程...!&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>GCD</tag>
      
      <tag>Dispatch Seamphore</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解GCD-Dispatch Queue</title>
    <link href="/2024/02/21/think-deep-in-gcd-dispatch-queue/"/>
    <url>/2024/02/21/think-deep-in-gcd-dispatch-queue/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前在OC高级中，已经对GCD有了了解，这里通过深入libdispatch的源码进行理解，源码传送门：<a href="https://github.com/apple-oss-distributions/libdispatch/tags">https://github.com/apple-oss-distributions/libdispatch/tags</a></p><h2 id="queue和线程之间的关系"><a href="#queue和线程之间的关系" class="headerlink" title="queue和线程之间的关系"></a>queue和线程之间的关系</h2><ul><li>之前我们知道，queue负责存放任务，queue中任务的具体执行最终需要线程执行</li><li>不同的queue中的任务可以放到同一个线程上，每个线程在执行queue中任务时会记录当前正在执行的是哪个queue的任务</li><li>并发queue可以同时将多个任务放在多个线程上执行，串行queue只能每次在单个线程上执行一个任务</li><li>一个queue可以设置另一个queue为自己的目标queue，即将自己整体作为任务以另一个queue的策略执行，比如一个<code>并发queue设置一个串行queue作为目标，那么并发queue中的所有任务也都变成了串行</code><br>一张图可以解释：<br><img src="/../images/image-43.png" alt="Alt text"><br>可以看到，queue和线程并非一对一关系，一个线程可以执行多个queue的任务（但同一时间肯定是只能执行一个queue的任务，所以有线程的当前queue的概念）。queue可以串行也可以是并行。</li><li>但是对于main queue优点特殊，main queue的任务只能在主线程上执行；反之则不然，主线程也能执行非main queue的任务，如下代码：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">// 测试代码</span><br><span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() &#123;<br>    <span class="hljs-keyword">super</span>.viewDidLoad()<br>    <br>    <span class="hljs-keyword">let</span> sQueue <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>(label: <span class="hljs-string">&quot;sQueue&quot;</span>)<br>    <span class="hljs-comment">// 串行队列同步不会产生新线程，任务在当前线程下执行，因此Thread.current必然是主线程</span><br>    sQueue.sync &#123; <span class="hljs-built_in">print</span>(<span class="hljs-type">Thread</span>.current) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><code>注意是同步执行时不会产生新线程，如果是异步执行，仍然会产生新线程</code></li></ul><h2 id="queue的定义"><a href="#queue的定义" class="headerlink" title="queue的定义"></a>queue的定义</h2><h3 id="dispatch-queue-s"><a href="#dispatch-queue-s" class="headerlink" title="dispatch_queue_s"></a>dispatch_queue_s</h3><p>在源码中，通过dispatch_queue_s来定义queue，为了方便后续分析，先列出一些函数方便理解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_s</span> &#123;<br>    <span class="hljs-comment">// 第一部分：DISPATCH_STRUCT_HEADER(dispatch_queue_s, dispatch_queue_vtable_s)</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_vtable_s</span> *do_vtable; <span class="hljs-comment">// 该类型的结构体包含了对dispatch_queue_s的操作函数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_s</span> *<span class="hljs-keyword">volatile</span> do_next; <span class="hljs-comment">//链表的next</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> do_ref_cnt; <span class="hljs-comment">// 引用计数</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> do_xref_cnt; <span class="hljs-comment">// 外部引用计数</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> do_suspend_cnt; <span class="hljs-comment">// 暂停标志，比如延时处理中，在任务到时后，计时器处理将会将该标志位修改，然后唤醒队列调度</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_s</span> *do_targetq; <span class="hljs-comment">// 目标队列，GCD允许我们将一个队列放在另一个队列里执行任务</span><br><span class="hljs-type">void</span> *do_ctxt; <span class="hljs-comment">// 上下文，用来存储线程池相关数据，比如用于线程挂起和唤醒的信号量、线程池尺寸等</span><br><span class="hljs-type">void</span> *do_finalizer;<br><br>    <span class="hljs-comment">// 第二部分：DISPATCH_QUEUE_HEADER</span><br>    <span class="hljs-type">uint32_t</span> <span class="hljs-keyword">volatile</span> dq_running; <span class="hljs-comment">// 队列运行的任务数量</span><br>    <span class="hljs-type">uint32_t</span> dq_width; <span class="hljs-comment">// 最大并发数：主队列/串行队列的最大并发数为1</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_object_s</span> *<span class="hljs-keyword">volatile</span> dq_items_tail; <span class="hljs-comment">// 队列尾结点</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_object_s</span> *<span class="hljs-keyword">volatile</span> dq_items_head; <span class="hljs-comment">// 队列头结点</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> dq_serialnum; <span class="hljs-comment">// 队列序列号</span><br>    <span class="hljs-type">dispatch_queue_t</span> dq_specific_q; <span class="hljs-comment">// specific队列</span><br><br>    <span class="hljs-type">char</span> dq_label[DISPATCH_QUEUE_MIN_LABEL_SIZE]; <span class="hljs-comment">// 队列名，队列名要少于64个字符    </span><br>    <span class="hljs-type">char</span> _dq_pad[DISPATCH_QUEUE_CACHELINE_PAD]; <span class="hljs-comment">// for static queues only</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="dispatch-queue-vtable-s"><a href="#dispatch-queue-vtable-s" class="headerlink" title="dispatch_queue_vtable_s"></a>dispatch_queue_vtable_s</h3><p>在上面我们可以看到，dispatch_queue_s中包含了dispatch_queue_vtable_s，该结构体包含了针对dispatch_queue_s的操作函数，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// dispatch_queue_vtable_s结构体，声明了一些函数用于操作dispatch_queue_s结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_vtable_s</span> &#123;<br><span class="hljs-comment">// DISPATCH_VTABLE_HEADER(dispatch_queue_s);</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">const</span> do_type;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-type">const</span> do_kind;<br><span class="hljs-built_in">size_t</span> (*<span class="hljs-type">const</span> do_debug)(<span class="hljs-keyword">struct</span> dispatch_queue_s *, <span class="hljs-type">char</span> *, <span class="hljs-type">size_t</span>);<br><span class="hljs-comment">// 唤醒队列的方法，全局队列和主队列此项为NULL</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_s</span> *(*<span class="hljs-type">const</span> do_invoke)(<span class="hljs-keyword">struct</span> dispatch_queue_s); <br><span class="hljs-comment">// 用于检测传入对象中的一些值是否满足条件</span><br><span class="hljs-built_in">bool</span> (*<span class="hljs-type">const</span> do_probe)(<span class="hljs-keyword">struct</span> dispatch_queue_s *);<br><span class="hljs-comment">// 销毁队列的方法，通常内部会调用这个对象的finalizer函数</span><br><span class="hljs-built_in">void</span> (*<span class="hljs-type">const</span> do_dispose)(<span class="hljs-keyword">struct</span> dispatch_queue_s *)<br>&#125;;<br></code></pre></td></tr></table></figure><p>在queue.c中定义了三个预定义的dispatch_queue_vtable_s，分别用于main queue&amp;自定义queue、global queue和manager queue</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 用于主队列和自定义队列</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_vtable_s</span> _dispatch_queue_vtable = &#123;<br>.do_type = DISPATCH_QUEUE_TYPE,<br>.do_kind = <span class="hljs-string">&quot;queue&quot;</span>,<br>.do_dispose = _dispatch_queue_dispose,<br>.do_invoke = <span class="hljs-literal">NULL</span>,<br>.do_probe = (<span class="hljs-type">void</span> *)dummy_function_r0,<br>.do_debug = dispatch_queue_debug,<br>&#125;;<br><br><span class="hljs-comment">// 用于全局队列</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_vtable_s</span> _dispatch_queue_root_vtable = &#123;<br>.do_type = DISPATCH_QUEUE_GLOBAL_TYPE,<br>.do_kind = <span class="hljs-string">&quot;global-queue&quot;</span>,<br>.do_debug = dispatch_queue_debug,<br>.do_probe = _dispatch_queue_wakeup_global,<br>&#125;;<br><br><span class="hljs-comment">// 用于管理队列</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_vtable_s</span> _dispatch_queue_mgr_vtable = &#123;<br>.do_type = DISPATCH_QUEUE_MGR_TYPE,<br>.do_kind = <span class="hljs-string">&quot;mgr-queue&quot;</span>,<br>.do_invoke = _dispatch_mgr_thread,<br>.do_debug = dispatch_queue_debug,<br>.do_probe = _dispatch_mgr_wakeup,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="queue的类型"><a href="#queue的类型" class="headerlink" title="queue的类型"></a>queue的类型</h2><p>queue可以分为main queue、自定义queue、global queue和manager queue</p><h3 id="main-queue"><a href="#main-queue" class="headerlink" title="main queue"></a>main queue</h3><p>我们最为熟悉，通过dispatch_get_main_queue即可获取，其内部定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> dispatch_get_main_queue() (&amp;_dispatch_main_q)</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_s</span> _dispatch_main_q = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !DISPATCH_USE_RESOLVERS</span><br>.do_vtable = &amp;_dispatch_queue_vtable,<br>.do_targetq = &amp;_dispatch_root_queues[<br>DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY], <span class="hljs-comment">// root queue中的其中一个</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>.dq_label = <span class="hljs-string">&quot;com.apple.main-thread&quot;</span>,<br>.dq_running = <span class="hljs-number">1</span>,<br>.dq_width = <span class="hljs-number">1</span>, <span class="hljs-comment">// 说明主队列是一个串行队列</span><br>.dq_serialnum = <span class="hljs-number">1</span>, <span class="hljs-comment">// 主队列序列号</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>main queue的成员说明如下：<ul><li>do_vtable之前已经看到了，是预定义的_dispatch_queue_vtable</li><li>do_targetq，也是一个预定义的queue，其定义如下：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY] = &#123;<br>        .do_vtable = &amp;_dispatch_queue_root_vtable,<br>        .do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>        .do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>        .do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>        .do_ctxt = &amp;_dispatch_root_queue_contexts[<br>                DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY],<br>        .dq_label = <span class="hljs-string">&quot;com.apple.root.default-overcommit-priority&quot;</span>,<br>        .dq_running = <span class="hljs-number">2</span>,<br>        .dq_width = UINT32_MAX,<br>        .dq_serialnum = <span class="hljs-number">7</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li><li>do_ref_cnt、do_xref_cnt,引用计数，和GCD的对象内存管理相关（GCD内部有自己的引用计数规则，不采用ARC），下面是它的引用计数方法：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dispatch_retain</span><span class="hljs-params">(<span class="hljs-type">dispatch_object_t</span> dou)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dou._do-&gt;do_xref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT)) &#123;<br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// global object</span><br>&#125;<br><span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-type">void</span> _dispatch_retain(<span class="hljs-type">dispatch_object_t</span> dou) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dou._do-&gt;do_ref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT)) &#123;<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// global object</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dispatch_release</span><span class="hljs-params">(<span class="hljs-type">dispatch_object_t</span> dou)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dou._do-&gt;do_xref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 调用_dispatch_release函数;</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-type">void</span> _dispatch_release(<span class="hljs-type">dispatch_object_t</span> dou) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dou._do-&gt;do_ref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT)) &#123;<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// global object</span><br>    &#125;<br>    <span class="hljs-comment">// 调用dx_dispose宏即调用do_dispose</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>  从上述代码可以看出：1.由于main queue的ref cnt是DISPATCH_OBJECT_GLOBAL_REFCNT，因而main queue的生命周期是整个进程 2.当ref cnt为0时，GCD中的对象才会释放</li></ul></li></ul><h3 id="manager-queue"><a href="#manager-queue" class="headerlink" title="manager queue"></a>manager queue</h3><p>manager queue是只在GCD内部使用的queue，不对外公开。用于GCD内部的管理角色，比如GCD定时器就用到了它，其内部定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_s</span> _dispatch_mgr_q = &#123;<br>.do_vtable = &amp;_dispatch_queue_mgr_vtable,<br>.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>.do_targetq = &amp;_dispatch_root_queues[<br>DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY],<br>.dq_label = <span class="hljs-string">&quot;com.apple.libdispatch-manager&quot;</span>,<br>.dq_width = <span class="hljs-number">1</span>,<br>.dq_serialnum = <span class="hljs-number">2</span>, <span class="hljs-comment">// 管理队列序列号</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>manager queue的成员说明如下<ul><li>do_vtable：就是前面定义的_dispatch_queue_mgr_vtable</li><li>do_targetq：也是一个内部预定义的queue，如下：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">  [DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY] = &#123;<br>.do_vtable = &amp;_dispatch_queue_root_vtable,<br>.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY],<br>.dq_label = <span class="hljs-string">&quot;com.apple.root.high-overcommit-priority&quot;</span>,<br>.dq_running = <span class="hljs-number">2</span>,<br>.dq_width = UINT32_MAX,<br>.dq_serialnum = <span class="hljs-number">9</span>,<br>  &#125;<br></code></pre></td></tr></table></figure></li><li>do_ref_cnt、do_xref_cnt:和main queue相同，也是DISPATCH_OBJECT_GLOBAL_REFCNT，因而生命周期也是整个进程</li></ul></li></ul><h3 id="自定义queue"><a href="#自定义queue" class="headerlink" title="自定义queue"></a>自定义queue</h3><p>通过dispatch_queue_create创建出来的queue就属于自定义queue，其源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">dispatch_queue_t</span> <span class="hljs-title">dispatch_queue_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *label, <span class="hljs-type">dispatch_queue_attr_t</span> attr)</span> </span>&#123;<br><span class="hljs-type">dispatch_queue_t</span> dq;<br><span class="hljs-type">size_t</span> label_len;<br><br><span class="hljs-keyword">if</span> (!label) &#123;<br>label = <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><br>label_len = <span class="hljs-built_in">strlen</span>(label);<br><span class="hljs-keyword">if</span> (label_len &lt; (DISPATCH_QUEUE_MIN_LABEL_SIZE - <span class="hljs-number">1</span>)) &#123;<br>label_len = (DISPATCH_QUEUE_MIN_LABEL_SIZE - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// XXX switch to malloc()</span><br>dq = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1ul</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> dispatch_queue_s) -<br>DISPATCH_QUEUE_MIN_LABEL_SIZE - DISPATCH_QUEUE_CACHELINE_PAD +<br>label_len + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(!dq)) &#123;<br><span class="hljs-keyword">return</span> dq;<br>&#125;<br><br><span class="hljs-comment">// _dispatch_queue_init(dq);</span><br><span class="hljs-comment">// 队列初始化展开如下</span><br>dq-&gt;do_vtable = &amp;_dispatch_queue_vtable;<br>dq-&gt;do_next = DISPATCH_OBJECT_LISTLESS;<br>dq-&gt;do_ref_cnt = <span class="hljs-number">1</span>;<br>dq-&gt;do_xref_cnt = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// Default target queue is overcommit!</span><br><span class="hljs-comment">// 使用的目标队列：_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY]</span><br>dq-&gt;do_targetq = _dispatch_get_root_queue(<span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>dq-&gt;dq_running = <span class="hljs-number">0</span>;<br>dq-&gt;dq_width = <span class="hljs-number">1</span>;<br>dq-&gt;dq_serialnum = <span class="hljs-built_in">dispatch_atomic_inc</span>(&amp;_dispatch_queue_serial_numbers) - <span class="hljs-number">1</span>;<br><br><span class="hljs-built_in">strcpy</span>(dq-&gt;dq_label, label);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fastpath</span>(!attr)) &#123;<br><span class="hljs-keyword">return</span> dq;<br>&#125;<br><span class="hljs-comment">// 如果是并发队列，设置最大并发数，UINT32_MAX可以看成不限制最大并发数</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fastpath</span>(attr == DISPATCH_QUEUE_CONCURRENT)) &#123;<br>dq-&gt;dq_width = UINT32_MAX;<br><span class="hljs-comment">// 设置目标队列，对于并发队列_dispatch_get_root_queue函数中的overcommit传的是false，获取的值： _dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY]</span><br>dq-&gt;do_targetq = _dispatch_get_root_queue(<span class="hljs-number">0</span>, <span class="hljs-literal">false</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">dispatch_debug_assert</span>(!attr, <span class="hljs-string">&quot;Invalid attribute&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> dq;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于slowpath和fastpath，实际是为了编译器优化，提高执行效率，slowpath表示该分支较少发生，fastpath表示该分支较大可能发生</p><ul><li><p>关于自定义queue的成员：</p><ul><li>do_vtable，和main queue相同，前面已经介绍了</li><li>do_targetq分为两种：<ul><li>自定义串行queue：通过dispatch_get_root_queue(0, true)获取，获取到的是_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY]</li><li>自定义并发queue：通过_dispatch_get_root_queue(0, false)获取，获取到的是_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY]</li><li>可以看到，true&#x2F;false代表是否要针对该queue创建新的线程，若是true，表示需要，否则不需要</li></ul></li><li>dq_serialnum是在_dispatch_queue_serial_numbers的基础上原子自增，从12开始，1到11是被内部保留的，如下：</li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// skip zero</span><br><span class="hljs-comment">// 1 - main_q</span><br><span class="hljs-comment">// 2 - mgr_q</span><br><span class="hljs-comment">// 3 - _unused_</span><br><span class="hljs-comment">// 4,5,6,7,8,9,10,11 - global queues</span><br><span class="hljs-comment">// we use &#x27;xadd&#x27; on Intel, so the initial value == next assigned</span><br></code></pre></td></tr></table></figure><p>  1是main queue，2是manager queue，3暂时未使用，4-11是global queue</p></li></ul><h3 id="global-queue"><a href="#global-queue" class="headerlink" title="global queue"></a>global queue</h3><p>我们使用dispatch_get_global_queue来获取，其源码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">dispatch_queue_t</span> <span class="hljs-title">dispatch_get_global_queue</span><span class="hljs-params">(<span class="hljs-type">long</span> priority, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (flags &amp; ~DISPATCH_QUEUE_OVERCOMMIT) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">return</span> _dispatch_get_root_queue(priority, flags &amp; DISPATCH_QUEUE_OVERCOMMIT);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">dispatch_queue_t</span> _dispatch_get_root_queue(<span class="hljs-type">long</span> priority, <span class="hljs-type">bool</span> overcommit) &#123;<br><span class="hljs-keyword">if</span> (overcommit) <span class="hljs-keyword">switch</span> (priority) &#123;<br><span class="hljs-keyword">case</span> DISPATCH_QUEUE_PRIORITY_LOW:<br><span class="hljs-keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY];<br><span class="hljs-keyword">case</span> DISPATCH_QUEUE_PRIORITY_DEFAULT:<br><span class="hljs-keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY];<br><span class="hljs-keyword">case</span> DISPATCH_QUEUE_PRIORITY_HIGH:<br><span class="hljs-keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY];<br><span class="hljs-keyword">case</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND:<br><span class="hljs-keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY];<br>&#125;<br><br><span class="hljs-keyword">switch</span> (priority) &#123;<br><span class="hljs-keyword">case</span> DISPATCH_QUEUE_PRIORITY_LOW:<br><span class="hljs-keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY];<br><span class="hljs-keyword">case</span> DISPATCH_QUEUE_PRIORITY_DEFAULT:<br><span class="hljs-keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY];<br><span class="hljs-keyword">case</span> DISPATCH_QUEUE_PRIORITY_HIGH:<br><span class="hljs-keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY];<br><span class="hljs-keyword">case</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND:<br><span class="hljs-keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY];<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_s</span> _dispatch_root_queues[] = &#123;<br>[DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY] = &#123;<br>.do_vtable = &amp;_dispatch_queue_root_vtable,<br>.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY],<br><br>.dq_label = <span class="hljs-string">&quot;com.apple.root.low-priority&quot;</span>,<br>.dq_running = <span class="hljs-number">2</span>,<br>.dq_width = UINT32_MAX,<br>.dq_serialnum = <span class="hljs-number">4</span>,<br>&#125;,<br>[DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY] = &#123;<br>.do_vtable = &amp;_dispatch_queue_root_vtable,<br>.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY],<br><br>.dq_label = <span class="hljs-string">&quot;com.apple.root.low-overcommit-priority&quot;</span>,<br>.dq_running = <span class="hljs-number">2</span>,<br>.dq_width = UINT32_MAX,<br>.dq_serialnum = <span class="hljs-number">5</span>,<br>&#125;,<br>[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY] = &#123;<br>.do_vtable = &amp;_dispatch_queue_root_vtable,<br>.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY],<br><br>.dq_label = <span class="hljs-string">&quot;com.apple.root.default-priority&quot;</span>,<br>.dq_running = <span class="hljs-number">2</span>,<br>.dq_width = UINT32_MAX,<br>.dq_serialnum = <span class="hljs-number">6</span>,<br>&#125;,<br>[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY] = &#123;<br>.do_vtable = &amp;_dispatch_queue_root_vtable,<br>.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY],<br><br>.dq_label = <span class="hljs-string">&quot;com.apple.root.default-overcommit-priority&quot;</span>,<br>.dq_running = <span class="hljs-number">2</span>,<br>.dq_width = UINT32_MAX,<br>.dq_serialnum = <span class="hljs-number">7</span>,<br>&#125;,<br>[DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY] = &#123;<br>.do_vtable = &amp;_dispatch_queue_root_vtable,<br>.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY],<br><br>.dq_label = <span class="hljs-string">&quot;com.apple.root.high-priority&quot;</span>,<br>.dq_running = <span class="hljs-number">2</span>,<br>.dq_width = UINT32_MAX,<br>.dq_serialnum = <span class="hljs-number">8</span>,<br>&#125;,<br>[DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY] = &#123;<br>.do_vtable = &amp;_dispatch_queue_root_vtable,<br>.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY],<br><br>.dq_label = <span class="hljs-string">&quot;com.apple.root.high-overcommit-priority&quot;</span>,<br>.dq_running = <span class="hljs-number">2</span>,<br>.dq_width = UINT32_MAX,<br>.dq_serialnum = <span class="hljs-number">9</span>,<br>&#125;,<br>[DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY] = &#123;<br>.do_vtable = &amp;_dispatch_queue_root_vtable,<br>.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY],<br><br>.dq_label = <span class="hljs-string">&quot;com.apple.root.background-priority&quot;</span>,<br>.dq_running = <span class="hljs-number">2</span>,<br>.dq_width = UINT32_MAX,<br>.dq_serialnum = <span class="hljs-number">10</span>,<br>&#125;,<br>[DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY] = &#123;<br>.do_vtable = &amp;_dispatch_queue_root_vtable,<br>.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY],<br><br>.dq_label = <span class="hljs-string">&quot;com.apple.root.background-overcommit-priority&quot;</span>,<br>.dq_running = <span class="hljs-number">2</span>,<br>.dq_width = UINT32_MAX,<br>.dq_serialnum = <span class="hljs-number">11</span>,<br>&#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>global queue的成员<ul><li><p>do_vtable是_dispatch_queue_root_vtable，在该vtable中，检测函数do_probe是_dispatch_queue_wakeup_global，用于唤醒global queue</p></li><li><p>do_targetq：之前我们看到，main queue、自定义queue和manager queue都使用预定义的queue作为target，但是global queue并没有，为啥没有呢，因为global queue获取到的就是root queue之一，root queue就不用再找target了，他们只能是其他queue的target</p></li><li><p>do_ref_cnt、do_xref_cnt：和main queue相同，所以也跟着整个进程</p></li><li><p>do_ctxt: 上下文，用于存储线程池相关数据，比如用于线程挂起和唤醒的信号量，其内部预定义：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_root_queue_context_s</span> _dispatch_root_queue_contexts[] = &#123;<br>    [DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>        .dgq_thread_mediator = &amp;_dispatch_thread_mediator[<br>                DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY],<br>        .dgq_thread_pool_size = MAX_THREAD_COUNT,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;,<br>    [DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>        .dgq_thread_mediator = &amp;_dispatch_thread_mediator[<br>                DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY],<br>        .dgq_thread_pool_size = MAX_THREAD_COUNT,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;,<br>    [DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>        .dgq_thread_mediator = &amp;_dispatch_thread_mediator[<br>                DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY],<br>        .dgq_thread_pool_size = MAX_THREAD_COUNT,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;,<br>    [DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>        .dgq_thread_mediator = &amp;_dispatch_thread_mediator[<br>                DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY],<br>        .dgq_thread_pool_size = MAX_THREAD_COUNT,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;,<br>    [DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>        .dgq_thread_mediator = &amp;_dispatch_thread_mediator[<br>                DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY],<br>        .dgq_thread_pool_size = MAX_THREAD_COUNT,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;,<br>    [DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>        .dgq_thread_mediator = &amp;_dispatch_thread_mediator[<br>                DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY],<br>        .dgq_thread_pool_size = MAX_THREAD_COUNT,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;,<br>    [DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>        .dgq_thread_mediator = &amp;_dispatch_thread_mediator[<br>                DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY],<br>        .dgq_thread_pool_size = MAX_THREAD_COUNT,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;,<br>    [DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>        .dgq_thread_mediator = &amp;_dispatch_thread_mediator[<br>                DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY],<br>        .dgq_thread_pool_size = MAX_THREAD_COUNT,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="queue中代码的同步执行：dispatch-sync"><a href="#queue中代码的同步执行：dispatch-sync" class="headerlink" title="queue中代码的同步执行：dispatch_sync"></a>queue中代码的同步执行：dispatch_sync</h2><p>首先明确，同步执行，即需要等待queue中代码执行完毕才能接着向下执行。<br>测试代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">// 串行队列</span><br><span class="hljs-keyword">let</span> sQueue <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>(label: <span class="hljs-string">&quot;sQueue&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>)<br>sQueue.sync &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-number">2</span>)</span>：<span class="hljs-subst">\(Thread.current)</span>&quot;</span>) &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-number">3</span>)<br>sQueue.sync &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-number">4</span>)</span>：<span class="hljs-subst">\(Thread.current)</span>&quot;</span>) &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-number">5</span>)<br><br><span class="hljs-comment">// 并行队列</span><br><span class="hljs-keyword">let</span> cQueue <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>(label: <span class="hljs-string">&quot;cQueue&quot;</span>, attributes: [.concurrent])<br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>)<br>cQueue.sync &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-number">2</span>)</span>：<span class="hljs-subst">\(Thread.current)</span>&quot;</span>) &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-number">3</span>)<br>cQueue.sync &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-number">4</span>)</span>：<span class="hljs-subst">\(Thread.current)</span>&quot;</span>) &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-number">1</span><br><span class="hljs-number">2</span>：<span class="hljs-operator">&lt;</span><span class="hljs-type">NSThread</span>: <span class="hljs-number">0x600002478980</span><span class="hljs-operator">&gt;</span>&#123;number <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, name <span class="hljs-operator">=</span> main&#125;<br><span class="hljs-number">3</span><br><span class="hljs-number">4</span>：<span class="hljs-operator">&lt;</span><span class="hljs-type">NSThread</span>: <span class="hljs-number">0x600002478980</span><span class="hljs-operator">&gt;</span>&#123;number <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, name <span class="hljs-operator">=</span> main&#125;<br><span class="hljs-number">5</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span>：<span class="hljs-operator">&lt;</span><span class="hljs-type">NSThread</span>: <span class="hljs-number">0x600002478980</span><span class="hljs-operator">&gt;</span>&#123;number <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, name <span class="hljs-operator">=</span> main&#125;<br><span class="hljs-number">3</span><br><span class="hljs-number">4</span>：<span class="hljs-operator">&lt;</span><span class="hljs-type">NSThread</span>: <span class="hljs-number">0x600002478980</span><span class="hljs-operator">&gt;</span>&#123;number <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, name <span class="hljs-operator">=</span> main&#125;<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>可见，<code>不管是串行queue和并发queue，只要是sync，都是在当前线程执行，不会使用新线程</code>，且会阻塞当前执行流，所以如果是在并发queue上同步执行，那么仍然不会创建新线程，而只是在当前线程执行。但是注意特殊情况：在异步线程执行sync到main queue的任务，仍然会在主线程执行！所以的main queue任务必须在主线程执行！！</p><h3 id="入口函数：dispatch-sync"><a href="#入口函数：dispatch-sync" class="headerlink" title="入口函数：dispatch_sync"></a>入口函数：dispatch_sync</h3><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dispatch_sync</span><span class="hljs-params">(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> (^work)(<span class="hljs-type">void</span>))</span> </span>&#123;<br><span class="hljs-comment">// DISPATCH_COCOA_COMPAT是Mac OS下才会走的</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_COCOA_COMPAT</span><br><span class="hljs-comment">// 是否是主队列</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dq == &amp;_dispatch_main_q)) &#123;<br><span class="hljs-comment">// 内部也是执行dispatch_sync_f函数</span><br><span class="hljs-keyword">return</span> _dispatch_sync_slow(dq, work);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Block_basic</span> *bb = (<span class="hljs-type">void</span> *)work;<br><span class="hljs-built_in">dispatch_sync_f</span>(dq, work, (<span class="hljs-type">dispatch_function_t</span>)bb-&gt;Block_invoke);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>虽然该函数缺乏了main queue，但是最终执行的还是dispatch_sync_f，其源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dispatch_sync_f</span><span class="hljs-params">(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> *ctxt, <span class="hljs-type">dispatch_function_t</span> func)</span> </span>&#123;<br><span class="hljs-comment">// 串行队列包括主队列</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fastpath</span>(dq-&gt;dq_width == <span class="hljs-number">1</span>)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">dispatch_barrier_sync_f</span>(dq, ctxt, func);<br>&#125;<br><span class="hljs-comment">// 全局队列，全局队列是没有do_targetq的，主队列/管理队列/自定义队列都有</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(!dq-&gt;do_targetq)) &#123;<br><span class="hljs-comment">// the global root queues do not need strict ordering</span><br>(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_atomic_add2o</span>(dq, dq_running, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">return</span> _dispatch_sync_f_invoke(dq, ctxt, func);<br>&#125;<br><span class="hljs-comment">// 其他队列</span><br>_dispatch_sync_f2(dq, ctxt, func);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>该函数区分了三种case：</p><ul><li>串行queue：执行dispatch_barrier_sync_f</li><li>并发queue：<ul><li>global queue：_dispatch_sync_f_invoke</li><li>非global queue：_dispatch_sync_f2</li></ul></li></ul><h3 id="重点函数dispatch-barrier-sync-f"><a href="#重点函数dispatch-barrier-sync-f" class="headerlink" title="重点函数dispatch_barrier_sync_f"></a>重点函数dispatch_barrier_sync_f</h3><p>该函数用于串行queue sync的时候，其实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dispatch_barrier_sync</span><span class="hljs-params">(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> (^work)(<span class="hljs-type">void</span>))</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_COCOA_COMPAT</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dq == &amp;_dispatch_main_q)) &#123;<br>   <span class="hljs-comment">// 内部调用dispatch_barrier_sync_f函数</span><br><span class="hljs-keyword">return</span> _dispatch_barrier_sync_slow(dq, work);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Block_basic</span> *bb = (<span class="hljs-type">void</span> *)work;<br><span class="hljs-built_in">dispatch_barrier_sync_f</span>(dq, work, (<span class="hljs-type">dispatch_function_t</span>)bb-&gt;Block_invoke);<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然区分main queue，但最终是调用dispatch_barrier_sync_f。查看源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">DISPATCH_NOINLINE</span><br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">dispatch_barrier_sync_f</span><span class="hljs-params">(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> *ctxt, <span class="hljs-type">dispatch_function_t</span> func)</span> </span>&#123;<br><span class="hljs-comment">// 1) ensure that this thread hasn&#x27;t enqueued anything ahead of this call</span><br><span class="hljs-comment">// 2) the queue is not suspended</span><br><span class="hljs-comment">// 1) 确保此线程在此调用之前没有入队</span><br><span class="hljs-comment">// 2) 队列未挂起</span><br><br><span class="hljs-comment">// 第1步：如果串行队列中存在其他任务或者队列被挂起，进入_dispatch_barrier_sync_f_slow，</span><br><span class="hljs-comment">// 等待这个队列中的其他任务完成(用信号量的方式通知)，然后执行这个任务。</span><br><span class="hljs-comment">// 多数情况下不会发生</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dq-&gt;dq_items_tail) || <span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">DISPATCH_OBJECT_SUSPENDED</span>(dq)))&#123;<br><span class="hljs-keyword">return</span> _dispatch_barrier_sync_f_slow(dq, ctxt, func);<br>&#125;<br><br><span class="hljs-comment">// 第2步：检查队列的dq_running状态，如果没有运行，进入_dispatch_barrier_sync_f_slow，等待激活。</span><br><span class="hljs-comment">// bool __sync_bool_compare_and_swap (type *ptr, type oldval, type newval, ...)</span><br><span class="hljs-comment">// 比较*ptr与oldval的值，如果两者相等，则将newval更新到*ptr并返回true</span><br><span class="hljs-comment">// dispatch_atomic_cmpxchg2o(dq, dq_running, 0, 1)相当于dq-&gt;dq_running为0的时候将</span><br><span class="hljs-comment">// dq-&gt;dq_running设置为1，并返回true</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(!<span class="hljs-built_in">dispatch_atomic_cmpxchg2o</span>(dq, dq_running, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>))) &#123;<br><span class="hljs-comment">// global queues and main queue bound to main thread always falls into</span><br><span class="hljs-comment">// the slow case</span><br><span class="hljs-comment">// 全局队列和绑定到主线程的主队列始终属于慢速情况即会进入_dispatch_barrier_sync_f_slow函数</span><br><span class="hljs-keyword">return</span> _dispatch_barrier_sync_f_slow(dq, ctxt, func);<br>&#125;<br><br><span class="hljs-comment">// 第3步：有多重队列，寻找真正的目标队列，其实还是回到了dispatch_sync_f方法</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dq-&gt;do_targetq-&gt;do_targetq)) &#123;<br><span class="hljs-keyword">return</span> _dispatch_barrier_sync_f_recurse(dq, ctxt, func);<br>&#125;<br><br><span class="hljs-comment">// 第4步：队列无任务执行，调用_dispatch_barrier_sync_f_invoke执行任务。</span><br><span class="hljs-comment">// 内部调用_dispatch_function_invoke去执行任务</span><br>_dispatch_barrier_sync_f_invoke(dq, ctxt, func);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中涉及到三个函数：</p><ul><li>_dispatch_barrier_sync_f_slow：若串行queue有任务正在执行，内部使用线程对应信号量并wait，使得当前线程挂起等待被唤醒</li><li>_dispatch_barrier_sync_f_recurse：内部调用dispatch_sync_f，这样形成递归，目的是查找最终的目标queue</li><li>若queue无任务执行，则可以直接执行，调用_dispatch_barrier_sync_f_invoke执行，执行时调用_dispatch_function_invoke</li><li>总结起来：有任务正在执行，先挂起线程，等待任务执行完毕再唤醒当前线程继续执行</li></ul><h3 id="dispatch-barrier-sync-f-invoke"><a href="#dispatch-barrier-sync-f-invoke" class="headerlink" title="_dispatch_barrier_sync_f_invoke"></a>_dispatch_barrier_sync_f_invoke</h3><p>该函数用于在串行queue当前无任务正在执行时，实际去执行任务，源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++">DISPATCH_NOINLINE<br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br>_dispatch_barrier_sync_f_invoke(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> *ctxt, <span class="hljs-type">dispatch_function_t</span> func) &#123;<br>    <span class="hljs-comment">// _dispatch_function_invoke的实现</span><br>    <span class="hljs-comment">// 将当前线程的dispatch_queue_key设置为dq，然后执行任务，</span><br>    <span class="hljs-comment">// 执行完之后再恢复到之前的old_dq</span><br>    <span class="hljs-type">dispatch_queue_t</span> old_dq = _dispatch_thread_getspecific(dispatch_queue_key);<br>_dispatch_thread_setspecific(dispatch_queue_key, dq);<br>_dispatch_client_callout(ctxt, func);<br>_dispatch_workitem_inc();<br>_dispatch_thread_setspecific(dispatch_queue_key, old_dq);<br><br><span class="hljs-comment">// 如果队列中存在其他任务，用信号量的方法唤醒，然后继续执行下一个任务</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dq-&gt;dq_items_tail)) &#123;<br><span class="hljs-keyword">return</span> _dispatch_barrier_sync_f2(dq);<br>&#125;<br><br><span class="hljs-comment">// dispatch_atomic_dec2o这个宏，会调用GCC内置的函数 __sync_sub_and_fetch，实现减法的原子性操作。因此这一行的意思是将dq_running的值减1，然后判断是否与0相等。</span><br><span class="hljs-comment">// _dispatch_wakeup为唤醒队列函数</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">dispatch_atomic_dec2o</span>(dq, dq_running) == <span class="hljs-number">0</span>)) &#123;<br>_dispatch_wakeup(dq);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>该函数总结就是：先执行任务，任务执行完毕之后若有其他任务在等着，则尝试唤醒，执行下一个任务</p><h3 id="GCD死锁产生的原因"><a href="#GCD死锁产生的原因" class="headerlink" title="GCD死锁产生的原因"></a>GCD死锁产生的原因</h3><p>我们知道，如果在主线程中使用dispatch_sync到main queue会造成死锁，比如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-meta">#import <span class="hljs-string">&quot;DeadLock.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">DeadLock</span></span><br><br>- (<span class="hljs-keyword">instancetype</span>)init &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init]) &#123;<br><span class="hljs-comment">//        [self _mianQueueDeadLock];</span><br>        [<span class="hljs-keyword">self</span> _serialQueueDeadLock];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - Private</span><br><br>- (<span class="hljs-type">void</span>)_mianQueueDeadLock &#123;<br>    <span class="hljs-built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^(<span class="hljs-type">void</span>)&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;这里死锁了&quot;</span>);<br>    &#125;);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)_serialQueueDeadLock &#123;<br>    <span class="hljs-built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="hljs-string">&quot;1serialQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <span class="hljs-built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="hljs-string">&quot;2serialQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <br>    <span class="hljs-built_in">dispatch_sync</span>(queue1, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;11111&quot;</span>);<br>        <br>        <span class="hljs-built_in">dispatch_sync</span>(queue1, ^&#123; <br>            <span class="hljs-comment">// 如果使用queue2就不会发生死锁，使用queue1就会死锁</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;22222&quot;</span>);<br>        &#125;);<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>以_serialQueueDeadLock为例，当我们首次执行串行queue任务时，正常执行，而执行到第二个dispatch_sync时，<code>由于上一个任务还没执行完毕(正在执行sync)，从而使得当前线程进入了wait，从而永远没有机会被唤醒，进入死锁</code></p><h3 id="dispatch-sync-f-invoke"><a href="#dispatch-sync-f-invoke" class="headerlink" title="_dispatch_sync_f_invoke"></a>_dispatch_sync_f_invoke</h3><p>该函数用于在并发的global queue同步执行任务时被调用，具体代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br>_dispatch_sync_f_invoke(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> *ctxt, <span class="hljs-type">dispatch_function_t</span> func) &#123;<br><span class="hljs-comment">// 执行任务</span><br>_dispatch_function_invoke(dq, ctxt, func);<br><span class="hljs-comment">// dq-&gt;dq_running减2后判断是否等于0，是就唤醒队列</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">dispatch_atomic_sub2o</span>(dq, dq_running, <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>)) &#123;<br>_dispatch_wakeup(dq);<br>&#125;<br>&#125;<br><br>``<br>该函数作用：先通过_dispatch_function_invoke执行任务，执行完毕后，判断queue有没有激活，没有激活，则执行激活函数_dispatch_wakeup<br><br>### _dispatch_sync_f2<br>当在非global的并发queue上同步执行任务时，调用该函数，源码<br>```C++<br>_dispatch_sync_f2(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> *ctxt, <span class="hljs-type">dispatch_function_t</span> func) &#123;<br><span class="hljs-comment">// 1) ensure that this thread hasn&#x27;t enqueued anything ahead of this call</span><br><span class="hljs-comment">// 2) the queue is not suspended</span><br><br><span class="hljs-comment">// 第1步：队列中有其他任务或者队列被挂起，压入信号量开始等待</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dq-&gt;dq_items_tail) || <span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">DISPATCH_OBJECT_SUSPENDED</span>(dq)))&#123;<br><span class="hljs-keyword">return</span> _dispatch_sync_f_slow(dq, ctxt, func);<br>&#125;<br><span class="hljs-comment">// 第2步：队列没有激活，激活队列后执行任务，最终还是调用了_dispatch_sync_f_slow函数，只是多了一个_dispatch_wakeup函数</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">dispatch_atomic_add2o</span>(dq, dq_running, <span class="hljs-number">2</span>) &amp; <span class="hljs-number">1</span>)) &#123;<br><span class="hljs-keyword">return</span> _dispatch_sync_f_slow2(dq, ctxt, func);<br>&#125;<br><span class="hljs-comment">// 第3步：队列有多重队列，寻找真正的目标队列</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dq-&gt;do_targetq-&gt;do_targetq)) &#123;<br><span class="hljs-keyword">return</span> _dispatch_sync_f_recurse(dq, ctxt, func);<br>&#125;<br><span class="hljs-comment">// 第4步：队列无任务执行，调用_dispatch_sync_f_invoke执行任务。</span><br><span class="hljs-comment">// 内部调用_dispatch_function_invoke去执行任务</span><br>_dispatch_sync_f_invoke(dq, ctxt, func);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里涉及到三个函数：</p><ul><li>_dispatch_sync_f_slow：该函数内部使用wait让调用线程进入等待</li><li>_dispatch_sync_f_recurse：该函内部调用了dispatch_sync_f,寻找最终的目标队列</li><li>_dispatch_sync_f_invoke：若队列中无任务，则调用该函数执行，最终调用_dispatch_function_invoke</li></ul><p>从上面的代码可以看出，<code>在queue上执行同步任务都是顺序执行的，这种顺序和queue是串行还是并发没有关系，这些任务按照fifo的方式进入queue，每一个任务都会等待前一个的完成，并且不会开辟新线程，只会在当前线程执行</code></p><p>整理下如图所示<br><img src="/../images/image-44.png" alt="Alt text"></p><h2 id="queue中代码的异步执行：dispatch-async"><a href="#queue中代码的异步执行：dispatch-async" class="headerlink" title="queue中代码的异步执行：dispatch_async"></a>queue中代码的异步执行：dispatch_async</h2><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>串行queue：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">let</span> sQueue <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>(label: <span class="hljs-string">&quot;sQueue&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>)<br>sQueue.async &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-number">2</span>)</span>：<span class="hljs-subst">\(Thread.current)</span>&quot;</span>) &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-number">3</span>)<br>sQueue.async &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-number">4</span>)</span>：<span class="hljs-subst">\(Thread.current)</span>&quot;</span>) &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br><span class="hljs-number">5</span><br><span class="hljs-number">2</span>：<span class="hljs-operator">&lt;</span><span class="hljs-type">NSThread</span>: <span class="hljs-number">0x600000b884c0</span><span class="hljs-operator">&gt;</span>&#123;number <span class="hljs-operator">=</span> <span class="hljs-number">4</span>, name <span class="hljs-operator">=</span> (null)&#125;<br><span class="hljs-number">4</span>：<span class="hljs-operator">&lt;</span><span class="hljs-type">NSThread</span>: <span class="hljs-number">0x600000b884c0</span><span class="hljs-operator">&gt;</span>&#123;number <span class="hljs-operator">=</span> <span class="hljs-number">4</span>, name <span class="hljs-operator">=</span> (null)&#125;<br></code></pre></td></tr></table></figure><p>可见，顺序执行串行queue中的任务，并且新创建了线程</p><p>并发queue：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">let</span> cQueue <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>(label: <span class="hljs-string">&quot;cQueue&quot;</span>, attributes: [.concurrent])<br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>)<br>cQueue.async &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-number">2</span>)</span>：<span class="hljs-subst">\(Thread.current)</span>&quot;</span>) &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-number">3</span>)<br>cQueue.async &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-number">4</span>)</span>：<span class="hljs-subst">\(Thread.current)</span>&quot;</span>) &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br><span class="hljs-number">5</span><br><span class="hljs-number">4</span>：<span class="hljs-operator">&lt;</span><span class="hljs-type">NSThread</span>: <span class="hljs-number">0x600002bc69c0</span><span class="hljs-operator">&gt;</span>&#123;number <span class="hljs-operator">=</span> <span class="hljs-number">6</span>, name <span class="hljs-operator">=</span> (null)&#125;<br><span class="hljs-number">2</span>：<span class="hljs-operator">&lt;</span><span class="hljs-type">NSThread</span>: <span class="hljs-number">0x600002bc84c0</span><span class="hljs-operator">&gt;</span>&#123;number <span class="hljs-operator">=</span> <span class="hljs-number">5</span>, name <span class="hljs-operator">=</span> (null)&#125;<br></code></pre></td></tr></table></figure><p>可见，然后使用不同线程，乱序执行加入的任务</p><p>总结就是：</p><ul><li>queue的异步任务具有创建新线程的能力</li><li>非main queue的串行queue，会创建一个新线程，然后所有任务串行执行</li><li>并发queue会创建多个线程，具体数量由系统决定，任务之间无顺序</li></ul><h3 id="入口函数：dispatch-async"><a href="#入口函数：dispatch-async" class="headerlink" title="入口函数：dispatch_async"></a>入口函数：dispatch_async</h3><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dispatch_async</span><span class="hljs-params">(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> (^work)(<span class="hljs-type">void</span>))</span> </span>&#123;<br><span class="hljs-built_in">dispatch_async_f</span>(dq, _dispatch_Block_copy(work), _dispatch_call_block_and_release);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数会将任务block copy到堆，或者增加引用计数（如果block已经在堆上），调用dispatch_async_f进入执行策略</p><p>dispatch_async_f函数的试实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">dispatch_async_f</span><span class="hljs-params">(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> *ctxt, <span class="hljs-type">dispatch_function_t</span> func)</span> </span>&#123;<br><span class="hljs-type">dispatch_continuation_t</span> dc;<br><br><span class="hljs-comment">// No fastpath/slowpath hint because we simply don&#x27;t know</span><br><span class="hljs-comment">// 串行队列，执行dispatch_barrier_async_f，其实最后还是执行任务入队的操作</span><br><span class="hljs-keyword">if</span> (dq-&gt;dq_width == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">dispatch_barrier_async_f</span>(dq, ctxt, func);<br>&#125;<br><br><span class="hljs-comment">// 从线程私有数据中获取一个dispatch_continuation_t的结构体</span><br>dc = <span class="hljs-built_in">fastpath</span>(_dispatch_continuation_alloc_cacheonly());<br><span class="hljs-keyword">if</span> (!dc) &#123;<br><span class="hljs-keyword">return</span> _dispatch_async_f_slow(dq, ctxt, func);<br>&#125;<br><br>dc-&gt;do_vtable = (<span class="hljs-type">void</span> *)DISPATCH_OBJ_ASYNC_BIT;<br>dc-&gt;dc_func = func;<br>dc-&gt;dc_ctxt = ctxt;<br><br><span class="hljs-comment">// No fastpath/slowpath hint because we simply don&#x27;t know</span><br><span class="hljs-comment">// 有目标队列，调用_dispatch_async_f2函数进行转发。</span><br><span class="hljs-keyword">if</span> (dq-&gt;do_targetq) &#123;<br><span class="hljs-keyword">return</span> _dispatch_async_f2(dq, dc);<br>&#125;<br><br><span class="hljs-comment">// 全局队列直接进行入队操作</span><br>_dispatch_queue_push(dq, dc);<br>&#125;<br></code></pre></td></tr></table></figure><p>从源码可以看出，该函数主要分为三种case：</p><ul><li>串行queue：调用dispatch_barrier_async_f</li><li>并发queue：<ul><li>若有目标queue：调用_dispatch_async_f2进行转发</li><li>若是global queue：直接调用_dispatch_queue_push入queue</li></ul></li></ul><p>由于queue的异步执行策略较为复杂，下面是图示：<br><img src="/../images/image-45.png" alt="Alt text"><br>从途中可以看出，虽然分了三种情况，但是最终都要走到_dispatch_queue_push或者_dispatch_async_f2，而后者其实也是执行入队操作，所以本质就是执行_dispatch_queue_push</p><h3 id="dispatch-continuation-t结构体"><a href="#dispatch-continuation-t结构体" class="headerlink" title="dispatch_continuation_t结构体"></a>dispatch_continuation_t结构体</h3><p>这个结构体实际就是用力啊封装我们传入的block，以串行queue的case，dispatch_barrier_async_f的源码为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dispatch_barrier_async_f</span><span class="hljs-params">(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> *ctxt, <span class="hljs-type">dispatch_function_t</span> func)</span> </span>&#123;<br><span class="hljs-type">dispatch_continuation_t</span> dc;<br><span class="hljs-comment">// 从线程私有数据中获取一个dispatch_continuation_t的结构体。</span><br>dc = <span class="hljs-built_in">fastpath</span>(_dispatch_continuation_alloc_cacheonly());<br><span class="hljs-keyword">if</span> (!dc) &#123;<br><span class="hljs-comment">// _dispatch_barrier_async_f_slow内部也是在进行入队操作</span><br><span class="hljs-keyword">return</span> _dispatch_barrier_async_f_slow(dq, ctxt, func);<br>&#125;<br><br><span class="hljs-comment">// DISPATCH_OBJ_BARRIER_BIT，用于阻塞标识</span><br>dc-&gt;do_vtable = (<span class="hljs-type">void</span> *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT);<br><span class="hljs-comment">// 将_dispatch_call_block_and_release作为func方法</span><br>dc-&gt;dc_func = func;<br><span class="hljs-comment">// 将传入的block作为上下文</span><br>dc-&gt;dc_ctxt = ctxt;<br><span class="hljs-comment">// 入队操作</span><br>_dispatch_queue_push(dq, dc);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，我们的block被作为dc的context成员了。<br>注意dc的do_vtable：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 串行队列异步或者使用dispatch_barrier_async函数会有一个DISPATCH_OBJ_BARRIER_BIT的barrier标记</span><br>dc-&gt;do_vtable = (<span class="hljs-type">void</span> *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT);<br><br><span class="hljs-comment">// not barrier</span><br>dc-&gt;do_vtable = (<span class="hljs-type">void</span> *)DISPATCH_OBJ_ASYNC_BIT;<br></code></pre></td></tr></table></figure><p>可以看出，对于不同情况，dc的do_vtable的标记也不相同，在GCD内部，存在4种标记：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISPATCH_OBJ_ASYNC_BIT0x1<span class="hljs-comment">//异步</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISPATCH_OBJ_BARRIER_BIT0x2<span class="hljs-comment">//阻塞</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISPATCH_OBJ_GROUP_BIT0x4<span class="hljs-comment">//组</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISPATCH_OBJ_SYNC_SLOW_BIT0x8<span class="hljs-comment">//同步慢</span></span><br></code></pre></td></tr></table></figure><p>通过DISPATCH_OBJ_BARRIER_BIT标记，GCD知道需要使用阻塞特性。</p><h3 id="任务入queue：-dispatch-queue-push"><a href="#任务入queue：-dispatch-queue-push" class="headerlink" title="任务入queue：_dispatch_queue_push"></a>任务入queue：_dispatch_queue_push</h3><p>它实际是个宏定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _dispatch_queue_push(x, y) _dispatch_queue_push_list((x), (y), (y))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _dispatch_queue_push_list _dispatch_trace_queue_push_list</span><br></code></pre></td></tr></table></figure><p>_dispatch_trace_queue_push_list源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">void</span> _dispatch_trace_queue_push_list(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">dispatch_object_t</span> _head, <span class="hljs-type">dispatch_object_t</span> _tail) &#123;<br><span class="hljs-comment">// 是否可以入队</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">DISPATCH_QUEUE_PUSH_ENABLED</span>())) &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_object_s</span> *dou = _head._do;<br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-comment">// 主要是对dispatch_continuation_s结构体的处理，确保后面的使用。</span><br>_dispatch_trace_continuation(dq, dou, DISPATCH_QUEUE_PUSH);<br>&#125; <span class="hljs-keyword">while</span> (dou != _tail._do &amp;&amp; (dou = dou-&gt;do_next));<br>&#125;<br><br>_dispatch_queue_push_list(dq, _head, _tail);<br>&#125;<br></code></pre></td></tr></table></figure><p>_dispatch_queue_push_list的源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">void</span> _dispatch_queue_push_list(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">dispatch_object_t</span> _head, <span class="hljs-type">dispatch_object_t</span> _tail) &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_object_s</span> *prev, *head = _head._do, *tail = _tail._do;<br><br>tail-&gt;do_next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">dispatch_atomic_store_barrier</span>();<br><span class="hljs-comment">// dispatch_atomic_xchg2o实质是调用((typeof(*(p)))__sync_swap((p), (n)))，它的定义是将p设为n并返回p操作之前的值。</span><br><span class="hljs-comment">// dispatch_atomic_xchg2o(dq, dq_items_tail, tail)相当于dq-&gt;dq_items_tail = tail，重新设置了队列的尾指针</span><br>prev = <span class="hljs-built_in">fastpath</span>(<span class="hljs-built_in">dispatch_atomic_xchg2o</span>(dq, dq_items_tail, tail));<br><span class="hljs-keyword">if</span> (prev) &#123;<br><span class="hljs-comment">// if we crash here with a value less than 0x1000, then we are at a</span><br><span class="hljs-comment">// known bug in client code for example, see _dispatch_queue_dispose</span><br><span class="hljs-comment">// or _dispatch_atfork_child</span><br><span class="hljs-comment">// prev是原先的队尾，如果队列中有其他的元素，就将压入的对象加在队列的尾部。</span><br>prev-&gt;do_next = head;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 如果队列为空</span><br>_dispatch_queue_push_list_slow(dq, head);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>_dispatch_queue_push_list_slow的源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">_dispatch_queue_push_list_slow(<span class="hljs-type">dispatch_queue_t</span> dq,<br><span class="hljs-keyword">struct</span> dispatch_object_s *obj)<br>&#123;<br><span class="hljs-comment">//dq-&gt;dq_items_head设置为dc，然后唤醒这个队列。因为此时队列为空，没有任务在执行，处于休眠状态，所以需要唤醒</span><br>_dispatch_retain(dq);<br>dq-&gt;dq_items_head = obj;<br>_dispatch_wakeup(dq);<br>_dispatch_release(dq);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="唤醒queue：-dispatch-wakeup"><a href="#唤醒queue：-dispatch-wakeup" class="headerlink" title="唤醒queue：_dispatch_wakeup"></a>唤醒queue：_dispatch_wakeup</h3><p>无论是同步执行还是异步执行，都使用该函数，用于唤醒当前queue，其源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">dispatch_queue_t</span> _dispatch_wakeup(<span class="hljs-type">dispatch_object_t</span> dou) &#123;<br><span class="hljs-type">dispatch_queue_t</span> tq;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">DISPATCH_OBJECT_SUSPENDED</span>(dou._do))) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dx_probe</span>(dou._do) &amp;&amp; !dou._dq-&gt;dq_items_tail) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// 如果dou._do-&gt;do_suspend_cnt == 0，返回YES,否则返回NO；</span><br><span class="hljs-comment">// 同时将DISPATCH_OBJECT_SUSPEND_LOCK赋值给dou._do-&gt;do_suspend_cnt</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dispatch_atomic_cmpxchg2o</span>(dou._do, do_suspend_cnt, <span class="hljs-number">0</span>, DISPATCH_OBJECT_SUSPEND_LOCK)) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_COCOA_COMPAT</span><br><span class="hljs-comment">// 主队列的任务调用_dispatch_queue_wakeup_main唤醒主队列</span><br><span class="hljs-keyword">if</span> (dou._dq == &amp;_dispatch_main_q) &#123;<br>_dispatch_queue_wakeup_main();<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// 放到目标队列中，重新走_dispatch_queue_push方法</span><br>_dispatch_retain(dou._do);<br>tq = dou._do-&gt;do_targetq;<br>_dispatch_queue_push(tq, dou._do);<br><br><span class="hljs-keyword">return</span> tq;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面我们看到了main queue和自定义queue的情况，但是没有global queue，因为global queue的唤醒比较隐晦，针对global queue的dx_probe(dou._do)调用如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> dx_probe(x) (x)-&gt;do_vtable-&gt;do_probe(x)</span><br><br><span class="hljs-comment">// dx_probe(dou._do) 相当于 (dou.do)-&gt;do_vtable-&gt;do_probe(dou.do)</span><br><br><span class="hljs-comment">// 全局队列的do_vtable：_dispatch_queue_root_vtable</span><br><br><span class="hljs-comment">// _dispatch_queue_root_vtable的定义</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_vtable_s</span> _dispatch_queue_root_vtable = &#123;<br>.do_type = DISPATCH_QUEUE_GLOBAL_TYPE,<br>.do_kind = <span class="hljs-string">&quot;global-queue&quot;</span>,<br>.do_debug = dispatch_queue_debug,<br>.do_probe = _dispatch_queue_wakeup_global,<br>&#125;;<br><br><span class="hljs-comment">// 全局队列：</span><br><span class="hljs-comment">// globalQueue -&gt; _dispatch_queue_root_vtable -&gt; _dispatch_queue_wakeup_global</span><br></code></pre></td></tr></table></figure><p>从上面可以看出，唤醒分为4种case：</p><ul><li>main queue：使用_dispatch_queue_wakeup_main</li><li>global queue：使用_dispatch_queue_wakeup_global</li><li>manager queue：调用_dispatch_mgr_wakeup，主要为dispatch_source服务</li><li>其他queue：向target queue压入该queue，继续做入queue操作</li></ul><h3 id="dispatch-queue-wakeup-main"><a href="#dispatch-queue-wakeup-main" class="headerlink" title="_dispatch_queue_wakeup_main"></a>_dispatch_queue_wakeup_main</h3><p>用于唤醒主线程的runloop，源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">void</span> _dispatch_queue_wakeup_main(<span class="hljs-type">void</span>) &#123;<br><span class="hljs-type">kern_return_t</span> kr;<br><span class="hljs-comment">// 主要看_dispatch_main_q_port_init的实现</span><br><span class="hljs-built_in">dispatch_once_f</span>(&amp;_dispatch_main_q_port_pred, <span class="hljs-literal">NULL</span>,<br>_dispatch_main_q_port_init);<br><span class="hljs-comment">// 关于主线程的唤醒主要靠mach_port和在runloop中注册相对应的source1</span><br>    <span class="hljs-comment">// 但是该函数的实现没有公开</span><br>kr = _dispatch_send_wakeup_main_thread(main_q_port, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">switch</span> (kr) &#123;<br><span class="hljs-keyword">case</span> MACH_SEND_TIMEOUT:<br><span class="hljs-keyword">case</span> MACH_SEND_TIMED_OUT:<br><span class="hljs-keyword">case</span> MACH_SEND_INVALID_DEST:<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_assume_zero</span>(kr);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>_dispatch_safe_fork = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// _dispatch_main_q_port_init的实现，RunLoop的唤醒需要依赖于mach port</span><br><span class="hljs-type">void</span> _dispatch_main_q_port_init(<span class="hljs-type">void</span> *ctxt DISPATCH_UNUSED) &#123;<br><span class="hljs-type">kern_return_t</span> kr;<br><br>kr = <span class="hljs-built_in">mach_port_allocate</span>(<span class="hljs-built_in">mach_task_self</span>(), MACH_PORT_RIGHT_RECEIVE,<br>&amp;main_q_port);<br><span class="hljs-built_in">DISPATCH_VERIFY_MIG</span>(kr);<br>(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_assume_zero</span>(kr);<br>kr = <span class="hljs-built_in">mach_port_insert_right</span>(<span class="hljs-built_in">mach_task_self</span>(), main_q_port, main_q_port,<br>MACH_MSG_TYPE_MAKE_SEND);<br><span class="hljs-built_in">DISPATCH_VERIFY_MIG</span>(kr);<br>(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_assume_zero</span>(kr);<br><br>_dispatch_program_is_probably_callback_driven = <span class="hljs-literal">true</span>;<br>_dispatch_safe_fork = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，唤醒主线程就是通过mach port向主线程发送消息，从而进一步唤醒RunLoop。所以我们说RunLoop RunLoop可以看做是使用GCD的API的，但是对于main queue，GCD和RunLoop紧密合作。</p><h3 id="dispatch-queue-wakeup-global"><a href="#dispatch-queue-wakeup-global" class="headerlink" title="_dispatch_queue_wakeup_global"></a>_dispatch_queue_wakeup_global</h3><p>源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-type">bool</span><br>_dispatch_queue_wakeup_global(<span class="hljs-type">dispatch_queue_t</span> dq) &#123;<br><span class="hljs-type">static</span> <span class="hljs-type">dispatch_once_t</span> pred;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_root_queue_context_s</span> *qc = dq-&gt;do_ctxt;<br><span class="hljs-type">int</span> r;<br><br><span class="hljs-keyword">if</span> (!dq-&gt;dq_items_tail) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>_dispatch_safe_fork = <span class="hljs-literal">false</span>;<br><br><span class="hljs-built_in">dispatch_debug_queue</span>(dq, __PRETTY_FUNCTION__);<br><br><span class="hljs-comment">// 上下文以及根队列的初始化，根队列内部会初始化线程池</span><br><span class="hljs-built_in">dispatch_once_f</span>(&amp;pred, <span class="hljs-literal">NULL</span>, _dispatch_root_queues_init);<br><br><span class="hljs-comment">// _dispatch_queue_wakeup_global支持两种实现的任务唤醒pthread_workqueue和thread pool</span><br><span class="hljs-comment">//  1.支持pthread_workqueue</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> HAVE_PTHREAD_WORKQUEUES</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br><span class="hljs-comment">// 如果队列的dgq_kworkqueue存在，则调用pthread_workqueue_additem_np函数</span><br><span class="hljs-comment">// dgq_kworkqueue是一个用于创建内核线程的接口，通过它创建的内核线程来执行内核其他模块排列到队列里的工作。</span><br><span class="hljs-comment">// 不同优先级的dispatch queue对应着对应优先级的workqueue。</span><br><span class="hljs-comment">// _dispatch_root_queues_init初始化的时候，使用pthread_workqueue_create_np创建pthread_workqueue</span><br><span class="hljs-keyword">if</span> (qc-&gt;dgq_kworkqueue)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">dispatch_atomic_cmpxchg2o</span>(qc, dgq_pending, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br><span class="hljs-type">pthread_workitem_handle_t</span> wh;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> gen_cnt;<br>_dispatch_debug(<span class="hljs-string">&quot;requesting new worker thread&quot;</span>);<br><span class="hljs-comment">// 该函数使用workq_kernreturn系统调用，通知workqueue增加应当执行的项目。</span><br><span class="hljs-comment">// 根据该通知，XNU内核基于系统状态判断是否要生成线程，如果是overcommit优先级的队列，workqueue则始终生成线程。</span><br>r = <span class="hljs-built_in">pthread_workqueue_additem_np</span>(qc-&gt;dgq_kworkqueue, _dispatch_worker_thread2, dq, &amp;wh, &amp;gen_cnt);<br>(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_assume_zero</span>(r);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>_dispatch_debug(<span class="hljs-string">&quot;work thread request still pending on global &quot;</span><br><span class="hljs-string">&quot;queue: %p&quot;</span>, dq);<br>&#125;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// HAVE_PTHREAD_WORKQUEUES</span></span><br><span class="hljs-comment">// 2. 支持thread pool</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br><span class="hljs-comment">// 通过发送一个信号量使线程保活</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">dispatch_semaphore_signal</span>(qc-&gt;dgq_thread_mediator)) &#123;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><br><span class="hljs-comment">// 计算线程池可用长度，如果线程池已满则跳转到out即return false，否则执行线程池-1操作</span><br><span class="hljs-type">pthread_t</span> pthr;<br><span class="hljs-type">int</span> t_count;<br><span class="hljs-keyword">do</span> &#123;<br>t_count = qc-&gt;dgq_thread_pool_size;<br><span class="hljs-keyword">if</span> (!t_count) &#123;<br>_dispatch_debug(<span class="hljs-string">&quot;The thread pool is full: %p&quot;</span>, dq);<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">dispatch_atomic_cmpxchg2o</span>(qc, dgq_thread_pool_size, t_count, t_count - <span class="hljs-number">1</span>));<br><span class="hljs-comment">// qc-&gt;dgq_thread_pool_size的值与t_counts是否相等，是就减1，并返回ture</span><br><br><span class="hljs-comment">// 这里说明线程池不够用了，使用pthread创建一个线程，</span><br><span class="hljs-comment">// 并执行_dispatch_worker_thread,_dispatch_worker_thread最终会调用到_dispatch_worker_thread2</span><br><span class="hljs-keyword">while</span> ((r = <span class="hljs-built_in">pthread_create</span>(&amp;pthr, <span class="hljs-literal">NULL</span>, _dispatch_worker_thread, dq))) &#123;<br><span class="hljs-keyword">if</span> (r != EAGAIN) &#123;<br>(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_assume_zero</span>(r);<br>&#125;<br><span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// 保证pthr能够被回收</span><br>r = <span class="hljs-built_in">pthread_detach</span>(pthr);<br>(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_assume_zero</span>(r);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// DISPATCH_ENABLE_THREAD_POOL</span></span><br><br>out:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="queue的任务调度"><a href="#queue的任务调度" class="headerlink" title="queue的任务调度"></a>queue的任务调度</h2><h3 id="main-queue的任务调度"><a href="#main-queue的任务调度" class="headerlink" title="main queue的任务调度"></a>main queue的任务调度</h3><p>在上面的分析中我们知道，唤醒main queue会调用_dispatch_send_wakeup_main_thread，但是该函数没有公开实现。通过函数调用栈我们知道，main queue的任务调度最终又回到了GCD之中的_dispatch_main_queue_callback_4CF。唤醒主线程，RunLoop执行__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__，接着调用了GCD执行_dispatch_main_queue_callback_4CF，其源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 处理主队列任务</span><br><span class="hljs-type">void</span> _dispatch_main_queue_callback_4CF(<span class="hljs-type">mach_msg_header_t</span> *msg DISPATCH_UNUSED) &#123;<br><span class="hljs-keyword">if</span> (main_q_is_draining) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 正在处理任务，设置状态为true</span><br>_dispatch_queue_set_mainq_drain_state(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 调度处理任务</span><br>_dispatch_main_queue_drain();<br><span class="hljs-comment">// 处理任务完成任务，恢复状态为false</span><br>_dispatch_queue_set_mainq_drain_state(<span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>main queue是串行queue，拿到本次要执行的dc，执行任务。对于之后入队的block，则放在下一轮的main queue唤醒中执行</p><p>如果RunLoop还未休眠，并且main queue中存在等待执行的任务，则RunLoop会在处理完这些任务之后再进入休眠。否则，GCD唤醒主线程，进而唤醒RunLoop，再通过GCD中的函数取出来执行，直到执行完毕再进入休眠。</p><p>ps，再看下gcd唤醒主线程后的调用栈：<br>主线程唤醒-&gt;执行runloop的__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__-&gt;调用GCD的_dispatch_main_queue_callback_4CF-&gt;调用之前封装dc的_dispatch_call_block_and_release的函数-&gt;执行block，注意这里_dispatch_call_block_and_release函数，他是之前封装dc时传进来的</p><p>注意：无论主线程是否进入睡眠，调用栈都是一样的，区别在于是否进入beforewaiting状态<br>注意：app首次启动时，即使没有beforewaiting，也会提交渲染，不会等待runloop时才提交，但后续的渲染都需要在beforewaiting时操作，这也是为什么一般在下次runloop时才能获取准确宽高的原因！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++">thread #<span class="hljs-number">1</span>, queue = <span class="hljs-string">&#x27;com.apple.main-thread&#x27;</span>, stop reason = breakpoint <span class="hljs-number">2.1</span><br>    frame #<span class="hljs-number">0</span>: <span class="hljs-number">0x000000010740f897</span> TestXX`__29-[ViewController viewDidLoad]_block_invoke(.block_descriptor=<span class="hljs-number">0x00006000035faca0</span>) at ViewController.m:<span class="hljs-number">81</span>:<span class="hljs-number">13</span><br>    frame #<span class="hljs-number">1</span>: <span class="hljs-number">0x00000001076847ec</span> libdispatch.dylib`_dispatch_call_block_and_release + <span class="hljs-number">12</span><br>    frame #<span class="hljs-number">2</span>: <span class="hljs-number">0x00000001076859c8</span> libdispatch.dylib`_dispatch_client_callout + <span class="hljs-number">8</span><br>  * frame #<span class="hljs-number">3</span>: <span class="hljs-number">0x0000000107693e75</span> libdispatch.dylib`_dispatch_main_queue_callback_4CF + <span class="hljs-number">1152</span><br>    frame #<span class="hljs-number">4</span>: <span class="hljs-number">0x00007fff2038fdbb</span> CoreFoundation`__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + <span class="hljs-number">9</span><br>    frame #<span class="hljs-number">5</span>: <span class="hljs-number">0x00007fff2038a63e</span> CoreFoundation`__CFRunLoopRun + <span class="hljs-number">2685</span><br>    frame #<span class="hljs-number">6</span>: <span class="hljs-number">0x00007fff203896d6</span> CoreFoundation`CFRunLoopRunSpecific + <span class="hljs-number">567</span><br>    frame #<span class="hljs-number">7</span>: <span class="hljs-number">0x00007fff2c257db3</span> GraphicsServices`GSEventRunModal + <span class="hljs-number">139</span><br>    frame #<span class="hljs-number">8</span>: <span class="hljs-number">0x00007fff24696cf7</span> UIKitCore`-[UIApplication _run] + <span class="hljs-number">912</span><br>    frame #<span class="hljs-number">9</span>: <span class="hljs-number">0x00007fff2469bba8</span> UIKitCore`UIApplicationMain + <span class="hljs-number">101</span><br>    frame #<span class="hljs-number">10</span>: <span class="hljs-number">0x000000010740feb2</span> TestXX`<span class="hljs-built_in">main</span>(argc=<span class="hljs-number">1</span>, argv=<span class="hljs-number">0x00007ffee87efea8</span>) at main.m:<span class="hljs-number">17</span>:<span class="hljs-number">12</span><br>    frame #<span class="hljs-number">11</span>: <span class="hljs-number">0x00007fff2025a3e9</span> libdyld.dylib`start + <span class="hljs-number">1</span><br>    frame #<span class="hljs-number">12</span>: <span class="hljs-number">0x00007fff2025a3e9</span> libdyld.dylib`start + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="global-queue的任务调度-dispatch-worker-thread2"><a href="#global-queue的任务调度-dispatch-worker-thread2" class="headerlink" title="global queue的任务调度_dispatch_worker_thread2"></a>global queue的任务调度_dispatch_worker_thread2</h3><p>global queue通过_dispatch_queue_wakeup_global函数，将任务入queue，让后调用_dispatch_worker_thread2进行处理任务</p><p>在_dispatch_worker_thread2中有两个函数比较重要：</p><ul><li>_dispatch_queue_concurrent_drain_one</li><li>_dispatch_continuation_pop</li></ul><h4 id="dispatch-queue-concurrent-drain-one"><a href="#dispatch-queue-concurrent-drain-one" class="headerlink" title="_dispatch_queue_concurrent_drain_one"></a>_dispatch_queue_concurrent_drain_one</h4><p>该函数的重要作用：</p><ul><li>多线程下的边界处理</li><li>获取出队的dc</li><li>再次唤醒global queue<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_object_s</span> *<br>_dispatch_queue_concurrent_drain_one(<span class="hljs-type">dispatch_queue_t</span> dq) &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_object_s</span> *head, *next, *<span class="hljs-type">const</span> mediator = (<span class="hljs-type">void</span> *)~<span class="hljs-number">0ul</span>;<br><br><span class="hljs-comment">// The mediator value acts both as a &quot;lock&quot; and a signal</span><br>head = <span class="hljs-built_in">dispatch_atomic_xchg2o</span>(dq, dq_items_head, mediator);<br><br><span class="hljs-comment">// 1. 检查队列是否为空，是返回NULL</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(head == <span class="hljs-literal">NULL</span>)) &#123;<br>(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_atomic_cmpxchg2o</span>(dq, dq_items_head, mediator, <span class="hljs-literal">NULL</span>);<br>_dispatch_debug(<span class="hljs-string">&quot;no work on global work queue&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(head == mediator)) &#123;<br><span class="hljs-comment">// 该线程在现线程竞争中失去了对队列的拥有权，这意味着libdispatch的效率很糟糕，</span><br><span class="hljs-comment">// 这种情况意味着在线程池中有太多的线程，这个时候应该创建一个pengding线程，</span><br><span class="hljs-comment">// 然后退出该线程，内核会在负载减弱的时候创建一个新的线程</span><br>_dispatch_debug(<span class="hljs-string">&quot;Contention on queue: %p&quot;</span>, dq);<br>_dispatch_queue_wakeup_global(dq);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_PERF_MON</span><br><span class="hljs-built_in">dispatch_atomic_inc</span>(&amp;_dispatch_bad_ratio);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// 在返回之前将head指针的do_next保存下来，如果next为NULL，这意味着item是最后一个</span><br>next = <span class="hljs-built_in">fastpath</span>(head-&gt;do_next);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(!next)) &#123;<br>dq-&gt;dq_items_head = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">dispatch_atomic_cmpxchg2o</span>(dq, dq_items_tail, head, <span class="hljs-literal">NULL</span>)) &#123;<br><span class="hljs-comment">// head和tail头尾指针均为空</span><br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><br><span class="hljs-comment">// 此时一定有item，该线程不会等待太久。</span><br><span class="hljs-keyword">while</span> (!(next = head-&gt;do_next)) &#123;<br>_dispatch_hardware_pause();<br>&#125;<br>&#125;<br><br>dq-&gt;dq_items_head = next;<br><span class="hljs-comment">// 再次唤醒全局队列</span><br>_dispatch_queue_wakeup_global(dq);<br>out:<br><span class="hljs-comment">// 返回需要处理的dc</span><br><span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>这里再次调用_dispatch_queue_wakeup_global,我们知道，并发queue中的dc执行是并发的，所以每次出队dc后检查下global queue，是否还有dc在queue中。如果有，在再次通知需要再创建一个work queue处理queue中剩余的dc，然后重复上面的步骤，类似递归。当多个work queue同时处理多个dc的时候，就是异步效果。</li></ul><h4 id="dispatch-continuation-pop"><a href="#dispatch-continuation-pop" class="headerlink" title="_dispatch_continuation_pop"></a>_dispatch_continuation_pop</h4><p>该函数实现了对任务处理，这些任务可能是异步任务、group任务、barrier任务甚至queue。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span><br>_dispatch_continuation_pop(<span class="hljs-type">dispatch_object_t</span> dou) &#123;<br><span class="hljs-type">dispatch_continuation_t</span> dc = dou._dc;<br><span class="hljs-type">dispatch_group_t</span> dg;<br><br>_dispatch_trace_continuation_pop(_dispatch_queue_get_current(), dou);<br><span class="hljs-comment">// 检测是不是队列，如果是，就进入_dispatch_queue_invoke处理队列</span><br><span class="hljs-comment">// dispatch_barrier_async的任务会进入以下分支，以保证barrier任务和其他任务隔离，</span><br><span class="hljs-comment">// 并通过dispath_semaphore_t实现通知barrier任务执行</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DISPATCH_OBJ_IS_VTABLE</span>(dou._do)) &#123;<br><span class="hljs-keyword">return</span> _dispatch_queue_invoke(dou._dq);<br>&#125;<br><br><span class="hljs-comment">// Add the item back to the cache before calling the function. This</span><br><span class="hljs-comment">// allows the &#x27;hot&#x27; continuation to be used for a quick callback.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The ccache version is per-thread.</span><br><span class="hljs-comment">// Therefore, the object has not been reused yet.</span><br><span class="hljs-comment">// This generates better assembly.</span><br><span class="hljs-comment">// 是否是异步任务</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>)dc-&gt;do_vtable &amp; DISPATCH_OBJ_ASYNC_BIT) &#123;<br>_dispatch_continuation_free(dc);<br>&#125;<br><br><span class="hljs-comment">// 判断是否是group任务</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>)dc-&gt;do_vtable &amp; DISPATCH_OBJ_GROUP_BIT) &#123;<br>dg = dc-&gt;dc_group;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>dg = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// 是任务封装的dispatch_continuation_t结构体（dc），直接执行任务。</span><br><span class="hljs-comment">// 这也是异步的block被调用的时机</span><br>_dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);<br><span class="hljs-keyword">if</span> (dg) &#123; <span class="hljs-comment">// 若是group中的任务，由于group的任务在执行时会enter，那么group任务执行完毕后也要成对执行leave</span><br><span class="hljs-built_in">dispatch_group_leave</span>(dg);<br>_dispatch_release(dg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="dispatch-queue-invoke"><a href="#dispatch-queue-invoke" class="headerlink" title="_dispatch_queue_invoke"></a>_dispatch_queue_invoke</h4><p>该函数用于异步处理任务，并且任务本身是queue时调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">void</span><br>_dispatch_queue_invoke(<span class="hljs-type">dispatch_queue_t</span> dq) &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">DISPATCH_OBJECT_SUSPENDED</span>(dq)) &amp;&amp;<br><span class="hljs-built_in">fastpath</span>(<span class="hljs-built_in">dispatch_atomic_cmpxchg2o</span>(dq, dq_running, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>))) &#123;<br><span class="hljs-built_in">dispatch_atomic_acquire_barrier</span>();<br><span class="hljs-type">dispatch_queue_t</span> otq = dq-&gt;do_targetq, tq = <span class="hljs-literal">NULL</span>;<br>_dispatch_queue_drain(dq);<br><span class="hljs-keyword">if</span> (dq-&gt;do_vtable-&gt;do_invoke) &#123;<br><span class="hljs-comment">// Assume that object invoke checks it is executing on correct queue</span><br>tq = <span class="hljs-built_in">dx_invoke</span>(dq);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(otq != dq-&gt;do_targetq)) &#123;<br><span class="hljs-comment">// An item on the queue changed the target queue</span><br>tq = dq-&gt;do_targetq;<br>&#125;<br><span class="hljs-comment">// We do not need to check the result.</span><br><span class="hljs-comment">// When the suspend-count lock is dropped, then the check will happen.</span><br><span class="hljs-built_in">dispatch_atomic_release_barrier</span>();<br><span class="hljs-comment">//dq_running减1，因为任务要么被直接执行了，要么被压到target队列了</span><br>(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_atomic_dec2o</span>(dq, dq_running);<br><span class="hljs-keyword">if</span> (tq) &#123;<br><span class="hljs-keyword">return</span> _dispatch_queue_push(tq, dq);<br>&#125;<br>&#125;<br><br>dq-&gt;do_next = DISPATCH_OBJECT_LISTLESS;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dispatch_atomic_sub2o</span>(dq, do_suspend_cnt,<br>DISPATCH_OBJECT_SUSPEND_LOCK)) &#123;<br><span class="hljs-comment">// 队列处于空闲状态，需要唤醒</span><br><span class="hljs-keyword">if</span> (dq-&gt;dq_running == <span class="hljs-number">0</span>) &#123;<br>_dispatch_wakeup(dq); <span class="hljs-comment">// verify that the queue is idle</span><br>&#125;<br>&#125;<br><span class="hljs-comment">// 释放队列</span><br>_dispatch_release(dq); <span class="hljs-comment">// added when the queue is put on the list</span><br>&#125;<br></code></pre></td></tr></table></figure><p>整理下上述流程<br><img src="/../images/image-46.png" alt="Alt text"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>queue和线程是多对1关系，一个线程上可以执行不同queue的任务，即使是主线程也如此，即主线程不仅能执行main queue的任务，也能执行其他queue的任务</li><li>queue操作与开启线程的关系<ul><li>串行queue+sync：任务在当前线程执行，并且等待之前任务执行，并且阻塞当前线程</li><li>串行queue+async：任务在新线程执行，不阻塞当前线程，任务在新线程上串行执行</li><li>并发queue+sync：任务在当前线程执行，阻塞当前线程</li><li>并发queue+async：开启多个线程，任务在新线程上执行，数量由系统决定，任务无序执行</li><li>主线程+main queue+sync：死锁，因为sync阻塞当前线程，主线程进入wait，此时调用sync的操作永远无法执行完毕，因为主线程永远不会被唤醒，从而死锁</li><li>main queue+async：任务在主线程串行执行</li></ul></li><li>queue的sync不具备开启线程能力，async才能开启新线程，串行&amp;并发决定了处理线程是否有多个</li><li>dispatch_queue通过struct和链表，实现为fifo的队列，无论串行queue还是并发queue，在调度时都是按顺序获取，主要区别在于：执行的顺序&amp;开启线程的数量</li><li>dispatch_sync:在当前线程执行，利用信号量实现串行</li><li>dispatch_async:<ul><li>若是main queue，则唤醒后执行runloop，然后调用gcd处理</li><li>若是其他queue：由线程池处理</li></ul></li><li>传递的block不是直接添加到queue上，而是封装为dispatch_continuation。dc包含了block还有上下文信息。queue会将dc添加链表中。无论queue是什么类型，最终的target都是global queue。在global queue执行block时，gcd从global queue取出dc，调用pthread_workqueue_additem_np，将该global queue自身，符合其优先级的workqueue和dc的回调函数进行传递。pthread_workqueue_additem_np函数使用workq_kernreturn系统调用，通知workqueue增加执行项目。而根据该通知，XNU kernel基于系统状态判断是否要生成线程，如果是overcommit的global queue，则始终生成线程。workqueue的新城执行pthread_workqueue函数，该函数调用gcd传递的回到函数，该函数中最终执行封装到dc中的block</li><li>gcd死锁是queue导致而不是线程导致，是因为_dispatch_barrier_sync_f_slow使用了线程对应的信号量，并进行wait，从而让线程等待，而又没有时机唤醒</li><li>关于barrier函数：<ul><li>dispatch_barrier_async的queue必须是由DISPATCH_QUEUE_CONCURRENT创建的queue</li><li>如果使用global queue，则表现的和dispatch_async一样</li><li>原因：<ul><li>若是global queue，则唤醒queue时执行_dispatch_queue_wakeup_global，则和dispatch_async一样</li><li>若是自定义queue：_dispatch_continuation_pop会执行dispatch_queue_invoke，在while循环中依次取出任务并调用_dispatch_continuation_redirect，使得任务并发执行；遇到DISPATCH_OBJ_BARRIER_BIT标记时，修改do_suspend_cnt保证后续while循环时直接go out。当barrier block的任务执行完，_dispatch_queue_class_invoke将do_suspend_cnt重置，允许barrier之后的任务执行</li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>GCD</tag>
      
      <tag>Dispatch Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再谈OC Block原理</title>
    <link href="/2024/02/20/think-about-oc-block-again/"/>
    <url>/2024/02/20/think-about-oc-block-again/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前已经学习过OC Block的底层原理，这里再次巩固下</p><h2 id="Block的实质"><a href="#Block的实质" class="headerlink" title="Block的实质"></a>Block的实质</h2><p>如下是一个基础的Block使用</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * argv[]) &#123;<br>    <span class="hljs-type">void</span> (^testBlock)(<span class="hljs-type">void</span>) = ^&#123;<br>        printf(<span class="hljs-string">&quot;asddasd&quot;</span>);<br>    &#125;;<br>    testBlock();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过如下xcrun指令，可以将其翻译为C++代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">xcrun -sdk iphoneos clang -<span class="hljs-built_in">arch</span> arm64 -rewrite-objc main.m<br></code></pre></td></tr></table></figure><p>翻译后代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span> </span>&#123;<br>    <span class="hljs-built_in">void</span> (*testBlock)(<span class="hljs-type">void</span>) = ((<span class="hljs-built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));<br><br>    ((<span class="hljs-built_in">void</span> (*)(__block_impl *))((__block_impl *)testBlock)-&gt;FuncPtr)((__block_impl *)testBlock);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，最后转换成了对于函数指针的调用。可以看到，我们定义的testBlock转换为了<code>&amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA)</code>,调用时，转换了testBlock-&gt;FuncPtr(testBlock)。<br><code>__main_block_impl_0</code>是个struct，相关定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__block_impl</span> &#123;<br>    <span class="hljs-type">void</span> *isa; <span class="hljs-comment">// isa是OC对象特有的标志</span><br>    <span class="hljs-type">int</span> Flags;<br>    <span class="hljs-type">int</span> Reserved;<br>    <span class="hljs-type">void</span> *FuncPtr; <span class="hljs-comment">// 该指针指向block执行函数的地址</span><br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_desc_0</span> &#123;<br>    <span class="hljs-type">size_t</span> reserved;   <span class="hljs-comment">// 预留的字段</span><br>    <span class="hljs-type">size_t</span> Block_size; <span class="hljs-comment">// block所占内存大小</span><br>&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> __main_block_impl_0)&#125;;<br><br><span class="hljs-comment">// __main_block_impl_0是一个C++结构体可以声明函数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_impl_0</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__block_impl</span> impl;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_desc_0</span>* Desc;<br>    <span class="hljs-comment">// 没有返回类型，与结构体同名的函数，这样的函数称为构造函数</span><br>    __main_block_impl_0(<span class="hljs-type">void</span> *fp, <span class="hljs-keyword">struct</span> __main_block_desc_0 *desc, <span class="hljs-type">int</span> flags=<span class="hljs-number">0</span>) &#123;<br>        impl.isa = &amp;_NSConcreteStackBlock; <span class="hljs-comment">// 初始化__block_impl结构体的isa成员变量</span><br>        impl.Flags = flags;<br>        impl.FuncPtr = fp; <span class="hljs-comment">// fp就是__main_block_func_0函数</span><br>        Desc = desc;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 该函数封装了block的执行代码</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __main_block_func_0(<span class="hljs-keyword">struct</span> __main_block_impl_0 *__cself) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;asddasd&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>__main_block_impl_0</code>有两个成员，分别是<code>__block_impl impl</code>和<code>__main_block_desc_0* Desc</code>。还有一个构造函数。当然__block_impl和__main_block_desc_0也是两个struct，上面已经有注释了，这里不再赘述。看下该struct的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">__main_block_impl_0(<span class="hljs-type">void</span> *fp, <span class="hljs-keyword">struct</span> __main_block_desc_0 *desc, <span class="hljs-type">int</span> flags=<span class="hljs-number">0</span>) &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，该struct需要传入函数指针fp和desc。而fp就是<code>__main_block_func_0</code>。isa的初始值_NSConcreteStackBlock，所以既然存在isa，Block也可以看做是OC对象，只不过其class_t是_NSConcreteStackBlock。</p><p>然后看函数调用，block的调用会被转换为对函数指针的调用，即<code>__main_block_func_0</code>的调用。</p><p>总结：<code>Block的本质可以看做是OC对象（有isa），Block的调用就是函数指针的调用</code>。</p><h2 id="Block对自动变量值的捕获"><a href="#Block对自动变量值的捕获" class="headerlink" title="Block对自动变量值的捕获"></a>Block对自动变量值的捕获</h2><p>在之前，我们知道所谓捕获自动变量，实际上变量将会被转换为struct，并保存到Block对应的struct中。不同类型的变量的捕获过程会略有区别，如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 静态全局变量</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> globalStaticValue = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 全局变量</span><br><span class="hljs-type">int</span> globalValue = <span class="hljs-number">2</span>;<br><br><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[]) &#123;<br>    <span class="hljs-comment">// 局部变量</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;<br>    <br>    <span class="hljs-comment">// 静态局部变量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> b = <span class="hljs-number">4</span>;<br>    <br>    <span class="hljs-type">void</span> (^testBlock)(<span class="hljs-type">void</span>) = ^&#123;<br>        printf(<span class="hljs-string">&quot;%d&quot;</span>, globalStaticValue);<br>        printf(<span class="hljs-string">&quot;%d&quot;</span>, globalValue);<br>        printf(<span class="hljs-string">&quot;%d&quot;</span>, a);<br>        printf(<span class="hljs-string">&quot;%d&quot;</span>, b);<br>    &#125;;<br>    <br>    testBlock();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们仍然将其转换为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 静态全局变量</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> globalStaticValue = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 全局变量</span><br><span class="hljs-type">int</span> globalValue = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_impl_0</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__block_impl</span> impl;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_desc_0</span>* Desc;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> *b;<br>    __main_block_impl_0(<span class="hljs-type">void</span> *fp, <span class="hljs-keyword">struct</span> __main_block_desc_0 *desc, <span class="hljs-type">int</span> _a, <span class="hljs-type">int</span> *_b, <span class="hljs-type">int</span> flags=<span class="hljs-number">0</span>) : <span class="hljs-built_in">a</span>(_a), <span class="hljs-built_in">b</span>(_b) &#123;<br>        impl.isa = &amp;_NSConcreteStackBlock;<br>        impl.Flags = flags;<br>        impl.FuncPtr = fp;<br>        Desc = desc;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __main_block_func_0(<span class="hljs-keyword">struct</span> __main_block_impl_0 *__cself) &#123;<br>    <span class="hljs-comment">// 局部变量，直接被copy封装到了Block中</span><br>    <span class="hljs-type">int</span> a = __cself-&gt;a; <span class="hljs-comment">// bound by copy</span><br><br>    <span class="hljs-comment">// 静态局部变量，copy其指针放到了Block中</span><br>    <span class="hljs-type">int</span> *b = __cself-&gt;b; <span class="hljs-comment">// bound by copy</span><br>    <br>    <span class="hljs-comment">// 全局变量（包括静态全局变量）直接使用，不做封装</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, globalStaticValue);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, globalValue);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, (*b));<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_desc_0</span> &#123;<br>    <span class="hljs-type">size_t</span> reserved;<br>    <span class="hljs-type">size_t</span> Block_size;<br>&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> __main_block_impl_0)&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span> </span>&#123;<br>    <span class="hljs-comment">// 局部变量</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;<br>    <br>    <span class="hljs-comment">// 静态局部变量</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> b = <span class="hljs-number">4</span>;<br>    <br>    <span class="hljs-built_in">void</span> (*testBlock)(<span class="hljs-type">void</span>) = ((<span class="hljs-built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a, &amp;b));<br>    <br>    ((<span class="hljs-built_in">void</span> (*)(__block_impl *))((__block_impl *)testBlock)-&gt;FuncPtr)((__block_impl *)testBlock);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的代码可以看出：<br>    - 局部普通变量会被block copy封装<br>    - 局部静态变量会被block copy其指针，通过指针访问<br>    - 全局普通变量和全局静态变量不会被封装，而是直接使用（实际上也没必要封装，在哪都能访问）</p><h2 id="Block对OC对象指针变量的捕获"><a href="#Block对OC对象指针变量的捕获" class="headerlink" title="Block对OC对象指针变量的捕获"></a>Block对OC对象指针变量的捕获</h2><p>仍然上代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-comment">// 静态全局对象</span><br><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSObject</span> *globalObjc;<br><br><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[]) &#123; <br>    <span class="hljs-comment">// 局部对象，且strong   </span><br>    <span class="hljs-built_in">NSObject</span> *object = [[<span class="hljs-built_in">NSObject</span> alloc] init];<br><br>    <span class="hljs-comment">// 局部对象，且weak</span><br>    __<span class="hljs-keyword">weak</span> <span class="hljs-built_in">NSObject</span> *weakObject = object;<br>    <br>    <span class="hljs-type">void</span> (^testBlock)(<span class="hljs-type">void</span>) = ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, object);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, weakObject);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, globalObjc);<br>    &#125;;<br>    <br>    testBlock();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用命令行转化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">xcrun -sdk iphoneos clang -<span class="hljs-built_in">arch</span> arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m<br></code></pre></td></tr></table></figure><p>转化后的C++代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> NSObject *globalObjc;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_impl_0</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__block_impl</span> impl;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_desc_0</span>* Desc;<br>    <span class="hljs-comment">// 捕获了对象指针及其所有权修饰符</span><br>    NSObject *__strong object;<br>    NSObject *__weak weakObject;<br>    __main_block_impl_0(<span class="hljs-type">void</span> *fp, <span class="hljs-keyword">struct</span> __main_block_desc_0 *desc, NSObject *__strong _object, NSObject *__weak _weakObject, <span class="hljs-type">int</span> flags=<span class="hljs-number">0</span>) : <span class="hljs-built_in">object</span>(_object), <span class="hljs-built_in">weakObject</span>(_weakObject) &#123;<br>        impl.isa = &amp;_NSConcreteStackBlock;<br>        impl.Flags = flags;<br>        impl.FuncPtr = fp;<br>        Desc = desc;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __main_block_func_0(<span class="hljs-keyword">struct</span> __main_block_impl_0 *__cself) &#123;<br>    <span class="hljs-comment">// 局部对象，且strong，通过捕获的指针访问</span><br>    NSObject *__strong object = __cself-&gt;object; <span class="hljs-comment">// bound by copy</span><br><br>    <span class="hljs-comment">// 局部对象，且weak，通过捕获的指针访问</span><br>    NSObject *__weak weakObject = __cself-&gt;weakObject; <span class="hljs-comment">// bound by copy</span><br>    <br>    <span class="hljs-built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_2p_n_j9tbqx6lqb2bqv110q6d300000gn_T_main_a7d9fa_mi_0, object);<br>    <span class="hljs-built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_2p_n_j9tbqx6lqb2bqv110q6d300000gn_T_main_a7d9fa_mi_1, weakObject);<br>    <span class="hljs-comment">// 全局对象，直接使用</span><br>    <span class="hljs-built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_2p_n_j9tbqx6lqb2bqv110q6d300000gn_T_main_a7d9fa_mi_2, globalObjc);<br>&#125;<br><br><span class="hljs-comment">// 对block进行copy时调用</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __main_block_copy_0(<span class="hljs-keyword">struct</span> __main_block_impl_0*dst, <span class="hljs-keyword">struct</span> __main_block_impl_0*src) &#123;<br>    <span class="hljs-comment">// 该函数根据所有权类型产生强引用或者弱引用</span><br>    _Block_object_assign((<span class="hljs-type">void</span>*)&amp;dst-&gt;object, (<span class="hljs-type">void</span>*)src-&gt;object, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);<br>    _Block_object_assign((<span class="hljs-type">void</span>*)&amp;dst-&gt;weakObject, (<span class="hljs-type">void</span>*)src-&gt;weakObject, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);<br>&#125;<br><br><span class="hljs-comment">// block从对中移除时调用</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __main_block_dispose_0(<span class="hljs-keyword">struct</span> __main_block_impl_0*src) &#123;<br>    <span class="hljs-comment">// 该函数释放引用</span><br>    _Block_object_dispose((<span class="hljs-type">void</span>*)src-&gt;object, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);<br>    _Block_object_dispose((<span class="hljs-type">void</span>*)src-&gt;weakObject, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_desc_0</span> &#123;<br>    <span class="hljs-type">size_t</span> reserved;<br>    <span class="hljs-type">size_t</span> Block_size;<br>    <span class="hljs-built_in">void</span> (*copy)(<span class="hljs-keyword">struct</span> __main_block_impl_0*, <span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>    <span class="hljs-built_in">void</span> (*dispose)(<span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span> </span>&#123;<br>    NSObject *object = ((NSObject *(*)(id, SEL))(<span class="hljs-type">void</span> *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(<span class="hljs-type">void</span> *)objc_msgSend)((id)<span class="hljs-built_in">objc_getClass</span>(<span class="hljs-string">&quot;NSObject&quot;</span>), <span class="hljs-built_in">sel_registerName</span>(<span class="hljs-string">&quot;alloc&quot;</span>)), <span class="hljs-built_in">sel_registerName</span>(<span class="hljs-string">&quot;init&quot;</span>));<br>    __attribute__((<span class="hljs-built_in">objc_ownership</span>(weak))) NSObject *weakObject = object;<br><br>    <span class="hljs-built_in">void</span> (*testBlock)(<span class="hljs-type">void</span>) = ((<span class="hljs-built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, object, weakObject, <span class="hljs-number">570425344</span>));<br><br>    ((<span class="hljs-built_in">void</span> (*)(__block_impl *))((__block_impl *)testBlock)-&gt;FuncPtr)((__block_impl *)testBlock);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果捕获的变量是OC对象，则将对象和所有权修饰符一并捕获。对捕获对象的增加或减少引用，通过内置函数实现。<br>注意，上面的代码只是改写成C++的表示，但是具体执行，比如对于weak、strong的使用，仍然需要利用到OC Runtime的支持（引用计数、weak表以及对应ARC管理机制）。比如在使用weak对象时，仍然需要通过<code>objc_loadWeakRetained</code>来使用，这和不使用Block时是一样的。</p><h2 id="block修饰符"><a href="#block修饰符" class="headerlink" title="__block修饰符"></a>__block修饰符</h2><p>我们知道，当我们需要通过修改Block捕获的局部变量进行赋值时，就需要使用该修饰符，上代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[]) &#123;<br>    __block <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">void</span> (^testBlock)(<span class="hljs-type">void</span>) = ^&#123;<br>        a = <span class="hljs-number">100</span>;<br>        printf(<span class="hljs-string">&quot;%d&quot;</span>, a);<br>    &#125;;<br>    testBlock();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换为C++代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 可见，一个简单的局部变量，因为通过__block修饰，被改写为了一个struct</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__Block_byref_a_0</span> &#123;<br>    <span class="hljs-type">void</span> *__isa;<br>    __Block_byref_a_0 *__forwarding;<br>    <span class="hljs-type">int</span> __flags;<br>    <span class="hljs-type">int</span> __size;<br>    <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_impl_0</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__block_impl</span> impl;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_desc_0</span>* Desc;<br>    __Block_byref_a_0 *a; <span class="hljs-comment">// by ref</span><br>    __main_block_impl_0(<span class="hljs-type">void</span> *fp, <span class="hljs-keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_a_0 *_a, <span class="hljs-type">int</span> flags=<span class="hljs-number">0</span>) : <span class="hljs-built_in">a</span>(_a-&gt;__forwarding) &#123;<br>        impl.isa = &amp;_NSConcreteStackBlock;<br>        impl.Flags = flags;<br>        impl.FuncPtr = fp;<br>        Desc = desc;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在block的struct中，多了一个<code>__Block_byref_a_0 *a</code>，该struct也有一个isa，所以也可以被当做是OC对象，另外还有一个forwarding指针，在之前，我们知道，该指针是为了方便Block从栈copy到堆时能够指向堆上的ref。</p><p>主要函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __main_block_copy_0(<span class="hljs-keyword">struct</span> __main_block_impl_0*dst, <span class="hljs-keyword">struct</span> __main_block_impl_0*src) &#123;<br>    _Block_object_assign((<span class="hljs-type">void</span>*)&amp;dst-&gt;a, (<span class="hljs-type">void</span>*)src-&gt;a, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __main_block_dispose_0(<span class="hljs-keyword">struct</span> __main_block_impl_0*src) &#123;<br>    _Block_object_dispose((<span class="hljs-type">void</span>*)src-&gt;a, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_desc_0</span> &#123;<br>    <span class="hljs-type">size_t</span> reserved;<br>    <span class="hljs-type">size_t</span> Block_size;<br>    <span class="hljs-built_in">void</span> (*copy)(<span class="hljs-keyword">struct</span> __main_block_impl_0*, <span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>    <span class="hljs-built_in">void</span> (*dispose)(<span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span> </span>&#123;<br>    <span class="hljs-comment">// 可以看出，转换后的ref的fowarding指针初始时就是ref本身</span><br>    __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>,(__Block_byref_a_0 *)&amp;a, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(__Block_byref_a_0), <span class="hljs-number">1</span>&#125;;<br>    <br>    <span class="hljs-built_in">void</span> (*testBlock)(<span class="hljs-type">void</span>) = ((<span class="hljs-built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, <span class="hljs-number">570425344</span>));<br>    <br>    ((<span class="hljs-built_in">void</span> (*)(__block_impl *))((__block_impl *)testBlock)-&gt;FuncPtr)((__block_impl *)testBlock);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，__block变量转换为了ref结构体，该结构体的forward指针初始时指向自身，如图所示：<br><img src="/../images/image-40.png" alt="Alt text"></p><p>最后，block在访问__block变量时，是通过forwarding指针获取到的。</p><p>__block的本质：<code>将变量改写封装到struct中，通过修改struct中的成员实现修改值</code>。</p><h2 id="Block存储域"><a href="#Block存储域" class="headerlink" title="Block存储域"></a>Block存储域</h2><p>前面也了解过，Block会存在于栈或者堆，有三种类型：<br><img src="/../images/image-41.png" alt="Alt text"><br>如何确定block的类型？可以在MRC环境下进行测试（因为ARC下可能会对Block自动copy），代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[]) &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">// block1，访问了局部变量，在stack</span><br>    <span class="hljs-type">void</span> (^block1)(<span class="hljs-type">void</span>) = ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s - %d&quot;</span>, __func__, a);<br>    &#125;;<br>    <br>    <span class="hljs-comment">// block2，没有访问局部变量，是global</span><br>    <span class="hljs-type">void</span> (^block2)(<span class="hljs-type">void</span>) = ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br>    &#125;;<br>    <br>    <span class="hljs-comment">// block3，对block1进行copy，是malloc</span><br>    <span class="hljs-type">void</span> (^block3)(<span class="hljs-type">void</span>) = [block1 <span class="hljs-keyword">copy</span>];<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ %@ %@&quot;</span>, [block1 <span class="hljs-keyword">class</span>], [block2 <span class="hljs-keyword">class</span>], [block3 <span class="hljs-keyword">class</span>]);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>copy操作对不同类型block的影响：</p><ul><li>stack -&gt; malloc</li><li>global -&gt; do nothing</li><li>malloc -&gt; 增加引用计数</li></ul><p>在ARC情况下，编译器会自动copy，比如：</p><ul><li>block作为返回值</li><li>block是strong的</li><li>block作为cocoa的usingBlock的参数时</li><li>block作为gcd的参数时</li></ul><h2 id="block变量的存储区域"><a href="#block变量的存储区域" class="headerlink" title="__block变量的存储区域"></a>__block变量的存储区域</h2><p><img src="/../images/image-42.png" alt="Alt text"><br>既然__block对应的struct是Block内部使用，那么Block需要维护__block的生命周期，可以看转换后的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 对block进行copy时调用</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __main_block_copy_0(<span class="hljs-keyword">struct</span> __main_block_impl_0*dst, <span class="hljs-keyword">struct</span> __main_block_impl_0*src) &#123;<br>    <span class="hljs-comment">// assign函数对__block变量生成强引用</span><br>    _Block_object_assign((<span class="hljs-type">void</span>*)&amp;dst-&gt;a, (<span class="hljs-type">void</span>*)src-&gt;a, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);<br>&#125;<br><br><span class="hljs-comment">// block从堆移除时</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __main_block_dispose_0(<span class="hljs-keyword">struct</span> __main_block_impl_0*src) &#123;<br>    <span class="hljs-comment">// dispose函数释放对__block变量的引用</span><br>    _Block_object_dispose((<span class="hljs-type">void</span>*)src-&gt;a, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_desc_0</span> &#123;<br>    <span class="hljs-type">size_t</span> reserved;<br>    <span class="hljs-type">size_t</span> Block_size;<br>    <span class="hljs-built_in">void</span> (*copy)(<span class="hljs-keyword">struct</span> __main_block_impl_0*, <span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>    <span class="hljs-built_in">void</span> (*dispose)(<span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span> </span>&#123;<br>    __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>,(__Block_byref_a_0 *)&amp;a, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(__Block_byref_a_0), <span class="hljs-number">1</span>&#125;;<br>    <br>    <span class="hljs-built_in">void</span> (*testBlock)(<span class="hljs-type">void</span>) = ((<span class="hljs-built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, <span class="hljs-number">570425344</span>));<br>    <br>    ((<span class="hljs-built_in">void</span> (*)(__block_impl *))((__block_impl *)testBlock)-&gt;FuncPtr)((__block_impl *)testBlock);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在copy和从堆上销毁block时，block内部会调用函数来维护对__block变量的引用计数。但是，<strong>如果block在栈上，并不会对__block变量产生引用</strong>（个人理解：因为栈上的block在作用域结束之后自动销毁，所以没必要进行引用）</p><p>在回忆下forwarding指针的作用，这是为了保证，无论block位于栈还是被copy到了堆，这些block都能够正确访问同一个ref结构体</p><h2 id="Block的循环引用"><a href="#Block的循环引用" class="headerlink" title="Block的循环引用"></a>Block的循环引用</h2><p>略</p><h2 id="面试题，如何Hook-Block的执行"><a href="#面试题，如何Hook-Block的执行" class="headerlink" title="面试题，如何Hook Block的执行"></a>面试题，如何Hook Block的执行</h2><p>通过参考官方源码，将block参数转换为struct，并修改其funcPtr</p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>OC</tag>
      
      <tag>Block</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mach内核</title>
    <link href="/2024/02/19/learn-about-mach-kernel/"/>
    <url>/2024/02/19/learn-about-mach-kernel/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>年过完啦，继续总结，先过渡下，回忆下Mach内核吧~Mach内核是OS X是iOS的核心中的核心，提供了线程调度、内存管理、硬件管理、IPC等重要功能</p><h2 id="OS-X系统"><a href="#OS-X系统" class="headerlink" title="OS X系统"></a>OS X系统</h2><ul><li>初代Apple使用的Mac OS和现在的OS X是不同的，初代Mac OS最后一代是Mac OS 9，终结于2001年</li><li>现在的OS X基于NeXTSTEP OS，于2001年正式接任</li><li>app bundle额interface builder的概念来自于NeXTSTEP，并且提供了Drive Kit用于驱动开发，后来被放到了IO Kit中</li><li>iOS派生自OS X，于2007年发布</li><li>NeXTSTEP是乔布斯在离开Apple之后创办了NeXT公司开发的</li><li>OS X和iOS的核心部分被称为Darwin，包含了XNU kernel和Unix基础</li><li>Darwin是开源的，但不含图形界面，并且没有官方ARM架构支持</li><li>XNU kernel是个混合kernel，包含Mach kernel和部分BSD</li><li>Carbon和Java都被OS X废弃，Carbon在Cocoa在功能上有重叠，在iOS上已经移除</li><li>graphic框架的核心是Quartz，其整合了Quartz Compositor（窗口组合）和Quartz 2D，其基于PDF模型，提供设备无关的分辨率，并可以使用OpenGL进行加速</li><li>OS X10.5首次支持64位Cocoa，10.6版本支持kernel以64位运行</li><li>OS X架构如下<br><img src="/../images/image-33.png" alt="Alt text"></li></ul><h2 id="XNU-kernel"><a href="#XNU-kernel" class="headerlink" title="XNU kernel"></a>XNU kernel</h2><ul><li>XNU是个混合kernel，包含BSD、Mach、IO Kit，实际上，有时这些layer的边界是模糊的，其架构如下：<br><img src="/../images/image-36.png" alt="Alt text"></li><li>KEXTs即kernel扩展，kernel扩展用于动态加载代码到kernel空间，从而可以编写驱动或者实现其他kernel功能，例如实现新的文件系统</li><li>KEXTs一般有两类：<ul><li>基于IO Kit，使用c++编写</li><li>基于通用kernel扩展，使用c编写</li></ul></li><li>XNU的最核心的部分是Mach，Mach为IOKit和BSD提供了硬件抽象、内存管理、线程调度、IPC</li><li>在Mach中，所谓Task，可以对应到Unix中的进程，Thread就是线程。Mach层面，Thread调度是独立，但是BSD层可以感知Thread属于哪个Task，以及进程之间的父子关系</li><li>XNU调度线程支持优先级，优先级如下：<br><img src="/../images/image-35.png" alt="Alt text"></li><li>XNU以双向链表的方式组织thread，每个优先级都有自己的链表，链表的集合被称为run queue，每个cpu的core都维护自己的run queue<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run_queue</span> &#123;</span><br><span class="hljs-type">int</span> highq; <span class="hljs-comment">/* highest runnable queue */</span><br><span class="hljs-type">int</span> bitmap[NRQBM]; <span class="hljs-comment">/* run queue bitmap array */</span><br><span class="hljs-type">int</span> count; <span class="hljs-comment">/* # of threads total */</span><br><span class="hljs-type">int</span> urgency; <span class="hljs-comment">/* level of preemption urgency */</span><br><span class="hljs-type">queue_head_t</span> queues[NRQS]; <span class="hljs-comment">/* one for each priority */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>Mach中的IPC，通过Port和Message<ul><li>Port类似于UDP协议，但是不局限于数据传输，而是可以提供同步、发送通知</li><li>Port使用message queue实现，一个port只能有一个sender，但是可以有多个receiver</li><li>每个Port需要有对应的right才能访问，同一个task中的thread共享Port的right，但是父子task的right不会继承</li><li>Port的right类型如下：<br>  <img src="/../images/image-37.png" alt="Alt text"></li><li>一组Port被称为Port Set，他们共享message queue，Port使用32位整数表示，并且没有全局注册表</li><li>在用户空间也是可以使用Mach IPC的，在一定程度上能代替system call，虽然最后也是通过system call调用</li></ul></li><li>Mach的Exception分为错误和正常，征程包含缺页、断点、系统调用（这在linux上被称为中断）<ul><li>Exception类型如下<br>  <img src="/../images/image-38.png" alt="Alt text"></li><li>当Exeption发生时，Mach会首先通过IPC Port将其发给引发Exception的thread，thread若无法处理交给Task，Task无法处理交给OS</li><li>Thread、Task和OS都维护了一组action，每个action用于处理一个 Exception type，如下  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">exception_action</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipc_port</span>* <span class="hljs-title">port</span>;</span> <span class="hljs-comment">/* exception port */</span><br>    <span class="hljs-type">thread_state_flavor_t</span> flavor; <span class="hljs-comment">/* state flavor to send */</span><br>    <span class="hljs-type">exception_behavior_t</span> behavior; <span class="hljs-comment">/* exception type to raise */</span><br>    <span class="hljs-type">boolean_t</span> privileged; <span class="hljs-comment">/* survives ipc_task_reset */</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li>其中flavor和behavior可以确定expcetion message和handler，handler即处理函数，可以是catch_mach_exception_raise()等。当Exception被分发后，kernel会等待replay，若返回KERN_SUCCESS意味着Thread可以继续执行</li><li>默认Thread的Exception Port是Null，默认由Task来处理。当进程使用Fork生成子进程时，子进程会继承父进程的Exception Port。XNU中的Unix的signal机制就是基于Mach的Exception机制来试下的</li></ul></li><li>XNU的Kernel地址空间和用户的Task的地址空间是独立的，而Linux的kernel地址空间和用户进程地址空间是共享的（kernel占用1GB、用户进程占用3GB，优点是无需TLB寻址，缺点是kernel地址受限），XNU和Task都各自占用4GB</li><li>XNU的虚拟内存数据结构使用了VM Map表示，VM Map代表进程的地址空间，以链表的方式串起来entry，entry在逻辑上是连续的，代表了一个region，而region则是可以合并和分割的，如下图所示<br><img src="/../images/image-39.png" alt="Alt text"></li><li>XNU源码：<br><a href="https://opensource.apple.com/">https://opensource.apple.com/</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Mach</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS KVO和KVC实现原理</title>
    <link href="/2024/01/18/think-deep-in-ios-kvc-kvo/"/>
    <url>/2024/01/18/think-deep-in-ios-kvc-kvo/</url>
    
    <content type="html"><![CDATA[<h1 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h1><p>在OC中，我们可以使用KVO机制来监听某个对象的属性值变化；swift中，一般使用属性的willSet和didSet达到类似效果，这里我们主要讨论OC的实现</p><h2 id="KVO的使用"><a href="#KVO的使用" class="headerlink" title="KVO的使用"></a>KVO的使用</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-comment">// 为receiver增加一个observer，从而监听receiver的属性变化</span><br>- (<span class="hljs-type">void</span>)addObserver:(<span class="hljs-built_in">NSObject</span> *)observer <br>         forKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath <br>            options:(<span class="hljs-built_in">NSKeyValueObservingOptions</span>)options <br>            context:(<span class="hljs-type">void</span> *)context;<br><br><span class="hljs-comment">// 在observer中实现该函数，当监听的属性发生变化时，回调该函数</span><br>- (<span class="hljs-type">void</span>)observeValueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath ofObject:(<span class="hljs-type">id</span>)object change:(<span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSKeyValueChangeKey</span>,<span class="hljs-type">id</span>&gt; *)change context:(<span class="hljs-type">void</span> *)context;<br><br><span class="hljs-comment">// 移除receiver的observer</span><br>- (<span class="hljs-type">void</span>)removeObserver:(<span class="hljs-built_in">NSObject</span> *)observer <br>            forKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath <br>               context:(<span class="hljs-type">void</span> *)context;<br></code></pre></td></tr></table></figure><h2 id="KVO实现机制"><a href="#KVO实现机制" class="headerlink" title="KVO实现机制"></a>KVO实现机制</h2><ul><li>KVO实现依赖于runtime，其基本原理是在addObserver时，runtime会动态创建一个原对象Class的子Class，然后让被监听对象的isa指向该创建的子Class，从而达到替换调用setXXX的方法效果</li><li>动态生成的Class一般叫做NSKVONotifying_KVOTestModel，并且其superClass指向被监听对象的原Class，这样，既可以替换指定的setXXX方法，又不影响调用其他方法</li><li>动态生成的Class除了替换了setXXX方法，还重写了class、dealloc等方法，这是因为系统要屏蔽内部实现细节。当然，如果我们直接用object_getClass来获取，获取到的还是派生的子Class</li><li>由于KVO是通过重写setter方法触发的，如果我们直接修改实例变量是不会触发KVO的，必须调用setXXX方法</li><li>重写的setter方法：先调用willChangeValue，然后调用原setter，最后调用didChangeValueForKey</li><li>监听属性使用的是keyPath，runtime会通过keyPath找到对应的setter并进行替换</li><li>KVO无论监听子类属性还是父类属性，都是可以的，即使子类中重写父类属性也是OK的，runtime只要找到setter方法就可以</li><li>使用block简化KVO调用：原理就是通过增加NSObject分类，添加便捷方法，将自身作为Observer去监听特定对象，当触发时，调用所有注册的block</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.neroxie.com/2019/07/12/KVO%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">https://www.neroxie.com/2019/07/12/KVO%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</a></p><h1 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h1><p>KVC允许我们通过keyPath来访问属性方法和成员变量，其工作原理依赖于搜索规则</p><h2 id="搜索规则"><a href="#搜索规则" class="headerlink" title="搜索规则"></a>搜索规则</h2><ul><li>依赖setter和getter以及accessInstanceVariablesDirectly（是否允许读取实例变量的值，默认为YES）</li><li>赋值原理：<ul><li>查找setXX，_setXX方法，找不到next</li><li>若accessInstanceVariablesDirectly为YES，则按照_XX,_isXX,XX,isXX去找实例变量，找不到next</li><li>调用setValue:forUndefinedKey<br><img src="/../images/image-32.png" alt="Alt text"></li></ul></li><li>取值原理：和赋值原理类似，但是注意<ul><li>若返回值是对象指针，则直接返回，若是基础类型且被NSNumber支持，则返回NSNumber，若不是则返回NSValue</li></ul></li><li>对于没有setXX的实例变量，KVC是否能触发KVO？讲道理是不行的，但实测可以，可能是apple自己再内部检测到了如果有KVO，则手动触发</li></ul><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.neroxie.com/2019/07/12/KVC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">https://www.neroxie.com/2019/07/12/KVC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>KVC</tag>
      
      <tag>KVO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解iOS Runtime</title>
    <link href="/2024/01/17/think-deep-in-ios-runtime/"/>
    <url>/2024/01/17/think-deep-in-ios-runtime/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>什么是Runtime，个人理解，就是代码run起来所需的环境，比如Java的Runtime就是Java虚拟机。这部分主要回忆下iOS的runtime，确切的说是OC的Runtime，即OC代码运行的依赖的环境及其内部机制。</p><h2 id="OC代码运行依赖于Runtime"><a href="#OC代码运行依赖于Runtime" class="headerlink" title="OC代码运行依赖于Runtime"></a>OC代码运行依赖于Runtime</h2><ul><li>C++&#x2F;C编译器编译时，对于函数的调用地址在编译时已经确定了</li><li>对于OC来说，函数调用是通过发消息的方式，基于Runtime的消息机制动态的找到调用函数的地址</li></ul><h2 id="OC元素认知"><a href="#OC元素认知" class="headerlink" title="OC元素认知"></a>OC元素认知</h2><ul><li>oc runtime的实现时libobjc，可以在github上找到<a href="https://github.com/gnustep/libobjc2">https://github.com/gnustep/libobjc2</a></li><li>id和Class的定义：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">if</span> !OBJC_TYPES_DEFINED</span><br><span class="hljs-comment">/// An opaque type that represents an Objective-C class.</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_class</span> *<span class="hljs-title">Class</span>;</span><br><br><span class="hljs-comment">/// Represents an instance of a class.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_object</span> &#123;</span><br>    Class isa  OBJC_ISA_AVAILABILITY;<br>&#125;;<br><br><span class="hljs-comment">/// A pointer to an instance of a class.</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_object</span> *<span class="hljs-title">id</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>可以看到，id就是objc_object结构体指针，而objc_object就是一个包含了一个objc_class指针(Class)的结构体</li></ul><p>objc_class的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_class</span> *<span class="hljs-title">Class</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_class</span> &#123;</span> <br> Class isa                                 OBJC_ISA_AVAILABILITY; <span class="hljs-comment">// metaclass</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !__OBJC2__</span><br> Class super_class                         OBJC2_UNAVAILABLE; <span class="hljs-comment">// 父类</span><br> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name                          OBJC2_UNAVAILABLE; <span class="hljs-comment">// 类名</span><br> <span class="hljs-type">long</span> version                              OBJC2_UNAVAILABLE; <span class="hljs-comment">// 类的版本信息，默认为0，可以通过runtime函数class_setVersion或者class_getVersion进行修改、读取</span><br> <span class="hljs-type">long</span> info                                 OBJC2_UNAVAILABLE; <span class="hljs-comment">// 类信息，供运行时期使用的一些位标识，如CLS_CLASS (0x1L) 表示该类为普通 class，其中包含实例方法和变量;CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法;</span><br> <span class="hljs-type">long</span> instance_size                        OBJC2_UNAVAILABLE; <span class="hljs-comment">// 该类的实例变量大小（包括从父类继承下来的实例变量）</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_ivar_list</span> *<span class="hljs-title">ivars</span>              <span class="hljs-title">OBJC2_UNAVAILABLE</span>;</span> <span class="hljs-comment">// 该类的成员变量地址列表</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_method_list</span> **<span class="hljs-title">methodLists</span>     <span class="hljs-title">OBJC2_UNAVAILABLE</span>;</span> <span class="hljs-comment">// 方法地址列表，与 info 的一些标志位有关，如CLS_CLASS (0x1L)，则存储实例方法，如CLS_META (0x2L)，则存储类方法;</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_cache</span> *<span class="hljs-title">cache</span>                  <span class="hljs-title">OBJC2_UNAVAILABLE</span>;</span> <span class="hljs-comment">// 缓存最近使用的方法地址，用于提升效率；</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_protocol_list</span> *<span class="hljs-title">protocols</span>      <span class="hljs-title">OBJC2_UNAVAILABLE</span>;</span> <span class="hljs-comment">// 存储该类声明遵守的协议的列表</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，objc_class里面也包含了isa指针，那是不是递归了？其实不是哈，这实际上是用于实现链表，等会就会看到它的作用了。实际上，由于任何包含isa指针的结构体都可以被看做是objc_object，所以Class也可以当成objc_object来使用。所以Class和Object并没有什么本质不同，只不过Class里面包含了额外的一些成员。</p><ul><li>重点：<ul><li>objc_object:<ul><li>isa：指向其Class，该Class中存放普通成员变量指针和方法指针</li></ul></li><li>objc_class:<ul><li>isa：指向其metaClass，即类的类，称为元类，元类中存放这静态变量指针和静态方法指针</li><li>super：指向该类的父Class，从而形成链式结构</li></ul></li><li>metaClass：我们知道metaClass也是objc_class,那么它的isa和super代表啥含义呢？好问题！实际上所有metaClass的isa都指向rootClass的metaClass，metaClass的super执向父Class的metaClass</li><li>那么rootClass的metaClass的isa和super指向哪？问得好！万物总归是由源头的嘛，它的isa指向自己，super指向nil</li><li>rootClass是啥？就是NSObject&#x2F;NSProxy的Class</li></ul></li></ul><p>一图胜千言，君请看：<br><img src="/../images/image-30.png" alt="Alt text"></p><ul><li>SEL：在oc中，我们对于方法的调用其实是间接的通过SEL消息传递的方式，SEL的本质是就是个结构体，一个标识符：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_selector</span> *<span class="hljs-title">SEL</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_selector</span> &#123;</span><br>    <span class="hljs-type">char</span> *name;                       OBJC2_UNAVAILABLE;<span class="hljs-comment">// 名称</span><br>    <span class="hljs-type">char</span> *types;                      OBJC2_UNAVAILABLE;<span class="hljs-comment">// 类型</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li>IMP:imp，实际是个函数指针，是函数的具体实现<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">id</span> <span class="hljs-params">(*IMP)</span><span class="hljs-params">(id, SEL, ...)</span>;<br></code></pre></td></tr></table></figure></li><li>Method：实际是类中方法的抽象类型，封装了IMP<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_method</span> *<span class="hljs-title">Method</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_method</span> &#123;</span><br>    SEL method_name                   OBJC2_UNAVAILABLE; <span class="hljs-comment">// 方法名</span><br>    <span class="hljs-type">char</span> *method_types                OBJC2_UNAVAILABLE; <span class="hljs-comment">// 方法类型</span><br>    IMP method_imp                    OBJC2_UNAVAILABLE; <span class="hljs-comment">// 方法实现</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>Ivar：代表实例变量地址<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_ivar</span> *<span class="hljs-title">Ivar</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_ivar</span> &#123;</span><br>    <span class="hljs-type">char</span> *ivar_name                   OBJC2_UNAVAILABLE; <span class="hljs-comment">// 变量名</span><br>    <span class="hljs-type">char</span> *ivar_type                   OBJC2_UNAVAILABLE; <span class="hljs-comment">// 变量类型</span><br>    <span class="hljs-type">int</span> ivar_offset                   OBJC2_UNAVAILABLE; <span class="hljs-comment">// 基地址偏移字节</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __LP64__</span><br>    <span class="hljs-type">int</span> space                         OBJC2_UNAVAILABLE; <span class="hljs-comment">// 占用空间</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>objc_property_t:是属性的抽象<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_property</span> *<span class="hljs-title">objc_property_t</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name; <span class="hljs-comment">// 名称</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *value;  <span class="hljs-comment">// 值（通常是空的）</span><br>&#125; <span class="hljs-type">objc_property_attribute_t</span>;<br></code></pre></td></tr></table></figure></li><li>Cache:用来缓存imp，因为OC通过SEL寻找Imp如果每次都是动态查找必然效率很低，所以其内部通过Cache来缓存找到的imp结果，加快执行效率<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_cache</span> *<span class="hljs-title">Cache</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_cache</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mask                   OBJC2_UNAVAILABLE;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> occupied               OBJC2_UNAVAILABLE;<br>    Method buckets[<span class="hljs-number">1</span>]                   OBJC2_UNAVAILABLE;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li>Category:即常用的分类，通过分类，我们可以动态给已经存在的类增加方法，顺便回忆下，Category的+load的覆盖，实际上取决于编译顺序<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_category</span> *<span class="hljs-title">Category</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_category</span> &#123;</span><br>    <span class="hljs-type">char</span> *category_name                           OBJC2_UNAVAILABLE; <span class="hljs-comment">// 类别名称</span><br>    <span class="hljs-type">char</span> *class_name                              OBJC2_UNAVAILABLE; <span class="hljs-comment">// 类名</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_method_list</span> *<span class="hljs-title">instance_methods</span>     <span class="hljs-title">OBJC2_UNAVAILABLE</span>;</span> <span class="hljs-comment">// 实例方法列表</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_method_list</span> *<span class="hljs-title">class_methods</span>        <span class="hljs-title">OBJC2_UNAVAILABLE</span>;</span> <span class="hljs-comment">// 类方法列表</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_protocol_list</span> *<span class="hljs-title">protocols</span>          <span class="hljs-title">OBJC2_UNAVAILABLE</span>;</span> <span class="hljs-comment">// 协议列表</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>oc runtime库提供了许多api，可以让我们动态修改类实例、方法甚至是动态创建类</li></ul><h2 id="OC-Runtime消息传递机制"><a href="#OC-Runtime消息传递机制" class="headerlink" title="OC Runtime消息传递机制"></a>OC Runtime消息传递机制</h2><ul><li>oc中，方法调用会被转换为objc_msgSendXXX(receiver, sel)调用</li><li>具体过程：<ul><li>判断sel是否要丢弃</li><li>判断receiver是否为nil，发给nil的消息会被忽略</li><li>在层级关系中寻找具体的方法实现<ul><li>寻找实例方法：从Class的methodLists寻找，找不到则从superClass的methodLists中找</li><li>寻找类方法：通过Class找到metaClass，从metaClass的methodLists中寻找，找不到，则从父类的metaClass的methodLists中寻找</li></ul></li><li>若还是找不到，则进入动态方法解析环节：<ul><li>调用resolveIntanceMethod：决定是否动态添加方法，若是，则通过class_addMethod动态添加方法，得以处理，否则next</li><li>调用forwardingTargetForSelector：既然自己没有这个方法，那转发给别人处理吧，如果返回指定对象，则调用指定对象的方法，返回nil，则next</li><li>调用methodSignatureForSelector：返回nil，结束，若返回methodSignature，则next</li><li>调用forwardInvocation：通过anInvocation做修改实现方法、修改响应对象，若成功，则结束，若失败，则next</li><li>调用doesNotRecognizeSelctor:若没有实现，则crash</li></ul></li></ul></li></ul><p>还是看图吧~<br><img src="/../images/image-31.png" alt="Alt text"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ianisme.com/ios/2019.html">https://www.ianisme.com/ios/2019.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>【iOS, Runtime]</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解iOS RunLoop</title>
    <link href="/2024/01/15/think-deep-in-ios-runloop/"/>
    <url>/2024/01/15/think-deep-in-ios-runloop/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Runloop是iOS和OSX中重要的概念，这部分主要回忆下其底层原理</p><h2 id="RunLoop概念"><a href="#RunLoop概念" class="headerlink" title="RunLoop概念"></a>RunLoop概念</h2><p>其实只要是窗口应用，无论是Windows、Android、QT，都会涉及到EventLoop的概念，以保证App能够持续响应用户交互。其基本实现原理都是启动一个无限循环，然后在循环中处理各种事件。RunLoop可以看做是iOS版本的EventLoop。iOS中的具体实现时基于CFRunLoopRef的NSRunLoop</p><h2 id="RunLoop与线程的关系"><a href="#RunLoop与线程的关系" class="headerlink" title="RunLoop与线程的关系"></a>RunLoop与线程的关系</h2><ul><li>主线程默认有一个Runloop</li><li>每个线程至多有一个Runloop（当然也可以没有runloop）</li><li>可以在线程中获取当前Runloop，若不存在，则进行创建<ul><li>NSRunLoop：[[NSRunLoop currentRunLoop] run]</li><li>CFRunLoop：CFRunLoopGetCurrent</li><li>注意currentRunLoop必须要添加source，不然运行起来就会立即退出</li></ul></li><li>源码分析：<ul><li>获取源码，具体实现看CFRunloop.c  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget -c -r -np -k -L -p   https:<span class="hljs-regexp">//</span>opensource.apple.com<span class="hljs-regexp">/source/</span>CF<span class="hljs-regexp">/CF-1153.18/</span><br></code></pre></td></tr></table></figure></li><li>具体实现：  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-comment">// 获取主线程runloop</span><br><span class="hljs-built_in">CFRunLoopRef</span> <span class="hljs-built_in">CFRunLoopGetMain</span>(<span class="hljs-type">void</span>) &#123;<br>    CHECK_FOR_FORK();<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">CFRunLoopRef</span> __main = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// no retain needed</span><br>    <span class="hljs-comment">// 若还不存在，在创建，绑定到主线程</span><br>    <span class="hljs-keyword">if</span> (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); <span class="hljs-comment">// no CAS needed</span><br>    <span class="hljs-keyword">return</span> __main;<br>&#125;<br><br><span class="hljs-comment">// 获取当前线程runloop</span><br><span class="hljs-built_in">CFRunLoopRef</span> <span class="hljs-built_in">CFRunLoopGetCurrent</span>(<span class="hljs-type">void</span>) &#123;<br>    CHECK_FOR_FORK();<br>    <span class="hljs-comment">// 首先从TSD中获取</span><br>    <span class="hljs-built_in">CFRunLoopRef</span> rl = (<span class="hljs-built_in">CFRunLoopRef</span>)_CFGetTSD(__CFTSDKeyRunLoop);<br>    <span class="hljs-comment">// TSD中有就直接返回TSD中(TSD就是thread specific data，这一步相当于作了个缓存，不用每次去全局dict去获取)</span><br>    <span class="hljs-keyword">if</span> (rl) <span class="hljs-keyword">return</span> rl;<br>    <span class="hljs-comment">// 否则创建，绑定到当前线程到TSD中</span><br>    <span class="hljs-keyword">return</span> _CFRunLoopGet0(pthread_self());<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="RunLoop的创建与释放"><a href="#RunLoop的创建与释放" class="headerlink" title="RunLoop的创建与释放"></a>RunLoop的创建与释放</h2><ul><li>创建：主要创建RunLoop结构体并初始化mode</li><li>释放：发生在thread销毁时，从全局dict中移除绑定关系</li></ul><h2 id="RunLoop的相关类和作用"><a href="#RunLoop的相关类和作用" class="headerlink" title="RunLoop的相关类和作用"></a>RunLoop的相关类和作用</h2><p><img src="/../images/image-27.png" alt="Alt text"></p><ul><li><p>主要包含</p><ul><li>CFRunLoopRef、CFRunLoopModeRef、CFRunLoopSourceRef、CFRunLoopTimerRef、CFRunLoopObserverRef</li><li>关系：runloop关联了多个mode，每个mode中包含多个source、timer、observer（统称item）</li><li>特别的，有一个虚拟的mode是common mode，它实际是个标记，标记为Common的Mode总是会执行commonModeItems中的回调，也就是说，将item添加到commonModeItems中，无论runloop当前处于哪种mode，都能被执行</li><li>所以，因为timer默认是加入到defaultMode，并没有加入到commonModeItems中，所以当滑动列表时，runloop切换到了tracking mode，自然不能执行default mode中的timer回调了</li><li>source分为source0和source1，source0用于app内部的事件分发，source1用于系统向app分发事件，比如触摸屏由系统生成touch事件并通过source1唤醒runloop，进而转换为source0回调</li><li>observer：当runloop的状态发生变化时，会回调对应的observer的回调，一般用于APM（App性能监控）<ul><li>runloop的状态主要包含：即将进入runloop、处理timer、处理source、即将进入休眠、结束休眠或被唤醒、退出loop</li><li>系统框架的observer：<ul><li>即将进入loop，创建pool</li><li>进入休眠之前，将layer的修改打包发给渲染进程</li><li>进入休眠之前，释放pool</li></ul></li><li>系统框架的source：<ul><li>source1：触摸屏事件，当被mach port唤醒时，处理source1的回调，该回调用来处理触摸屏事件</li></ul></li><li>系统框架的timer：NSTimer，但是CADisplayLink内部是source，两者并不一样</li><li>runloop和dispatch的关系：runloop实际是框架，dispatch则是负责block调度，两者相互协作，比如看：  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-comment">// 注意，正常流程下，如果main queue中有block，runloop会处理完毕再休眠</span><br><span class="hljs-comment">// 但是，如果runloop已经休眠了，此时通过异步线程发送给main queue一个block</span><br><span class="hljs-comment">// 那么首先，异步线程会唤醒主线程，进而执行runloop的__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE_函数</span><br><span class="hljs-comment">// 而在该函数中并不会直接执行block，而是调用dispatch库的_dispatch_main_queue_callback_4CF去处理</span><br><span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), block) <br></code></pre></td></tr></table></figure></li><li>NSURLSession：实际上就是在线程中开启runloop，注册source0和source1，source1用于接收底层系统的socket数据通知，source0用来接收由source1转发过来的通知</li></ul></li></ul></li><li><p>整个runloop的运行流程如下：<br><img src="/../images/image-28.png" alt="Alt text"></p><ul><li>注意source0只能在app内部通过手动调用的方式触发并唤醒runloop，而source1则可以绑定mach port，可以通过ipc的方式唤醒线程进而唤醒runloop</li><li>注意在runloop运行期间，可以持续收到source1，所以如果一直有source1，则runloop不会进入休眠，直到source1全部处理完毕</li><li>注意进入runloop和退出runloop只会执行1次</li><li>runloop和gcd的关系：<ul><li>一般情况下，runloop是基于gcd的api的，毕竟runloop是要跑在线程中，由gcd管理线程，但是因为runloop的存在，gcd唤醒主线程并发了一个block到main queue，则需要调用runloop的特定函数去处理，但是最终又回到了gcd的代码中</li><li>block也可以不通过gcd执行，而是通过放在runloop的指定mode中执行，不过一般不这么干，所以看到别人画的图中有block时，一般不是指gcd派发的block，而是由特定函数加入到runloop中的block，一般很少这么用，所以可以忽略掉</li><li>异步线程的gcd中派发block一般都是直接由gcd处理调度的</li><li>注意dispatch_async_main如果main thread没有休眠，则是在当前runloop执行的，不会让runloop休眠，一般只有dispatch_after才会在下一个runloop执行</li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>RunLoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS核心动画-Part7</title>
    <link href="/2024/01/13/ios-core-animation-p7/"/>
    <url>/2024/01/13/ios-core-animation-p7/</url>
    
    <content type="html"><![CDATA[<h2 id="高效绘图"><a href="#高效绘图" class="headerlink" title="高效绘图"></a>高效绘图</h2><ul><li>cpu绘图：通常是指自己实现drawLayer:InContext或drawRect，这需要额外开辟内存和计算，代价高昂</li><li>矢量图形：<ul><li>通过path绘制矢量图形，每次draw都会重绘整个path</li><li>优化：通过CAShapeLayer绘制</li></ul></li><li>脏矩形：<ul><li>有时CAShapeLayer并不能满足我们的要求，比如我们希望绘制的线条是用粉笔样式，那么CAShapeLayer显然不能实现</li><li>可以调用setNeedsPlayInRect来设置需要重绘的rect，这样drawRect不会重绘整个layer区域，可以减少需要绘制的内存和对象</li><li>异步绘制：一般情况下，布局、绘制都是在主线程上的，但是如果我们有预测的将某些内容放到异步去做，那么可以提高性能<ul><li>CATiledLayer就允许每个小块独立线程调用drwaLayerInContext</li><li>drawsAsync属性:和CATiledLayer不同，drawLayerInContext仍让在主线程调用，只不过该方法的实际代码执行是在异步线程，该属性适用于哪些频繁重绘的layer，如UITableView的cell</li></ul></li></ul></li></ul><h2 id="图像IO"><a href="#图像IO" class="headerlink" title="图像IO"></a>图像IO</h2><ul><li>可以优化图片加载时机：<ul><li>预加载</li><li>异步线程加载，有时为了避免主线程加载图片耗时，可以使用异步线程加载，如tableview展示很多图片，注意避免复用的情况，加tag标记cell，cell没有复用的情况下再展示图片（所以实际上没啥卵用），但对本地图片来说其实作用不是很大</li><li>避免延迟解码：<ul><li>iOS通常会延迟解码</li><li>UIImage的imageNamed方法会立刻解码而不会延迟</li><li>可以将image设置为contents避免延迟解码，但这回在主线程执行，所以不利于优化耗时</li><li>可以使用ImageIO框架，强制图片立刻解码</li><li>可以使用CGContext绘制图片<ul><li>绘制一个像素，然后丢弃绘制的像素，这回强制图片解码</li><li>绘制所有像素，然后丢弃原始图片，这种方式会在特定设备上优化</li></ul></li></ul></li><li>使用CATiledLayer来实现异步加载</li><li>使用预览图</li></ul></li><li>缓存：<ul><li>UIImageNamed默认会缓存，他有自己的缓存策略</li><li>自定义缓存：需要自己实现缓存key、缓存策略、失效策略（这里的失效是指相同文件名但内容变化）、回收策略等等</li><li>NSCache，类似于字典，但是系统会在内存压力大时自动回收</li></ul></li><li>文件格式：<ul><li>png适合透明图片、jpeg适合普通图片</li></ul></li></ul><h2 id="layer性能"><a href="#layer性能" class="headerlink" title="layer性能"></a>layer性能</h2><ul><li>隐式绘制：相对的是显式绘制，比如设置contents属性，使用cgcontext绘制；隐式绘制，则是通过使用特定的layer属性、特定的视图、特定的layer子类造成的</li><li>文本：CATextLayer使用CoreText绘制寄宿图，所以尽量避免改变他的frame，因为会引起重绘</li><li>光栅化：shouldRasterize会触发渲染为图片，然后结果将被缓存起来以便后续使用；但是如果用在频繁变动的layer上，缓存的优势荡然无存甚至更糟糕</li><li>离屏渲染：<ul><li>当不能直接在当前屏幕的framebuffer上绘制时，就会触发离屏渲染然后贴到当前的buffer</li><li>圆角、图层蒙版、阴影均会触发离屏渲染</li><li>圆角矩形可以优化为<ul><li>CAShapeLayer+Path的方式</li><li>圆角背景图片</li></ul></li><li>阴影可以优化为使用shadowPath,但是只对简单的形状有效</li></ul></li><li>混合和过度绘制：<ul><li>gpu每一帧填充的像素数量有限制，即填充率</li><li>屏幕上同一个像素被填充多次</li><li>但是如果存在大量重叠的透明子layer，那么gpu就需要消耗更多资源去计算layer的混合，并且对每个透明像素都需要绘制1次，造成过度绘制，为了减少混合和过度绘制行为，优化：<ul><li>视图设置不透明的色值</li><li>设置opaque为YES</li><li>图片尽量避免透明</li><li>若有可能，使用shouldRasterize，以将结果缓存避免混合</li></ul></li></ul></li><li>减少layer数量：<ul><li>创建layer、处理layer、打包layer数据给渲染进程都是有开销的</li><li>虽然CoreAnimation会处理不可见的layer，但我们自己也要避免创建不可见的layer</li><li>建立自己的layer回收机制</li></ul></li><li>建立快照：使用renderInContext，一般日后使用，一般适合固定不变的视图</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Core Animation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS核心动画-Part6</title>
    <link href="/2024/01/13/ios-core-animation-p6/"/>
    <url>/2024/01/13/ios-core-animation-p6/</url>
    
    <content type="html"><![CDATA[<h2 id="基于定时器的动画"><a href="#基于定时器的动画" class="headerlink" title="基于定时器的动画"></a>基于定时器的动画</h2><ul><li>NSTimer：普通的计时器，但是存在不准确、受到的runloop事件处理耗时的影响，我们可以修改为使用CADisplayLink和基于真实时间流逝进行计算</li><li>CADisplayLink：基于屏幕刷新进行回调，CADisplayLink因为是基于帧的，如果发生丢帧，那么丢帧时将不会调用回调，但是NSTimer总是会执行，即使延迟</li><li>计算帧耗时：在回调时记录当前时间，和上次时间进行对比，可以计算出实际上一帧持续的时间，进而动态调整下一帧要展示的数据</li><li>runloop mode:由于runloop中的事件分为不同优先级，所在在不同情况下，runloop优先执行某些mode下的回调，比如在滑动的时候，NSTimer可能就不被执行（因为它在defaultMode），如果想要不受这种影响，需要将我们的回调添加到commonMode中</li></ul><h2 id="物理模拟"><a href="#物理模拟" class="headerlink" title="物理模拟"></a>物理模拟</h2><p>略，很少用</p><h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><ul><li>CoreAnimation会智能将工作分配在cpu和gpu上以达到最优新能</li><li>在系统中，所有的layer的最终合成是被SpringBoard进程管理的</li><li>动画执行过程：<ul><li>App进程：<ul><li>布局：设置图层层级、位置、属性</li><li>显示： 绘制寄宿图，涉及UIView的drawRect和CALayer的drawLayerInContext</li><li>准备：将动画数据准备发送到渲染进程</li><li>提交：打包所有图层和动画数据发送到渲染进程</li></ul></li><li>渲染进程：<ul><li>解码图层数据</li><li>计算OpenGL纹理</li><li>GPU绘制</li></ul></li><li>只有最后的GPU绘制才是GPU处理，前面的都是CPU处理，并且只有布局和显示由开发者自己控制</li></ul></li><li>性能影响：<ul><li>GPU相关操作<ul><li>太多的图层会造成发送给渲染进程的数据量过大，造成cpu压力</li><li>重绘：由重叠的半透明layer引起，因为gpu填充比率有限制，所以需要避免重绘</li><li>离屏绘制：如圆角、为离屏图片分配内存，圆角触发离屏绘制的主要原因是无法在当前屏幕使用的frameBuffer中计算圆角的展示效果，否则会将背景像素也给切割掉，所以只能在额外的frameBuffer中先计算出本图层圆角的效果，然后再贴到当前的frameBuffer中去</li><li>过大的图片：如果图片过大，gpu无法处理，就需要cpu先预先处理</li></ul></li><li>CPU相关操作：<ul><li>如果CPU做了大量操作，则会引起卡顿，丢帧</li><li>布局计算：如果布局很复杂，自然是耗时验证的</li><li>view懒加载：如果view是懒加载的，自然也会降低布局速度</li><li>CG绘制：这个不用说，cpu自己开辟内存绘制，并且发送给给渲染进程，会造成巨大性能开销</li><li>解压图片：对于大图片，会占用一定时间</li><li>layer被发送到render进程之后，cpu会将layer转换为三角纹理，如果layer过于复杂，也会降低性能</li></ul></li><li>IO相关操作：如网络、读取文件等等，可以采取预加载、多线程、缓存机制进行优化</li></ul></li><li>测量性能&#x2F;Instruments<ul><li>Time Profile:测量函数耗时</li><li>Core Animation：CoreAnimation性能</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Core Animation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS核心动画-Part5</title>
    <link href="/2024/01/13/ios-core-animation-p5/"/>
    <url>/2024/01/13/ios-core-animation-p5/</url>
    
    <content type="html"><![CDATA[<h2 id="layer时间"><a href="#layer时间" class="headerlink" title="layer时间"></a>layer时间</h2><ul><li>CAMediaTiming：该协议定义了在一段时间内用于控制时间流逝的属性，如duration、repatCount，CALayer和CAAnimation都实现了该协议，所以时间可以被任意基于layer或者animation控制<ul><li>duration实际是动画重复一次的事件，还有repeatCount控制重复次数</li><li>repatDuration:指定动画重复指定时长</li><li>autoreveres:指定是否自动反向执行</li></ul></li><li>相对时间：animation中，每个aniamtion的时间有自己控制，可以加速、减速、延时<ul><li>beginTime：指定动画开始之前的延时时间，收到speed影响</li><li>speed：时间倍数，默认为1</li><li>timeOffset:让动画快进到某一点，但是不收speed硬性</li></ul></li><li>fillMode：指定动画的开始和结束时的行为<ul><li>removed:默认行为，在到达beginTime时才显示第一帧，并且结束后回到layer当前状态</li><li>backwards：无论是否到达beginTime，立刻显示第一帧，但只有到达beginTime才会执行动画</li><li>forwards：到达beginTime才显示第一帧，动画结束后保持最后一帧状态，直到动画被删除</li><li>both：backwards+forward综合体，立刻显示第一帧，并且结束后保持最后的状态，直到动画移除</li><li>思考：如何既删除动画又保留最终状态？需要我们自己实现delegate，动画结束后手动设置layer的属性值,注意如果不手动设置值，则layer的属性值并不会发生改变！！</li></ul></li><li>层级关系时间：对于layer调整时间将影响到所有子layer，子layer中的时间是以父layer为基准的，但是调整子layer时间并不会影响父layer<ul><li>duration、repeatCount、repatDuartaion并不会影响子layer，但是beginTime、timeOffset、speed会影响</li><li>全局时间：即mach时间，即CACurrentMediaTime，可以认为是绝对可靠的事件基准</li><li>本地时间：每个CALayer和CAAnimation都有自己的本地时间的概念，类似于坐标转换，可以在layer之间通过covertTime来转换</li></ul></li><li>暂停、倒回和跨进：通过设置layer的speed修改动画速度</li><li>手动动画：设置layer的speed为0，并且手动修改timeOffset即可</li></ul><h2 id="动画曲线"><a href="#动画曲线" class="headerlink" title="动画曲线"></a>动画曲线</h2><ul><li>动画速度：即改变量&#x2F;时间间隔</li><li>通过CAMediaTimingFunction的functionWithName创建动画曲线</li><li>通过CATransaction的setAnimationTimingFunction设置动画曲线</li><li>UIView动画在通过options更加方便我们使用动画曲线</li><li>关键帧动画的每个步骤都可以单独应用一个动画曲线</li><li>自定义动画曲线：可以通过functionWithControlPoints构造自己的动画曲线</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Core Animation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS核心动画-Part4</title>
    <link href="/2024/01/13/ios-core-animation-p4/"/>
    <url>/2024/01/13/ios-core-animation-p4/</url>
    
    <content type="html"><![CDATA[<h2 id="隐式动画"><a href="#隐式动画" class="headerlink" title="隐式动画"></a>隐式动画</h2><ul><li>CALayer的属性改变默认是带有自动动画的，比如颜色切换时会发生过渡，这就是所谓的隐式动画</li><li>隐式动画的时长取决于事务，动画类型取决于layer关联的CAAction</li><li>事务会将属性变化打包并做动画，通过CATransaction进行管理</li><li>类似于autorelease pool，事务也是类似stack的设计，当前属性的改变会被添加到最内层的事务，也可以通过begin、commit手动入栈和出栈</li><li>通过setAnimationDuration设置当前事务的时长</li><li>默认的，在每次runloop周期自动开启一次新的事务，所以一般我们不需要手动创建（是不是很像autorelease pool!!)，默认的时长是0.25s</li><li>UIView的animateWithDuration实际上内部就是对CATransaction begin、commit封装</li><li>可以通过setCompletionBlock来设置事务完成之后的回调，如果完成回调中作了动画，那么该动画是默认添加到外部的事务（一般是runloop开启的事务）中的</li><li>之前说，隐式动画的类型取决于layer关联的CAAction，UIView中的关联的layer的隐式动画实际是被禁用了的，也就是说，修改UIView的属性，默认是不带动画的，那么UIView是如何禁用隐式动画的呢？这就需要我们理解隐式动画的机制：<ul><li>当layer属性被修改时，layer会检测实现CALayerDelegate的actionForLayer:forKey方法，如果有，则之间返回结果</li><li>如没有实现delegate的委托，那么layer检查acttions字典</li><li>如果actions字典不存在对应属性，那么检查style字典</li><li>如果style字典不存在对应属性，那么调用兜底的defaultActionForKey</li><li>所以，最终返回一个CAAction，使用该action对属性做动画</li><li>UIView实际上通过实现了delegate，检测当前是否包含在动画块中，如果是，则返回对应CAAction，否则，返回nil，造成默认禁用的效果</li><li>当然，也可以通过调用CATransaction setDisableAction显式禁用所有隐式动画</li><li>这里，我们可以发现，如果想要修改隐式动画行为，对于单独的CALayer，可以实现deleagte，或者设置actions字典；对于UIView来说，要么放在动画块中，要么自定义UIView，重写actionForLayer，本质上，我们只是需要能够获取到何时的CAAction</li></ul></li><li>在做动画的时候，修改layer的属性，值会立刻发生变化，但是实际上渲染并没有立刻发生，动画时CALayer仅是model的角色，真正的呈现需要通过presentationLayer建模，通过presentation我们可以获取屏幕上当前真正展示的属性值，这允许我们在动画期间允许视图响应交互</li></ul><h2 id="显式动画"><a href="#显式动画" class="headerlink" title="显式动画"></a>显式动画</h2><ul><li>显式动画是相对于隐式动画来说，所谓的隐式，我认为理解为默认更合适，由UIKit框架决定，而显式则是开发者自己决定，对于底层渲染并不关心是隐式还是显式</li><li>属性动画：即创建一个CAPropertyAniation子类对象，设置该子类对应的keyPath和value，然通过layer的addAnimation应用该action，即可让keyPath指定的属性做预期动画，可以设置action的delegate，让其在停止时调用对应回调</li><li>通过setValueForKey给action关联特定值，可以在回调中区分出是哪个动画</li><li>CAKeyframeAnimation:是属性动画的子类，特点可以是设置values，或者设置path，让动画以指定的属性步调或者路径进行变化（如果是以path作为值，一般动画的属性是position，并且我们可以通过设置rotationMode来沿着path的切线运动）</li><li>虚拟属性：keyPath并不完全对应于真实属性，如果我们想做旋转动画，我们可能会想到transform属性，但是在某些情况下，可能直接使用transform不如使用虚拟属性transform.rotation更方便，后者只要指定旋转的角度即可，这实际上因为apple通过CAValueFunction内部对我们指定的虚拟属性作了计算实现的</li><li>动画组：之前的属性动画只能针对于单个属性做动画，通过CAAnimationGroup则可以将单独的属性动画组合起来一起做动画</li><li>过渡：属性动画只能针对于属性，如果想针对于layer整体内容（如移除子layer）做动画，则过渡更合适。CATransition通过type和subtype控制过渡效果。其实过渡动画在修改layer的content时默认发生的隐式动画，一般是淡入淡出</li><li>除了过渡实现内容动效，我们还可以自己使用renderInContext进行截图，然后对截图内容自定义属性动画实现自定义过渡效果</li><li>移除动画：调用removeAnimationForKey移除，移除之后，会立刻渲染成当前layer的属性值（注意不是目标值）；如果要让动画被移除之后更新layer的属性值，那么需要设置removedOnCompletion为NO，并设置fillMode</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Core Animation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS核心动画-Part3</title>
    <link href="/2024/01/11/ios-core-animation-p3/"/>
    <url>/2024/01/11/ios-core-animation-p3/</url>
    
    <content type="html"><![CDATA[<h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><ul><li>仿射变换：即旋转、缩放、平移。仿射变换的特定是在变换前后，两条平行直线依然保持平行</li><li>可以使用CGAffineTransformMakeXXX函数来创建一个变换</li><li>UIView中的transform属性对应于CALayer的affineTransform属性</li><li>可以通过CGAffineTransformXXX属性来和另一个transform进行合成新的transform</li><li>也可以使用concat来拼接两个transform</li><li>注意变换的顺序会影响最终的结果，先旋转后平移和先平移后旋转结果不同</li></ul><h2 id="3d-transform"><a href="#3d-transform" class="headerlink" title="3d transform"></a>3d transform</h2><ul><li>CGAffineTransform只是2d变换，CATransform3D则可以做3d变换</li><li>可以使用CATransformMake生成对应变换，iOS上z轴从屏幕向外</li><li>3d transform默认是等距投影而不是透视投影，这意味着远处的边和近处的边是看上去一样长，这不符合人类视觉，所以3d效果不强</li><li>要使用透视效果，需要修改transform3d的m34值，m34默认为0，可以取值为-1&#x2F;d,d越小，透视效果越强，同时越失真，d越大，透视效果越弱</li><li>灭点：所有透视物体最远处的共同消失点，默认是anchorPoint，位于layer中心。所以一般对多个layer做透视同时让他们保持同一个灭点，可以先将layer放到屏幕中线做变化，然后平移到指定位置；更方便的方法是设置父容器的subLayerTransform来让所有子layer共享灭点，这样不用将每个layer先放到中心再做变换</li><li>layer有个doubleSided,表示是否要双面绘制，默认YES，如果设置为NO，则翻转后不显示</li><li>注意在3d transform加透视的情况下，先对外层绕y轴旋转，再对内层绕y轴逆向旋转是不会使得内层回到初始状态的，因为外层变换之后，内层已经被被渲染变形了，再做逆向旋转只是对原来变形的layer做旋转</li><li>可以使用3d transform构建立方体，不常用，略</li></ul><h2 id="专用layer"><a href="#专用layer" class="headerlink" title="专用layer"></a>专用layer</h2><ul><li>CAShapeLayer：通过CGPath绘制指定形状，相比于直接通过CGContext绘制，渲染速度更快，并且可以超出layer之外绘制；通过bezier Path可以绘制任意形状的shape，自然可以绘制自定义圆角</li><li>CATextLayer：功能上比肩UILabel，但速度更快，并且支持富文本，可以将CATextLayer作为自定义View的宿主layer来实现自定义的UILabel</li><li>CATransformLayer：方便3d展示，略</li><li>CAGradientLayer：最常用，展示渐变色</li><li>CAReplicationLayer：对每个子layer接连应用指定次数的变换和色彩偏移，复制出指定数量的子layer，可以利用它实现反射效果</li><li>CAScrollLayer：实现自定义的ScrollView，虽然contentRect可以指定layer可视区域，但是处理滑动并不方便</li><li>CATiledLayer:将大图分解为小片并按需载入，以避免性能压力，实际上CATiledLayer需要我们手动将大图分解为小图，在需要的时候通过回调在drawLayerInContext函数中需要我们实现读取指定小图的逻辑</li><li>CAEmitterLayer：实现例子效果</li><li>CAEAGLLayer：实现opengl绘制，大多用于3d绘制</li><li>AVPlayerLayer：视频播放，是MPMoviePlayer的底层</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Core Animation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS核心动画-Part2</title>
    <link href="/2024/01/09/ios-core-animation-p2/"/>
    <url>/2024/01/09/ios-core-animation-p2/</url>
    
    <content type="html"><![CDATA[<h2 id="layer几何学"><a href="#layer几何学" class="headerlink" title="layer几何学"></a>layer几何学</h2><ul><li>UIView的的属性frame、bounds、center对应layer的frame、bounds、position</li><li>frame代表相对于父view上的坐标，bounds是设定自身的坐标，center和position代表自身的anchorPoint相对于父view的坐标，center和anchorPoint只不过是同样的东西的不同表述罢了</li><li>anchorPoint和position是同样的东西，但是修改其中之一，不影响另一个，但是这样的话frame就得变动了，其计算公式如下： <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objc"> <span class="hljs-comment">// 这里记住，anchorPoint和position只是同一个东西，只是数值不同，按照默认anchorPoint 0.5 0.5去推算就行</span><br>position.x = frame.origin.x + anchorPoint.x * bounds.size.width；  <br>position.y = frame.origin.y + anchorPoint.y * bounds.size.height；<br></code></pre></td></tr></table></figure></li><li>anchorPoint默认位于中间，他是layer进行变换时的锚点，比如同样都是缩放，是从中间开始缩放还是从左上角开始缩放是不同的效果</li><li>view的几种属性，实际上最终改变的是layer的属性，frame实际上是个计算属性，会根据bounds、position、transform计算得到，而改变frame也会改变这几个值，frame始终代表的是轴对齐的一个矩形区域，当旋转后可能frame的宽高和bounds的宽高不再一致，我们一般修改frame来进行布局，但实际上，底层layer使用的是anchorPoint来定位<br><img src="/../images/image-26.png" alt="Alt text"></li><li>修改layer的anchorPoint，会造成view的位置变动，把锚点想象成一个钉子，系统会优先使用锚点定位，然后根据宽高计算出frame，当我们修改锚点时，做旋转变换是以锚点为中心点的</li><li>可以通过CALayer提供的convertXXX函数来进行坐标转换</li><li>layer有zindex决定覆盖顺序，默认是按照子layer的添加顺序展示</li><li>CALayer虽然不关心触摸事件，却提供了containsPoint和hitTest的方法<ul><li>containsPoint: 接受子layer的坐标，由每个子layer判定是否在区域中，所以需要先转换为子view的point</li><li>hitTest:接受父layer中的坐标，返回是哪个子layer被触摸了，但是hitTest依赖于添加的顺序，如果手动修改了zIndex，就检测不正确</li></ul></li><li>CALayer没有UIView的自动布局，但是可以实现CALayerDelegate的layoutSUblayersOfLayer当布局调整时重新设置layer的frame</li></ul><h2 id="layer可以实现的视觉效果"><a href="#layer可以实现的视觉效果" class="headerlink" title="layer可以实现的视觉效果"></a>layer可以实现的视觉效果</h2><ul><li>圆角：cornerRaidus，默认不影响子layer，但可以设置maskTouBounds</li><li>边框：borderWidth和borderColor，内边框</li><li>阴影：shadowColor（阴影色值）、shadowOffset（默认向为0,-3向上偏移）、shadowRadius（控制模糊度），阴影的形状和寄宿图的形状完全一致，我们也可以指定shadowPath来自己绘制阴影形状</li><li>clip会将阴影给裁掉，可以先内部进行裁减，然后添加到外部容器上，再给外部容器设置阴影，因为阴影默认是针对寄宿图的形状的（也就是裁减之后的子view）</li><li>mask：可以将一个layer A设置为另一个layer B的mask属性来将B的内容裁减为A的形状</li><li>放大或者缩小content时，可以选择不同的采样算法，默认是linear，可以选择neareast</li><li>组透明：ios7之前默认是false（即子layer和父layer会独立计算透明度像素然后再叠加），ios7之后（包含ios7）之后是true（即子layer和父layer会作为一个整体计算透明度像素），所以一般无需考虑</li><li>shouldRasterize+rasterizationScale用于将layer光栅化，那么效果也是整体的</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Core Animation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS核心动画-Part1</title>
    <link href="/2024/01/08/ios-core-animation-p1/"/>
    <url>/2024/01/08/ios-core-animation-p1/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Core Animation实际是由Layer Kit演变而来的，是一个强大的符渲染引擎，通过将独立的layer进行组合成树状结构进行渲染</p><h2 id="Layer-tree"><a href="#Layer-tree" class="headerlink" title="Layer tree"></a>Layer tree</h2><ul><li>UIKit中，我们使用的是UIView，UIView可以处理事件、CG绘图和简单的动画，UIView之间组成了树状关系</li><li>CALayer和UIView类似，只是不支持处理事件</li><li>实际上，每个UIView都管理一个CALayer，反之则未必，CALayer才是真正处理渲染的，UIView&#x3D;CALayer+事件处理+动画抽象接口，实际上就是分层和解耦的思想的体现</li><li>但是有时想实现复杂的展示效果，如果阴影、圆角，UIView没有提供相应接口，此时就必须直接操作CALayer</li><li>可以直接创建layer并添加到子layer</li></ul><h2 id="寄宿图"><a href="#寄宿图" class="headerlink" title="寄宿图"></a>寄宿图</h2><ul><li>layer有个contents属性，可以添加一个CGImageRef显示图片，称为寄宿图，类似于UIImageView，可以设置contentGravity设置缩放模式， contentScale用于设置一个点显示多少像素，如果在高分屏上设置低scale，那意味着每个物理点显示的像素数更少，则颗粒感越强</li><li>默认情况下，UIView的内容如果超出边界不会裁减，layer也一样，可以设置maskToBounds属性（UIView叫做clipToBounds）</li><li>contentsRect：可以指定显示寄宿图的区域，是单位坐标</li><li>contentsCenter: TODO,感觉不是很理解,类似于.9图？</li><li>drawRect：<ul><li>可以通过在UIView的方法以代码方式设置寄宿图，像素大小是layer大小*scale，所以如无必要不要实现该方法，造成资源浪费</li><li>实际上UIView将自己layer的CALayerDelegate设置为自己，并在必要的时候触发layer的display方法，如果我们不依赖UIView，可以手动实现CALayerDelegate并自己决定何时调用display</li><li>手动调用layer的display方法 -&gt; delegate 若实现了displayLayer，则调用该函数，否则 -&gt; delegate: drawLaer in context-&gt; uiview: drawInContext</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Core Animation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OC高级编程-GCD</title>
    <link href="/2024/01/06/oc-advance-gcd/"/>
    <url>/2024/01/06/oc-advance-gcd/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分主要介绍iOS 4引入了GCD多线程编程模型</p><h2 id="GCD概要"><a href="#GCD概要" class="headerlink" title="GCD概要"></a>GCD概要</h2><ul><li>概念：是执行异步任务的技术之一，基于线程，但是相比于直接使用线程更加安全和方便，开发者无需关心底层线程的创建</li><li>在gcd之前，cooca提供在NSObject类提供了performSelectorInBackground&#x2F;onMainThread来实现</li><li>多线程的问题：race condition、dead lock、线程爆炸等等</li></ul><h2 id="GCD-API"><a href="#GCD-API" class="headerlink" title="GCD API"></a>GCD API</h2><ul><li>dispatch queue：即任务队列<ul><li>串行队列：任务必须依次执行完毕，单线程，每个queue对应一个线程</li><li>并发队列：任务不必依次执行完毕，可同时执行，多线程,线程数由os管理</li></ul></li><li>创建queue：dispatch_queue_create</li><li>dispatch_release&#x2F;dispatch_retain:自iOS6以来，dispatch对象被纳入了ARC，不需要手动调用</li><li>main queue和global queue：main queue比较特殊，与主线程绑定，global queue都是异步线程，global queue支持设置优先级</li><li>disptach_set_target_queue:该api主要用于修改dispatch_queue_create生成queue的优先级，注意不能修改直接main queue和get_global_queue得到的queue的优先级，同时本应在queue上执行的任务也将放到目标queue上执行<ul><li>一个可能的用法：将两个串行queue放到一个串行queue上执行，避免两个queue并发，实际上就是重新绑定了queue</li></ul></li><li>dispatch_afer:延时执行</li><li>dispatch_group:实现结构化并发，被添加到group中的任务必须全部执行结束，才会触发触发dispatch_group_notify设置的回调</li><li>dispatch_wait:阻塞当前线程，等待group中的所有任务执行完毕</li><li>dispatch_barrier_async:在并发queue中，所有的任务执行是乱序的，但是该函数就行一个栅栏，分割了上面和下面的任务，所以该函数一般是和并发队列一起使用</li><li>dispatch_sync:同步执行，在任务执行结束之前，调用线程会一直阻塞，注意在主线程中调用可能造成死锁（在主线程中执行了sync到main queue的操作，使得主线程wait，永远没有机会被唤醒）</li><li>dipatch_apply:在queue上执行指定次数，并且在执行完毕之前阻塞当前线程</li><li>dispatch_suspend&#x2F;dispatch_resume:挂起和恢复执行的queue</li><li>dispatch信号量：使用disptahc_seamphore和dispatch_semaphore_wait&#x2F;signal来等待和释放信号量，信号量大于0时才能执行，否则阻塞</li><li>dispatch_once:保证只执行一次，一般用于实现单例</li><li>dispatch io:主要用于并发读取和处理文件，略</li></ul><h2 id="GCD实现"><a href="#GCD实现" class="headerlink" title="GCD实现"></a>GCD实现</h2><ul><li>GCD的实现构成：<ul><li>libdispatch：基于pthread抽象出queue</li><li>libc：提供pthread</li><li>xnu内核：workqueue</li></ul></li><li>queue就是通过链表实现的队列，block一般不直接加入queue，然后先封装到dispatch continuation结构体中，然后再加入queue，不管如何，最后实际都是绑定到main queue或者root global queue中</li><li>root global queue按照优先级和是否强制生成线程分为8种，强制生成线程一般用于串行队列（因为每个串行队列都要生成一个线程）<br><img src="/../images/image-25.png" alt="Alt text"></li><li>每个global queue使用一个pthread_workqueue,对应xnu内核的wrokqueue，关系如图：<br><img src="/../images/image-24.png" alt="Alt text"></li><li>具体执行过程：block从queue中被取出，将global queue、workqueue信息和continuation作为参数传递给pthread的work_queue_add函数，pthread则通过系统调用，通知xnu内核增加执行项目，xnu判断是否生成线程，然后执行pthread_work_queue函数，最终执行block，block执行结束后，进行通知group、取下一个block操作</li><li>dispatch source:实际是xnu的kqueue的封装，当系统事件出现时进行回调的技术，比如mach端口发送&#x2F;接受、定时器等等，并且dispatch_source可以设置取消回调</li><li>主队列和主线程：主队列的任务必然在主线程中执行，主线程中不仅可以执行主队列任何，还有可能执行其他关联的任务</li><li>在libdispatch内部，<strong>可以将线程和queue关联起来，比如主线程</strong>，既可以执行main queue任务，也可以执行其他queue任务，那么在执行的时候，就需要先获取原来的queue保存起来，将线程设置为新queue绑定，然后执行完毕之后再恢复与原来queue的绑定</li><li>dispatch_sync实际上会优化为当前线程执行，如果在主线程上执行，那么因为会阻塞主线程，导致block无法执行，也就无法唤醒，造成dead lock</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>OC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OC高级编程-Blocks</title>
    <link href="/2024/01/06/oc-advance-blocks/"/>
    <url>/2024/01/06/oc-advance-blocks/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本章主要介绍iOS4引入的Blocks，对应其他语言的闭包，可以看做是编译器自动生成的带有上下文变量和函数的结构体。</p><h2 id="Blocks概要"><a href="#Blocks概要" class="headerlink" title="Blocks概要"></a>Blocks概要</h2><ul><li>概念：带有自动变量的匿名函数</li></ul><h2 id="Blocks的模式"><a href="#Blocks的模式" class="headerlink" title="Blocks的模式"></a>Blocks的模式</h2><ul><li>语法：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">// 完整写法<br>^返回类型 (参数列表) &#123;表达式&#125;<br>// 返回类型可以省略<br>^(参数列表) &#123;表达式&#125;<br>// 没有参数时可省略参数列表<br>^&#123;表达式&#125;<br></code></pre></td></tr></table></figure></li><li>block类型声明<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">// 实际上，这种写法和c函数指针很相似 int(*ptr)(type...)<br>返回类型 (^变量名)(参数列表类型)<br></code></pre></td></tr></table></figure></li><li>与typedef结合使用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">// 使用typedef可以简化传参<br>typedef 返回类型 (^类型名)(参数列表类型)<br></code></pre></td></tr></table></figure></li><li>block类型变量和其他c变量一样，也可以使用block *指针</li><li>block默认捕获外部变量的值的默认方式是copy，在block内部默认不能修改外部值，如要修改，需要在被捕获的变量前加__block修饰</li><li>block没有实现对c数组的捕获，<strong>不能捕获c数组，需要使用c指针</strong></li></ul><h2 id="Blocks的实现"><a href="#Blocks的实现" class="headerlink" title="Blocks的实现"></a>Blocks的实现</h2><ul><li>block实质：实质就由编译器生成的struct</li><li>为了探究编译器的实现，使用clang –rewrite-objc重写为c++<ul><li>编译器合成了一个xxx_block_impl_idx的结构体，封装了函数和捕获的变量</li><li>block结构体的isa指针描述了block的类型</li><li>id的本质是objc_object的指针的typedef，即  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">typedef struct objc_object &#123;<br>    Class isa;<br>&#125; *id;<br></code></pre></td></tr></table></figure></li><li>Class实际是objc_class的指针的typedef，即  <figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm">typedef struct objc_class&#123;<br>    <span class="hljs-type">Class</span> isa;<br>&#125; *<span class="hljs-type">Class</span>;<br></code></pre></td></tr></table></figure>  和objc_object完全相同。</li><li>假设有个类叫做NyanCat，则NyanCat对象的实际的结构体objc_object中包含了：<ul><li>isa：指向其自己的Class，自己的Class包含了实例方法和实例成员的信息<ul><li>自己的Class中的isa，指向元类的Class，元类的Class的super指向父类元类的Class</li><li>自己的Class的super，指向父类的Class</li></ul></li><li>具体实例成员<br>  如下图所示<br>  <img src="/../images/image-23.png" alt="Alt text"></li><li>总是，就是具体实例+描述信息，仅此而已</li><li>Class的具体实现就是class_t</li></ul></li><li>而block的结构体也包含有isa，可以看做是oc对象（**只要有isa的struct都可以认为是oc对象），其isa则是NSXXXBlock</li></ul></li><li>对于自动变量的捕获，编译器通过在创建block struct传入进行赋值到struct实例中</li><li>__block:实际上__block类似于auto，向编译器表明存储区域。编译器为__block变量创建一个ref结构体，将变量封装到该结构体中，对该变量的访问实际就是对该结构体的访问（类似于Swift的propertyWerapper)<ul><li>在ref中有个forwarding指针，指向自身，需要通过forwarding指针访问值而不直接通过ref</li><li>同一个ref可以被多个block共享，也就是说，block中存放该ref的指针而不存放具体的ref</li></ul></li><li>之前说过，block可以看做是oc对象，block的类可以分为：<ul><li>stack:分配在栈上，捕获变量的block，脱离作用域则被销毁</li><li>global：分配在data区,例如全局block和不捕获变量的block</li><li>malloc：分配在堆，将block和__block进行copy，这也是__block为啥要用一个forwarding，因为当copy后，如果栈上的ref还指向自身，就没法同步变化了</li><li>大多数情况下，block不需要显式copy，编译器会自动copy，如从函数中返回block，调用retainBlock，实际会调用block_copy</li><li>coco框架usingBlock和gcd的api都会帮我们copy，不需要手动调用</li><li>实测，大部分函数返回或者传递的block都会帮我们copy</li><li>对于已经在堆上的block进行copy只会增加引用计数</li><li>在ARC中，多次连续copy不会有问题，copy之后的引用计数就是持有变量的数量</li></ul></li><li>__block变量当block从栈复制到堆时，会跟着一起复制，多个block持有时会增加其引用计数，当block被废弃时，__block也会一起被废弃</li><li>block捕获对象，即增加对象的引用计数，默认是捕获的是__strong引用，编译器会给合成的ref增加合成对应的assign和dispose，实际相当于retain和release<ul><li>ps:书中说如果不对block copy，那么持有的强引用无效，实测还是有效的，不会有任何问题，不需要手动copy</li></ul></li><li>block循环引用：略，使用weak即可，或者使用__block，再执行完毕之后，手动设置为nil（不推荐！！）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>OC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OC高级编程-ARC</title>
    <link href="/2024/01/03/oc-adavance-arc/"/>
    <url>/2024/01/03/oc-adavance-arc/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分主要介绍OC的内存管理实现原理。</p><h2 id="什么是ARC"><a href="#什么是ARC" class="headerlink" title="什么是ARC"></a>什么是ARC</h2><ul><li>ARC，即自动引用计数，是在iOS 5中被引入的。类似于C++中的智能指针</li></ul><h2 id="内存管理-引用计数"><a href="#内存管理-引用计数" class="headerlink" title="内存管理&#x2F;引用计数"></a>内存管理&#x2F;引用计数</h2><ul><li>在很久之前，需要开发者手动管理对OC对象内存，即需要手动retain和手动release，ARC的引入则是将这项任务交给了编译器</li><li>MRC的一般规则：<ul><li>使用以下名称开头的方法意味着调用方生成对象并持有：<ul><li>alloc&#x2F;new&#x2F;copy&#x2F;mutableCopy</li></ul></li><li>非调用方生成的对象，调用方也可以持有<ul><li>例如通过非上述方法生成的对象，调用方可以通过显式retain的方式进行持有</li></ul></li><li>不再需要持有对象时进行释放<ul><li>使用release方法</li></ul></li><li>非自己持有的对象，不能释放，这是保证持有和释放匹配，否则就会造成崩溃</li><li>根据上面的规则，如果某个方法生成对象，并将其给到调用法，应该如何做？<ul><li>如果是以alloc&#x2F;new等开头的方法，方法内部进行retain再返回给调用法，即可满足语义</li><li>如果非alloc&#x2F;new等开头的方法，则需要将其<strong>先加入到autorelease</strong>，再返回给调用方，由调用方进行retain（可选）<ul><li>如果不加入到autorelease，则会立即释放，调用方就没有机会进行retain了</li></ul></li></ul></li></ul></li><li>alloc&#x2F;retain&#x2F;release&#x2F;dealloc的内部实现<ul><li>理解的最好的方式就是看源码，但是Apple并没有开源Foundation框架，所以只能借助于GNUstep框架来近似理解(实际上objc runtime已经开源了，但如果只是为了理解，GNUstep的实现完全够了)</li><li>GNUstep的实现：<ul><li>alloc：计算对象大小，然后分配对应元数据+对象本身需要的内存大小，元数据中保存对象引用计数retain计数<ul><li>注意，alloc时，retain计数的实际值为0，只不过在对外展示时手动+1展示，那么当release时，只要当前retain计数的实际值为0，那么就说明一定是最后一个对象，直接dealloc</li></ul></li><li>retain：将元数据中计数增加</li><li>release：将元数据中计数减少，当减少时retain为0，说明是最后一个对象，执行dealloc</li><li>dealloc：释放创建的内存，注意只需要传元数据地址就行，free只需要内存块的首地址就能正确释放</li></ul></li><li>Apple的实现<ul><li>此处作者通过lldb符号断点的方式大致进行猜测</li><li>在Apple的实现中，引用计数不是保存在对象头部的元数据中，而是单独放到了一个hash表中</li></ul></li><li>两种实现的优缺点比较：<ul><li>放在头部：实现简单，可以统一管理引用计数和对象内存</li><li>放在hash表：对象内存分配时不需要考虑头部（即解耦），hash表中存放了各对象的内存地址，从而可以获取每个对象的内存块（信息更丰富）</li></ul></li></ul></li><li>autorelease的内部实现：<ul><li>autorelease对象会存放到NSAutoreleasePool中，当pool被drain时，其中的对象会自动调用release</li><li>在一次runloop中，会自动创建一个pool，在runloop结束时，会自动drain，所以一般不需要手动创建pool</li><li>但是有时我们想要提前释放一些autorelease对象，比如在循环中大量生成NSString，这些NSString如果是默认被添加到主runloop的pool中，那么必须得等主runloop结束时才会释放，这会造成内存压力。此时我们就可以手动创建pool，将对象创建放到我们pool中，从而可以控制释放时机，降低内存压力</li><li>内部实现：<ul><li>GNUstep的实现：<ul><li>添加到pool：先获取当前正在使用的pool，然后将对象添加到pool中，因为pool类似于一个栈结构，当前使用的pool就是最内层嵌套的pool</li><li>drain：先清空pool，即对pool中的所有对象调用release，最终release内部存储容器</li></ul></li><li>Apple的实现：<ul><li>思想是相似的，不过Apple使用的容器叫做AutoreleasePoolPage，push生成一个page，pop销毁一个page，对象调用autorelease则会添加到当前的page中</li></ul></li><li>问题：pool可以调用autorelease么？答案是不可以，pool的autorelease方法被重载，只要调用就会发生异常(当然，在ARC下我们也无法直接创建pool对象，要关闭ARC，可以在project-build settings中进行设置)</li></ul></li></ul></li></ul><h2 id="ARC规则"><a href="#ARC规则" class="headerlink" title="ARC规则"></a>ARC规则</h2><ul><li><p>在ARC的情况下，编译器会根据我们声明的修饰自动插入合适的retain&#x2F;release&#x2F;autorelease等</p><ul><li>__strong：默认行为，持有引用，可以修饰变量和类成员变量</li><li>__weak：需要显式写出，不持有引用，主要用于解决循环引用问题</li><li>__unsafe_unretained:和__weak一样，不持有引用，但是不安全，不会自动设置为nil（为什么需要这个修饰符呢？有时是为了一些性能优势，有时是为了与C交互不得不使用）</li><li>__autoreleasing：表示会自动加入到pool中，但是一般也不用显式写出，因为：<ul><li>当对象作为返回值时，自动添加到pool中</li><li>当使用weak变量是，如果变量不为nil，则会先将其加入到pool中，防止使用时被销毁</li><li>当使用对象指针是，也会被自动加上该修饰符，比如NSError*<em>，实际就是NSError * (__autorelease</em>),表示这个指针中存放了一个指针p，p引用的对象应该需要被加入到pool中，因为p所引用的error并不是自己创建的，而是别人创建的。所以当将一个对象指针的地址赋给一个双重指针时，需要显示的写出修饰符，不然因为默认修饰符是autorelease而出现不匹配而报错。但其实我们可以传递一个strong修饰的变量给到autorelease修饰的参数，实际上这是编译器帮我们作了一次转换</li></ul></li><li>ARC有效的情况下：<ul><li>如需将ARC的对象给到C结构体成员，需要转换为修改为_unsafe_unretained或者转换为void *</li><li>如需转换id和void *:使用__brigde，但是这种直接转换没有任何内存管理语义<ul><li>__brigde_reatined:将oc对象转换为c对象，实际就是编译器为我们额外插入了一次retain，保证c在使用时该对象还没被释放，<strong>oc作用域还没结束时引用计数会多个1</strong>，oc作用域结束后，引用计数仍然为1，<strong>必须调用CFRelease手动释放</strong></li><li>__bridge_transfer:将c对象转换为oc对象，实际就是编译器先retatin，然后额外进行了release，保证c中看上去已经释放了，完全由oc托管，<strong>转换前后引用计数保持不变</strong>，即将内存管理职责交给了oc</li><li>注意这种转换只适合OC和CoreFoundation中的类，普通的C结构体是不行的（因为根本就没有retain&#x2F;release这些…)</li><li><strong>注意将c对象直接通过bridge转换给到oc的__strong，会发生默认的retain，可能造成内存泄漏（这里说的内存泄漏是指忘记对cf对象调用cfrelease的情况）；而如果直接通过brigde将oc转换为c，则oc作用域结束时，对象会被销毁，会发生bad access</strong>，所以必须正确使用__brigde_xxx和CRXXX才能正确转换避免内存错误</li><li>总结下必须手动调用cfrelease的情况：1.通过__bridge_retined将oc转换为cf 2.通过__bridge将c转换为oc的__strong，释放的目的都是为了防止内存泄漏</li></ul></li></ul></li></ul></li><li><p>属性和修饰符有着对应关系：</p></li></ul><pre><code class="Objective-C">assign -&gt; __unsafe_unretainedcopy -&gt; __strong，并且调用copyretain -&gt; __strongusafe_unretained -&gt; __unsafe_unretainedweak -&gt; __weak</code></pre><p>需要注意，关联的属性和类成员变量必须修饰符相同</p><ul><li>当与C数组结合使用时：<ul><li>当静态数组中存放oc对象的引用时，oc对象会随着数组的释放而释放，静态数组是分配在栈上的，编译器知道何时释放</li><li>当动态数组中存放oc对象的引用时，需要我们手动将数组中的指针赋值为nil，动态数组的实际内存时在堆上的，编译器无法知道何时释放（所以最好不要使用动态数组存放oc对象）</li></ul></li></ul><h2 id="ARC的实现"><a href="#ARC的实现" class="headerlink" title="ARC的实现"></a>ARC的实现</h2><ul><li>__strong:<ul><li>对于alloc这些方法，只是在作用域末尾插入了release</li><li>对于非alloc这些方法获取的对象，理论上会将对象加入到pool中，但实际上，编译器会做以下优化：<ul><li>调用方通过objc_retainAutoreleasedReturnValue(obj)尝试retain，他能够处理没有加入到pool的对象，并在作用域末尾插入release</li><li>被调用函数的内部返回的是objc_autorelaeseReturnValue(obj),该函数会检查调用方是否随后会调用objc_retainAutoreleasedReturnValue，如果是，则不将objc添加到pool，而是直接传递</li><li>通过这两个函数的协作，可以省去将obj添加到pool的成本</li></ul></li></ul></li><li>__weak:<ul><li>首先调用objc_initweak(&amp;weakObj, strongObj)实际就是objc_storeweak(&amp;weakObjc, strongObj),超出作用域之后，调用objc_destroyweak(&amp;weakObj),实际就是objc_storeweak(&amp;weakObj, 0)</li><li>objc_storeweak会将strongObj的地址作为key，weakObj的地址作为值，存到weak表中，若strongObj为0，则从表中删除该weakObj</li><li>大致结构类似strongObj -&gt; [weakObj1, weakObjc2….]</li><li>weak表和引用计数表类似，都是hash表，所以通过该表，在strongObj被销毁时，能快速找到所有的weak变量设置为nil</li><li><strong>oc对象被销毁时，会从weak表中找到对应weak变量设置为nil，然后从weak表中删除该项，最后从引用计数表中删除该项</strong></li><li>在使用weak变量时，编译器会插入objc_loadWeakRetained(obj),取出对应对象，然后插入objc_autorlease,将其添加到pool中，防止在作用域内使用时被释放，注意每使用一次，都会插入一次，那么在作用域内频繁使用weak对象，就会频繁被添加（同一个对象可以被多次添加到pool中）</li><li><strong>所以，最好在取得weak之后，将其赋值给strong变量，防止产生大量的autorelease对象</strong></li><li>有的类重写了retain&#x2F;release,从而不支持weak，比如NSMachPort</li></ul></li><li>__autorleasing:就是插入objc_autorelease(obj)注册到pool</li><li>获取引用计数：_objc_rootRetainCount，但是该函数不可信</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>OC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-互用性</title>
    <link href="/2023/12/31/swift-advance-interop/"/>
    <url>/2023/12/31/swift-advance-interop/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>所谓互用性，也称为互操作性，大白话就是Swift如何和其他编码语言的二进制进行交互调用。Swift的强大之处在于，可以方便的和OC、C混用。</p><h2 id="封装一个用C编写的程序库"><a href="#封装一个用C编写的程序库" class="headerlink" title="封装一个用C编写的程序库"></a>封装一个用C编写的程序库</h2><ul><li>设置包管理器：<ul><li>brew install cmark: 安装cmark</li><li>创建SwiftPM项目目录：swift package init –type executable</li><li>如何找到cmark库<ul><li>需要按照clang moudule格式使用module map封装cmark为module</li><li>需要在Package.swift中定义一个.systemLibaryay target，标志由系统包管理器，如apt、homebrew提供的库，并将其添加到主target的依赖中</li><li>那么创建一个目录，包含shime.h，其中包含cmark.h，module map文件中指定header为shime.h，并link cmark二进制</li><li>然后就可以在Swift中调用了</li></ul></li></ul></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">import</span> PackageDescription<br><span class="hljs-keyword">let</span> package <span class="hljs-operator">=</span> <span class="hljs-type">Package</span>(<br>    name: <span class="hljs-string">&quot;CommonMarkExample&quot;</span>,<br>    dependencies: [],<br>    targets: [<br>        .executableTarget(<br>            name: <span class="hljs-string">&quot;CommonMarkExample&quot;</span>,<br>            dependencies: [<span class="hljs-string">&quot;Ccmark&quot;</span>]),<br>        .systemLibrary(<br>            name: <span class="hljs-string">&quot;Ccmark&quot;</span>,<br>            pkgConfig: <span class="hljs-string">&quot;libcmark&quot;</span>,<br>            providers: [<br>                .brew([<span class="hljs-string">&quot;cmark&quot;</span>]),<br>                .apt([<span class="hljs-string">&quot;cmark&quot;</span>]),<br>        ]),<br>    ]<br>)<br></code></pre></td></tr></table></figure><ul><li>封装CmmonMark程序库<ul><li>Swift在调用是，会将c的数据类型转换为Swift数据类型</li><li>注意在调用后，需要手动free c返回的数据对象</li></ul></li><li>对于不透明指针，Swift使用OpaquePointer</li><li>对于C枚举，Swift使用struct表示，而对于OC的NS_Enum会转换为Swift Enum</li></ul><h2 id="底层类型概览"><a href="#底层类型概览" class="headerlink" title="底层类型概览"></a>底层类型概览</h2><ul><li>含有managed表示内存时自动管理</li><li>含有unsafe表示安全性需要自己保证，不提供内存管理，需要手动管理</li><li>含有buffer表示作用于连续内存上的多个元素而非单一元素</li><li>含有pointer表示具有指针语义</li><li>含有raw表示无类型原始数据，等价于void*</li><li>含有mutable表示允许修改指向的内存</li><li>指针：<ul><li>UnsafePointer等价于const int*，即不能修改指针指向的内存</li><li>const int *p,const修饰指向的内容，指向的内容不可变</li><li>int *const p,const修饰指针，指针不可变，指向的内容可变</li><li>使用可选值代表空指针</li></ul></li></ul><h2 id="闭包用作C的回调函数"><a href="#闭包用作C的回调函数" class="headerlink" title="闭包用作C的回调函数"></a>闭包用作C的回调函数</h2><ul><li>只允许向C函数指针传递不捕获任何外部变量的block或者函数，使用@convention(C)告知编译器，因为C函数指针时静态的，但是Swift闭包本质上可以理解为一个带有上下文和函数的结构体</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-编码和解码</title>
    <link href="/2023/12/31/swift-advance-encode-decode/"/>
    <url>/2023/12/31/swift-advance-encode-decode/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>和别的语言序列化的概念相似，Swift中定义了Codeable协议，其实际就是Decodeable&amp;Encodeable。标准库所有基本类型都实现了Codeable，如果struct和class内部属性都满足Codeable，则编译器可以自动生成其Codeable实现。</p><h2 id="一个最小的例子"><a href="#一个最小的例子" class="headerlink" title="一个最小的例子"></a>一个最小的例子</h2><ul><li>当strcut中的成员都是Codeable时，编译器可以自动生成Codeable实现，我们只要声明Codeable即可</li><li>编码：Swift自带JSONEncoder和PropertyListEncoder，可以将Codeable转换为对应数据，不同的encoder返回的数据格式是不同的</li><li>解码：将编码之后的数据传递给decoder，从而重新创建出实例</li><li>自定义编码格式：如果不自定义，那么编码后的数据格式完全由编码器的默认实现决定，比如Double就是json中的浮点。如果想要让Double编码为字符串，我们可以实现一个自定义的@propertyWrapper，让其符合Encodeable，然后自己实现encode和init(from decoder)方法<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">@propertyWrapper</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CodedAsString</span>: <span class="hljs-title class_">Codable</span> &#123;<br>    <span class="hljs-keyword">var</span> wrappedValue: <span class="hljs-type">Double</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">wrappedValue</span>: <span class="hljs-type">Double</span>) &#123;<br>        <span class="hljs-keyword">self</span>.wrappedValue <span class="hljs-operator">=</span> wrappedValue<br>    &#125;<br>    <br>    <span class="hljs-comment">// 自定义属性解码</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">from</span> <span class="hljs-params">decoder</span>: <span class="hljs-type">Decoder</span>) <span class="hljs-keyword">throws</span> &#123;<br>        <span class="hljs-keyword">let</span> container <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> decoder.singleValueContainer()<br>        <span class="hljs-keyword">let</span> str <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">String</span>.<span class="hljs-keyword">self</span>)<br>        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> value <span class="hljs-operator">=</span> <span class="hljs-type">Double</span>(str) <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 抛出错误</span><br>        &#125;<br>        wrappedValue <span class="hljs-operator">=</span> value<br>    &#125;<br>    <br>    <span class="hljs-comment">// 自定义属性编码</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">encode</span>(<span class="hljs-params">to</span> <span class="hljs-params">encoder</span>: <span class="hljs-type">Encoder</span>) <span class="hljs-keyword">throws</span> &#123;<br>        <span class="hljs-keyword">var</span> container <span class="hljs-operator">=</span> encoder.singleValueContainer()<br>        <span class="hljs-keyword">try</span> container.encode(<span class="hljs-type">String</span>(wrappedValue))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="编码过程"><a href="#编码过程" class="headerlink" title="编码过程"></a>编码过程</h2><ul><li>实际是每个被编码的值调用自身的encode方法，传递对应的Encoder实例进行编码</li><li>容器：先看下Encoder协议<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">/// 一个可以把值编码成某种外部表现形式的类型。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Encoder</span> &#123;<br>    <span class="hljs-comment">/// 编码到当前位置的编码键 (coding key) 路径</span><br>    <span class="hljs-keyword">var</span> codingPath: [<span class="hljs-type">CodingKey</span>] &#123; <span class="hljs-keyword">get</span> &#125;<br>    <span class="hljs-comment">/// 用户为编码设置的上下文信息。</span><br>    <span class="hljs-keyword">var</span> userInfo: [<span class="hljs-type">CodingUserInfoKey</span> : <span class="hljs-keyword">Any</span>] &#123; <span class="hljs-keyword">get</span> &#125;<br>    <span class="hljs-comment">/// 返回一个容器，用于存放多个由给定键索引的值。</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">container</span>&lt;<span class="hljs-type">Key</span>: <span class="hljs-type">CodingKey</span>&gt;(<span class="hljs-params">keyedBy</span> <span class="hljs-params">type</span>: <span class="hljs-type">Key</span>.<span class="hljs-keyword">Type</span>)<br>    -&gt; <span class="hljs-type">KeyedEncodingContainer</span>&lt;<span class="hljs-type">Key</span>&gt;<br>    <span class="hljs-comment">/// 返回一个容器，用于存放多个没有键索引的值。</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">unkeyedContainer</span>() -&gt; <span class="hljs-type">UnkeyedEncodingContainer</span><br>    <span class="hljs-comment">/// 返回一个适合存放单一值的编码容器。</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">singleValueContainer</span>() -&gt; <span class="hljs-type">SingleValueEncodingContainer</span><br>&#125;<br></code></pre></td></tr></table></figure>为每个要编码的值创建一个编码容器，保证每个值不会覆盖彼此，有三种类型的容器：<ul><li>keyed contianer：用于编码键值对，可以看做是个特殊的dict</li><li>unkeyed container：编码值，不需要key，可以懒做是编码结果数组</li><li>single value container：对单一值编码，处理由单个属性定义的类型，如Int<br>每种容器都对应一个协议，约束容器应该如何接受值并进行编码，以single value container举例：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">SingleValueEncodingContainer</span> &#123;<br>    <span class="hljs-comment">/// 编码到当前位置的编码键路径。</span><br>    <span class="hljs-keyword">var</span> codingPath: [<span class="hljs-type">CodingKey</span>] &#123; <span class="hljs-keyword">get</span> &#125;<br>    <span class="hljs-comment">/// 编码空值。</span><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">encodeNil</span>() <span class="hljs-keyword">throws</span><br>    <span class="hljs-comment">/// 编码原始类型的方法</span><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">encode</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">value</span>: <span class="hljs-type">Bool</span>) <span class="hljs-keyword">throws</span><br>    <span class="hljs-comment">/// TL;DR</span><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">encode</span>&lt;<span class="hljs-type">T</span>: <span class="hljs-type">Encodable</span>&gt;(<span class="hljs-keyword">_</span> <span class="hljs-params">value</span>: <span class="hljs-type">T</span>) <span class="hljs-keyword">throws</span><br>&#125; <br></code></pre></td></tr></table></figure>可以看到，如果是单个简单类型的值，直接调用对应函数，如果不属于这个简单类型，那么则调用该对象的encode(to:)递归。其他两种类型的容器也是和single value container有类似的结构，但是具备更多的能力，比如可以创建嵌套容器，具体使用哪个，取决于类型实现者自己。比如数组既可以调用single value container，也可以使用unkeyed container，显然后者更佳。</li></ul></li><li>总结下：编码器提供底层编码能力，被编码的类型自己调用编码器去编码。</li></ul><h2 id="合成的代码"><a href="#合成的代码" class="headerlink" title="合成的代码"></a>合成的代码</h2><ul><li>当编译器自己合成Codeable方法时，其实现时什么<ul><li>首先，会生成一个枚举CodingKeys，用来表示内部的属性，该enum符合CodingKey协议，该协议允许使用String和Int转换</li><li>encode：使用一个keyed container，将属性分别encode并放到container中，最终的结果是递归的</li><li>init方法：同样先获取keyed container，然后递归调用decode获得属性值并最终创建自身</li></ul></li></ul><h2 id="手动遵守协议"><a href="#手动遵守协议" class="headerlink" title="手动遵守协议"></a>手动遵守协议</h2><ul><li>如果不想使用编译器生成的Codeable方法，可以自己实现</li><li>自定义CodingKeys：<ul><li>实现键的重命名：将对应case的rawValue修改为指定值</li><li>不含某个case：编码时将跳过对应属性</li></ul></li><li>自定义encode和init<ul><li>比如处理json字符串中缺失某个字段</li><li>但是这也反应了一个问题，就是对于非正常值的处理，使用编码系统还是不够灵活和普适合，但是，理想情况下是要求server返回正确的数据，但是因为在实际工作中总是有各种各样的case，所以一般还是手动解析更多</li></ul></li></ul><h2 id="常见的编码任务"><a href="#常见的编码任务" class="headerlink" title="常见的编码任务"></a>常见的编码任务</h2><ul><li>编码非自己的类型：可以自定义encode或者封装嵌套实现，但是不能直接通过extension别人的类型为Codeable，或者使用计算属性来动态创建非Codeable的类型</li><li>让类满足Codable：对值来说，很简单，直接符合Codeable，但是对于类来说，不能通过extension的方式追加Codeable（required方法不能添加到extension中，required表示所有子类都要实现，所以required方法能被动态派发，所以必须在编译期间检查创建，而不不能通过事后extension的方式创建）。我们可以通过变通的方法，比如使用可Codeable的类型，然后动态创建出非Codeable的类型</li><li>解码多态的集合：比如数组中包含多个UIView的子类型，但是解码时我们只能将其解码为固定的UIView类型，实际上这种情况我们只能case by case解决，因为要保证类型安全，否则就有可能创建意外类型的对象</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-错误处理</title>
    <link href="/2023/12/30/swift-advance-error-handle/"/>
    <url>/2023/12/30/swift-advance-error-handle/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>错误处理很枯燥，错误处理也很重要，skr~</p><h2 id="错误分类"><a href="#错误分类" class="headerlink" title="错误分类"></a>错误分类</h2><ul><li>预期中的error，如网络连接失败<ul><li>可忽略的eror：如字典中key不存在，一般这种返回可选值更好</li><li>需提供详细信息的error：如网络失败，需要网络失败的类型<br>-非预期的error：如数组越界</li></ul></li></ul><h2 id="Result类型"><a href="#Result类型" class="headerlink" title="Result类型"></a>Result类型</h2><ul><li>实际就是个enum<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;<span class="hljs-title class_">Success</span>, <span class="hljs-title class_">Failure</span>: <span class="hljs-title class_">Error</span>&gt; &#123;<br>    <span class="hljs-keyword">case</span> success(<span class="hljs-type">Success</span>)<br>    <span class="hljs-keyword">case</span> failure(<span class="hljs-type">Failure</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="抛出和捕获"><a href="#抛出和捕获" class="headerlink" title="抛出和捕获"></a>抛出和捕获</h2><ul><li>函数后使用throws表示函数可能抛出错误，调用时需要加try</li><li>任意类型都可以是Error类型，Error类型实际就是个标记类型</li><li>使用do…catch…捕获error</li><li>本质上，抛出error就是创建result，只不过编译器帮我们完成了</li></ul><h2 id="具体类型error和无类型error"><a href="#具体类型error和无类型error" class="headerlink" title="具体类型error和无类型error"></a>具体类型error和无类型error</h2><ul><li>throw属于无类型error，因为我们并不能穷举所有error类型，大多数情况下也没有必要</li><li>Result属于具体类型error</li></ul><h2 id="不可忽而略的error"><a href="#不可忽而略的error" class="headerlink" title="不可忽而略的error"></a>不可忽而略的error</h2><ul><li>相比于Result，当使用throws，编译器强制我们进行处理</li></ul><h2 id="错误转换"><a href="#错误转换" class="headerlink" title="错误转换"></a>错误转换</h2><ul><li>try?可以将throws转换为可选值，但是会丢失error信息</li><li>try!表示如果throw，直接崩掉</li><li>Result提供了api将可throw的代码封装为Result，很简单，就是内部catch</li></ul><h2 id="错误链"><a href="#错误链" class="headerlink" title="错误链"></a>错误链</h2><ul><li>throws链：只要有一个函数throw，那么整个函数都会throw</li><li>result链：略，比较复杂，并且没啥用</li></ul><h2 id="错误和回调"><a href="#错误和回调" class="headerlink" title="错误和回调"></a>错误和回调</h2><ul><li>回调不兼容throws，而是只能使用回调Result结果</li></ul><h2 id="使用defer进行清理"><a href="#使用defer进行清理" class="headerlink" title="使用defer进行清理"></a>使用defer进行清理</h2><ul><li>类似于finally，但可以使用在任何地方</li><li>多个defer执行的顺序取决于声明顺序逆序，可以认为是个栈</li><li>defer发生在return的求值之后，在实际return之前</li></ul><h2 id="Rethrows"><a href="#Rethrows" class="headerlink" title="Rethrows"></a>Rethrows</h2><ul><li>如果将一个函数标记为throws，则任何调用的地方都必须加try</li><li>可以将函数标记为rethrows，这时，只有其参数是throws标记时，他才是throws的</li></ul><h2 id="将错误桥接到OC"><a href="#将错误桥接到OC" class="headerlink" title="将错误桥接到OC"></a>将错误桥接到OC</h2><ul><li>Swift将OC中接受NSError**的函数姿容转换为throws的版本</li><li>Swift的Error将会转换为NSError</li><li>LocalizedError协议：提供本地化信息表示</li><li>RecoverableError：描述用户可恢复的错误</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-并发</title>
    <link href="/2023/12/30/swift-advance-concurrency/"/>
    <url>/2023/12/30/swift-advance-concurrency/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Swift 5.5引入了async&#x2F;await特性，类似于go的go func。本质上是用户级线程，即在线程之上又抽象了自己的任务调度。</p><h2 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async&#x2F;Await"></a>Async&#x2F;Await</h2><ul><li>之前，一般通过回调编写异步代码，缺点就是有可能导致深度嵌套，可读性差，并且，也无法使用Swift的错误处理和defer</li><li>每个await都有可能导致任务被suspend，在await的函数返回之后再执行之后的代码</li><li>Swift的编发模型称为协同式多任务，函数是自愿暂停并且只在await才能暂停</li><li>被暂停的函数<strong>再继续后可能在和原先不同的线程上执行</strong>，所以在函数中执行和线程相关的代码时要小心，如thread local变量需要修改为task local变量</li><li>适合io密集型任务</li><li>支持cancel，但是这个cancel只是标记了一个flag，具体是否结束任务需要自行决定，这也是协作式的一种表现</li><li>每次await都会创建一个异步作业，两个个await之间的代码是同步执行的</li><li>但有时多个作用会被合并，也就是说，虽然await创建了一个新任务，但是实际情况该任务可能和await之前的任务一起是同步执行的，所以await是<strong>潜在</strong>的暂停，不一定是必然暂停</li><li>可将将异步回调通过withCheckedThrowingContinuationg封装为async函数，checked表示运行时会进行检查，确保回调仅调用1次</li><li>withXXXContinuation除了用来封装异步回调，本质上，允许我们手动暂停任务，并在之后恢复</li><li>async方法需要标记为@objc才能被oc通过回调方式调用</li></ul><h2 id="结构化并发"><a href="#结构化并发" class="headerlink" title="结构化并发"></a>结构化并发</h2><ul><li>task是Swift并发模型的基本执行上下文，每个async函数都位于一个task中</li><li>task中遇到await，可能暂停，将控制权交还给调度器，再次调度后可能位于不同的线程上执行</li><li>await调用async函数，被调用函数和调用者属于同一个task，想要创建新任务，需要进行明确的动作<ul><li>子任务：async let，高招属性结构组织，有作用域和生命周期</li><li>非结构化任务：单独的任务，称为独立任务树的根节点，调用Task或者Task.detached创建非结构化任务</li></ul></li><li>任务树中<ul><li>子任务相互之间可以并发运行</li><li>子任务生命周期不能超过父任务，父任务需要等待所有子任务完成才退出</li><li>取消从父任务传递给子任务</li><li>子任务继承父任务优先级和任务本地值</li></ul></li><li>async let：使用该语法创建子任务，会立即执行，没有被await的async let将会在作用域结束后隐式被cancel并且await，只是因为必须保证子任务有机会退出</li><li>任务组在正常退出时，不会隐式cancel和await</li><li>async let即使包含多个异步调用，也只会创建一个任务</li><li>async let是在编译期间确定了子任务数量，如果想要运行时动态添加子任务，则需要任务组</li></ul><h2 id="任务组"><a href="#任务组" class="headerlink" title="任务组"></a>任务组</h2><ul><li>提供动态数量的子任务</li><li>使用withTaskGroup和withThrowingTaskGroup创建任务组</li><li>一些规则：<ul><li>子任务结果按照完成顺序传递</li><li>子任务结果类型需要完全相同</li><li>子任务声明周期不能超过任务组闭包范围</li><li>如果在退出任务组闭包时仍然有未经等待的子任务，运行时会在继续前隐式等待这些任务直到结束并丢弃结果，注意不会自动cancel</li><li>任务组不会限制并发数量</li></ul></li><li>传递给任务组的参数闭包类型是@Sendable修饰的，这个注解表示多任务执行该代码是安全的，即并发安全，即代码中不会引起race condition<ul><li>@Sendable捕获的值自己需要是Sendable的</li><li>Sendable是个空协议，即标记协议</li><li>非public的struct和enum，只要其成员是Sendable，则本身也是Sendable</li><li>Actor默认是Sendable</li><li>对于没有标记为final的class，编译器无法保证是Sendable，但是我们可以通过修饰@uncheckSendable告知编译器，安全性由开发者保证</li><li>虽然Swift闭包默认将捕获作为引用，但@Sendable中需要将捕获变量作为值处理，这也是保证安全性的手段</li><li>目前来说，@Sendable编译器还无法保证完全的安全，还处在不断的完善中</li></ul></li><li>取消是协作式的，即需要任务自己检查取消状态并执行相应逻辑，可以执行Task.checkCancellation让取消时抛出error</li><li>大部分情况下，我们调用系统异步函数时无需自己检查cancel，然是如果我们自己实现一个耗时任务，还是需要的</li><li>如果一个任务被取消，应该抛出error</li><li>当任务组被cancel时，子任务也会被canel</li><li>可以使用withTaskCancellationHandler为取消设置回调函数</li><li>可以使用Task.init开启独立任务，该任务会立即开始，并且称为一个新的任务树的根节点，Task类似于js中的promise或者java中的Future</li><li>通过Task启动的非结构化任务，会继承原上下文的优先级、本地值和actor隔离域，即如果开启Task的任务是运行在actor队列中的，那么Task也是会加到该actor队列中</li><li>若不想Task在当前上下文中执行，可以使用Task.detached创建游离任务，游离任务不会继承当前任务的优先级、本地址和actor隔离</li><li>若要在非async函数中开启任务，则必须借助于Task</li><li>非结构化任务中，不会抛出错误</li></ul><h2 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h2><ul><li>无论是传统的多线程还是最近兴起的协程，都需要处理race condition问题，解决方式包括锁、串行队列等，而Swift并发使用的方案是Actor作为资源隔离机制</li><li>actor是引用类型，和声明class一样。在actor内部访问var属性是没有问题的，访问let属性更没问题（实际上，let可以跨actor也是安全的），对于方法的访问，其<strong>内部采用串行队列加以保护</strong></li><li>actor并不是将整个方法都隔离，在await之间的函数视为原子操作</li><li>actor的方法是可重入的，即一旦actor中的方法因执行async函数而不suspend时，其他方法再次调用actor中的方法时，能够在actor的队列中执行</li><li>因为actor方法是可重入的，所以不要暂停点前后的数据是有可能发生变化的</li><li>同一个任务如果执行多个actor的方法，那么会产生actor跳跃，不可避免产生开销</li><li>@MainActor，是个globalActor，使用该标记让我们的属性或者方法都运行在主线程队列中</li><li>nonisolated：将其标记为非保护</li><li>大多数情况下，@MainActor都是符合预期的，但要分3种情况<ul><li>标记async方法：没问题</li><li>标记非async方法：编译器会执行静态检查，在main actor上下文中直接调用，其他上下文需要await，但是在oc中可能失效</li><li>标记属性：同样是编译期间检查，不能在非main actor上下中访问</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-集合协议类型</title>
    <link href="/2023/12/28/swift-advance-collection-protocol/"/>
    <url>/2023/12/28/swift-advance-collection-protocol/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Swift中的集合，如Array、Dictionary、Set是建立在Swift标准库提供的协议之上的。这部分主要介绍Sequence和Collection协议，他们的关系如图：<br><img src="/../images/image-22.png" alt="Alt text"></p><ul><li>Sequence: 提供迭代方法，但是不保证能够支持多次迭代</li><li>Collection: 继承自Sequence，可以支持多次遍历，允许使用索引访问元素，通过SubSequence提供切片能力</li><li>MutableCollection:允许通过下标修改Collection，但是不允许修改元素数量</li><li>RangeReplaceableCollection: 提供替换集合中连续区间中的元素，进而支持插入、删除</li><li>BidirectionalCollection：提供双向遍历能力</li><li>RandomeAccessCollection：继承自BidirectionalCollection，保证计算索引和移动索引位置都是常数时间操作</li><li>LazySequenceProtocol: 只有在开始遍历是才计算其中元素的序列</li><li>LayzCollectionProtocol：和LazySequenceProtocol类似，只不过额外支持Collection的能力</li></ul><h2 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h2><ul><li>Sequence代表一系列相同类型的值</li><li>支持使用for进行迭代<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Sequence</span> &#123;<br>    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Element</span><br>    <span class="hljs-comment">// 约束迭代器的元素类型和自身元素类型一致</span><br>    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Iterator</span>: <span class="hljs-type">IteratorProtocol</span> <span class="hljs-keyword">where</span> <span class="hljs-type">Iterator</span>.<span class="hljs-type">Element</span> <span class="hljs-operator">==</span> <span class="hljs-type">Element</span><br>    <span class="hljs-comment">// 必要方法，获取迭代器</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeIterator</span>() -&gt; <span class="hljs-type">Iterator</span><br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>迭代器的作用：每次生成一个值并管理迭代状态<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">IteratorProtocol</span> &#123;<br>    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Element</span><br>    <span class="hljs-comment">// 必要方法，next</span><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">next</span>() -&gt; <span class="hljs-type">Element</span>?<br>&#125;<br></code></pre></td></tr></table></figure></li><li>迭代器只允许单向迭代</li><li>当我们自己实现了Sequence时，就可以调用许多便捷方法了，如contains（因为Protocol对方法有默认实现）</li><li>迭代器一般是具有值语义的，即也有例外，比如AnyIterator，其内部就封装了一个类类型的迭代器，所以具有引用语义</li><li>可以通过函数闭包创建AnyIterator，并通过将其传递给AnySequence方便的创建序列，但是性能上会有所损耗</li><li>也可以通过sequence函数来方便的创建Sequence，性能也会有所损耗</li><li>注意Sequence本身并<strong>不保证能够对Sequence多次遍历的结果相同</strong>，要多次遍历，需要使用Collection</li></ul><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><ul><li>支持多次遍历并且每次遍历的结果一致</li><li>支持下标访问</li><li><strong>Collection是有限的</strong>，但是Sequence可以是无限的</li><li>Collection有关联的SubSequence，表示Collection的一个切片</li><li>自己实现Collection，略</li><li>实现的Collection可以遵守ExpressibleByArrayLiteral，这样可以方便的使用数组创建</li><li>Collection中的一些关联类型都有默认的实现，比如Indices的默认类型是DefaultIndices&lt;Self&gt;，有时通过实现自定义的关联类型，有助于性能优化，比如将DefaultIndices替换为Range，从而避免对Self的引用，从而避免在迭代时修改Collection而可能造成的额外的COW</li></ul><h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><ul><li>Index表示Collection中的位置</li><li>每个Collection都有startIndex和endIndex，注意endIndex是最后一个元素的<strong>下一个位置</strong>，也就是说endIndex实际是个终止哨岗</li><li>Index不必是Int，但必须是Comparable的</li><li>使用Index作为下标操作返回的是非可选值，因为Index必须由开发者保证是有效的</li><li>当Collection改变时，Index将会失效</li><li>Collection和其切片类型共享Index</li><li>可以调用Collection的indexAfter方法来步进Index</li><li>自定义集合Index，不一定是整数，只要实现时保证语义即可和对应方法即可</li></ul><h2 id="SubSequence"><a href="#SubSequence" class="headerlink" title="SubSequence"></a>SubSequence</h2><ul><li>Collection中有个关联类型叫做SubSequence，SubSequnce本身也是符合Collection的，默认实现时Slice&lt;Self&gt;</li><li>SubSequence和原Collection共享内部存储</li><li>为啥不叫SubCollection而是叫SubSequence呢？别问，问就是历史遗留问题（之前SubSequence是作为Sequence的关联类型的</li><li>SubSequence适合持有中间结果，因为内存开销低。但是不建议长时间持有SubSequence，可能造成内存泄漏，因为SubSequence持有了原Collection</li><li>可以将SubSequence转换为Collection以创建副本</li><li>SubSequence的默认实现时Slice类型，实际只是封装了Range+Collection</li><li>SubSequence和Collection共享Index，注意下标越界</li></ul><h2 id="专门的Collection类型"><a href="#专门的Collection类型" class="headerlink" title="专门的Collection类型"></a>专门的Collection类型</h2><ul><li>Collection协议不提供从后往前移动Index，不提供插入、删除、替换等改变Collection的操作，为此标准库提供了几种特定类型的Collection以宽展功能<ul><li>BidirectionalCollection: 支持双向遍历</li><li>RandomAccessCollection: 支持高效随机访问</li><li>MutableCollection: 支持下标赋值</li><li>RangeReplaceableCollection: 支持范围替换（进而支持插入、删除）</li></ul></li><li>BidirectionalCollection：通过index(before:)索引前移，这种能力一般来说是保证往后移动index的性能是常量级别的，基于此，该协议还提供reversed、removeLast、suffix等操作，注意reversed并不是真的将集合倒转，而是使用特定的索引从后往前遍历罢了，标准库中的大部分Collection同时也是该协议</li><li>RandomAccessCollection:支持最高效的元素存取，需要保证能够在常数时间内完成索引计算</li><li>MutableCollection: 支持原地元素修改，索引必须针对下标提供setter方法。注意该协议只支持改变元素值，但不支持修改Collection的大小和元素位置，所以满足这个协议的只有Array，而Dict、Set、String都不满足该要求</li><li>RangeReplaceableCollection: 支持添加、删除、范围替换，如String，注意该协议并非对MutableCollection的继承，两者的侧重点不一样</li><li>通过将这些一些进行组合约束，可以确保一些算法是满足语义</li></ul><h2 id="延迟序列"><a href="#延迟序列" class="headerlink" title="延迟序列"></a>延迟序列</h2><ul><li>标准库为延迟求值提供了两个协议LazySequenceProtocol和LazyCollectionProtocol</li><li>使用lazy属性，我们不需要自己实现就可以获取延迟计算的能力</li><li>LazyCollectionProtocol相比于LazySequenceProtocol，可以直接使用索引，只有在获取索引元素时，计算才会发生，而LazySequence只能依次延迟计算每个元素，也就是没有索引功能</li><li>但是使用索引未必就是常量时间的，只不过是将计算延迟罢了</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-协议</title>
    <link href="/2023/12/26/swift-advance-protocol/"/>
    <url>/2023/12/26/swift-advance-protocol/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>之前在了解泛型实现原理时，我们知道Swift的泛型使用协议的PWT来动态派发对协议函数的调用，协议和泛型一般同时出现，否则仅用泛型的功能不够强大</li><li>protocol可以被extension，只有protocol中的方法会被动态派发</li><li>被extension的protocol可以约束协议中的泛型所符合的要求来特殊化协议，称为条件化扩展，eg.<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">// 该扩展协议的含义，所有的元素都要符合Comparable</span><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Sequence</span> <span class="hljs-title class_">where</span> <span class="hljs-title class_">Element</span>: <span class="hljs-title class_">Comparable</span><br></code></pre></td></tr></table></figure></li><li>protocol可以继承</li><li>protocol可以组合</li><li>当protocol的实现依赖于其他协议，被称为条件化实现,eg.<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">// 该扩展协议的含义，当Array中元素符合Equatables时，Array才符合Equatable</span><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Array</span>: <span class="hljs-title class_">Equatable</span> <span class="hljs-title class_">where</span> <span class="hljs-title class_">Element</span>: <span class="hljs-title class_">Equatable</span><br></code></pre></td></tr></table></figure></li><li>protocol可以有多个关联类型，如Element，其表示特定类型的占位符，实现协议的特定类型需要定义该具体的类型</li></ul><h2 id="protcol目击者"><a href="#protcol目击者" class="headerlink" title="protcol目击者"></a>protcol目击者</h2><ul><li>所谓protocol目击者，可以理解为具有具体类型的类型实例方法</li><li>目击者，即witness，个人理解翻译为证明者，即向编译器证明这个类型确实实现了协议所规定的方法，也包含了实现的方法的相关信息，编译器可以通过witness拿到要调用的具体方法</li><li>swift中的协议目击者是编译器生成并自动传递的，在调用协议方法的地方，会转换为对协议目击者方法的调用</li></ul><h2 id="条件化protocol实现"><a href="#条件化protocol实现" class="headerlink" title="条件化protocol实现"></a>条件化protocol实现</h2><ul><li>其本质就是对其中的关联类型提供目击者</li></ul><h2 id="protocol继承"><a href="#protocol继承" class="headerlink" title="protocol继承"></a>protocol继承</h2><ul><li>其本质也是通过协议目击者的组合实现</li></ul><h2 id="使用protocol进行设计"><a href="#使用protocol进行设计" class="headerlink" title="使用protocol进行设计"></a>使用protocol进行设计</h2><ul><li>协议扩展功能extension protcol，可以在协议总添加方法实现调用协议所规定的方法，调用规定的方法是动态派发的</li><li>协议扩展和类型扩展可以重复定义同一个函数<ul><li>通过类型直接调用同名函数，则调用的是类型扩展中的函数</li><li>通过协议扩展中的方法调用同名函数，则调用的是协议扩展中的函数<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">DrawingContext</span> &#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">DrawingContext</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addCircle</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这是协议扩展中的addCircle&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">DrawingContext</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">drawSomething</span>() &#123;<br>        addCircle()<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SVG</span>: <span class="hljs-title class_">DrawingContext</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addCircle</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这是类型扩展中的addCircle&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> svg <span class="hljs-operator">=</span> <span class="hljs-type">SVG</span>()<br><span class="hljs-comment">// 会调用类型扩展中的addCircle</span><br>svg.addCircle()<br><span class="hljs-comment">// 调用协议扩展中的addCircle</span><br>svg.drawSomething()<br></code></pre></td></tr></table></figure></li></ul></li><li>记住：<strong>只有协议中要求的方法才能被动态派发到具体的类型的实现</strong>，而对于协议扩展中实现的方法，则不能动态派发，在编译期间就会被确定，并且是优先静态派发到协议扩展中的方法</li><li>协议的要求的方法可以有默认实现，并且可以被重写</li><li>协议可以被组合：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">typealias</span> <span class="hljs-type">Codable</span> <span class="hljs-operator">=</span> <span class="hljs-type">Decodeable</span> &amp; <span class="hljs-type">Encodable</span><br></code></pre></td></tr></table></figure></li><li>协议可以继承</li></ul><h2 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h2><ul><li>有些protocol需要约束相关类型，可以使用关联类型</li><li>使用associatedtype Element标记一个关联类型，他实际就是一个具体类型的占位符，在实现协议时需要使用typealias Element &#x3D; XXX指定这个占位符的具体类型</li><li>当编译器可以自动推断出关联的具体类型时，可以省略typealias</li><li>关联类型可以指定默认类型</li><li>等等，关联类型和泛型是不是看着很相似？确实如此，他们的区别在于，关联类型是类型设计者显式确定的，但是泛型则是调用者在调用时通过编译器创建的</li></ul><h2 id="Self"><a href="#Self" class="headerlink" title="Self"></a>Self</h2><ul><li>在协议或扩展中，Self是指实现了该协议的类型本身</li></ul><h2 id="再谈实现协议"><a href="#再谈实现协议" class="headerlink" title="再谈实现协议"></a>再谈实现协议</h2><ul><li>建议：不要让不属于你的类型去实现一个不属于你的协议，因为可能不属于你的类型的作者再会自己添加一个协议，这可能导致不符合预期</li></ul><h2 id="存在体"><a href="#存在体" class="headerlink" title="存在体"></a>存在体</h2><ul><li>严格来说，Swift中的协议不是一个特定类型，只能用来约束泛型，但实际上，使用时还是能够以类似a: P的方式声明</li><li>这个实际是编译器为我们处理了，当我们将协议当做类型使用时，<strong>编译器会创建一个包装类型，称为存在体</strong></li><li>所谓存在，就是告知你，确实存在那么一个类型符合该协议</li><li>Swift 5.6之前，使用的语法直接就是xx: P，但是Swift其实并不鼓励直接使用协议作为类型，Swift 5.6就提出了any P更加清晰的表示这是符合某个协议的类型的语义，用来取代这种隐式的表达</li><li>any P可以看做等价于Any<P>，即创建了封装任意符合协议的Any类型，这层封装称为<strong>存在体容器</strong>，由于存在体容器需要记录协议的协议目击者信息，协议方法越多，存在体容器越大</li><li>当我们使用any P的时候，我们的语义是接受<strong>任意符合P的类型</strong>，注意这里是任意，而不是特定！！！和下面的some P区分开</li><li>存在体和泛型，any P有时和T: P作用类似，但是any P的更加灵活，调用时需要借助于PWT，需要处理所有可能的实现协议的类型，所以开销也更大。而T:P编译器会有可能生成特化版本，不需要记住与PWT，性能更佳</li><li><strong>如果协议中存在对Self和关联类型的要求，则无法调用协议中对参数绑定了Self或关联类型的方法</strong>，因为存在体会抹除类型具体信息，编译器不确定传递的存在体的类型是否和实现了协议的类型的类型是一致的<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Equatable</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">==</span> (<span class="hljs-params">lhs</span>: <span class="hljs-keyword">Self</span>, <span class="hljs-params">rhs</span>: <span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-type">Bool</span><br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span>: <span class="hljs-title class_">Equatable</span> &#123;<br><br>&#125;<br><br><span class="hljs-comment">// 错误，编译器不确定lhs和rhs中的Self类型是否一致</span><br><span class="hljs-keyword">let</span> s: <span class="hljs-type">Equatable</span> <span class="hljs-operator">=</span> <span class="hljs-type">S</span>()<br></code></pre></td></tr></table></figure>这里，Equatable就无法被当做存在体类型使用，因为其方法参数中规定了Self的要求。注意，如果是返回值的类型是Self，则是可以的，编译器会将返回值类型再次打包为存在体容器。</li><li>对于Self的要求同样适合关联类型</li><li>协议不能遵守本身，所以也就无法将存在体any P传递给接受一个T:P的泛型参数,这一规则对于init方法和静态方法适用，因为这些函数隐式的接受Self为参数<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">P</span> &#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">test</span>&lt;<span class="hljs-type">T</span>: <span class="hljs-type">P</span>&gt;(<span class="hljs-params">t</span>: <span class="hljs-type">T</span>) &#123;<br>    <span class="hljs-built_in">print</span>(t)<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span>: <span class="hljs-title class_">P</span> &#123;<br>    <br>&#125;<br><br><span class="hljs-comment">// 错误： protocol type &#x27;P&#x27; cannot conform to &#x27;P&#x27;</span><br><span class="hljs-comment">// 也就是P的存在体类型不能符合P本身</span><br><span class="hljs-keyword">let</span> s1: <span class="hljs-type">P</span> <span class="hljs-operator">=</span> <span class="hljs-type">S</span>()<br>test(t: s1)<br><br><span class="hljs-comment">// 正确，传递的是结构体具体类型而非存在体类型</span><br><span class="hljs-keyword">let</span> s2: <span class="hljs-type">S</span> <span class="hljs-operator">=</span> <span class="hljs-type">S</span>()<br>test(t: s2)<br></code></pre></td></tr></table></figure></li><li>有一个特例，Error协议的存在体本身确实是遵守Error协议，但是它能作为参数传递给T: Error泛型参数，这个是编译器的白名单，由于Error是个标记协议，所以这么做不存在问题</li><li>不要过早使用存在类型，存在体类型虽然方便，但是会抹除具体类型信息，并且会导致性能开销，<strong>最好是使用代用约束的泛型</strong></li></ul><h2 id="不透明类型"><a href="#不透明类型" class="headerlink" title="不透明类型"></a>不透明类型</h2><ul><li>some P，是<strong>某个满足P的具体类型</strong>，注意这里不是任意类型，和上面的any P区分开</li><li>和any P不同，any P由于能够接受任意符合P的类型，会抹除掉具体类型的信息，而some P则会保留，只是用户无法获知而已</li><li>some P在Swift UI中大量使用，如some View。这使得深层嵌套的泛型更加容易使用并且隐藏实现细节，比如Swift UI每加一个修饰符，返回的具体类型会增加泛型的嵌套层次，显然不便于书写，同时也暴露了内部实现细节，这里用some View表示我们不care，编译器知道就好</li><li>不透明类型的规则：<ul><li>可以出现在函数的返回类型、属性、变量或者下标中</li><li>通常来说约束时协议，但也可以是具体类型，如some UIView表示任意特定的UIView子类</li><li>返回不透明类型的函数必须在所有return分支中返回相同的类型 （所以这里又不得不提到Swift UI中resultBuilder的伟大，他将分支表达式合并为相同的类型）</li><li>返回不透明类型的函数必须在每次调用时都返回相同的具体类型</li><li>可以通过动态转换还原成具体类型</li></ul></li></ul><h2 id="类型消除器"><a href="#类型消除器" class="headerlink" title="类型消除器"></a>类型消除器</h2><ul><li>在标准库中，我们可以将一个具体的Sequence类型转换为一个AnySequence型，这个AnySequence就是类型消除器，但会引入额外的开销</li><li>手动实现一个类型消除器的思路，实际就是利用泛型，创建一个只暴露内部元素泛型类型的封装类型，对协议方法的调用再内部通过方法转发到到对具体类型的调用<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">// 原始协议</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Restorable</span> &#123;<br>    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">State</span>: <span class="hljs-type">Codable</span><br>    <span class="hljs-keyword">var</span> state: <span class="hljs-type">State</span> &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>&#125;<br>&#125;<br><br><span class="hljs-comment">// 实现了协议并只关心State类型的类型的基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnyRestorableBoxBase</span>&lt;<span class="hljs-title class_">State</span>: <span class="hljs-title class_">Codable</span>&gt;: <span class="hljs-title class_">Restorable</span> &#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">init</span>() &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> state: <span class="hljs-type">State</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123;<span class="hljs-built_in">fatalError</span>()&#125;<br>        <span class="hljs-keyword">set</span> &#123;<span class="hljs-built_in">fatalError</span>()&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 上面的类型的实现子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnyRestorableBox</span>&lt;<span class="hljs-title class_">R</span>: <span class="hljs-title class_">Restorable</span>&gt;: <span class="hljs-title class_">AnyRestorableBoxBase</span>&lt;<span class="hljs-title class_">R</span>.<span class="hljs-title class_">State</span>&gt; &#123;<br>    <span class="hljs-keyword">var</span> r: <span class="hljs-type">R</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">r</span>: <span class="hljs-type">R</span>) &#123;<br>        <span class="hljs-keyword">self</span>.r <span class="hljs-operator">=</span> r<br>    &#125;<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> state: <span class="hljs-type">R</span>.<span class="hljs-type">State</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123; r.state &#125;<br>        <span class="hljs-keyword">set</span> &#123; r.state <span class="hljs-operator">=</span> newValue &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 对外暴露的类型，调用方只需要关心State类型，内部封装了上面类型的子类的实例，对协议方法的调用将被转发，外界无需关心具体类型</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AnyRestorable</span>&lt;<span class="hljs-title class_">State</span>: <span class="hljs-title class_">Codable</span>&gt;: <span class="hljs-title class_">Restorable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> box: <span class="hljs-type">AnyRestorableBoxBase</span>&lt;<span class="hljs-type">State</span>&gt;<br>    <br>    <span class="hljs-keyword">init</span>&lt;<span class="hljs-type">R</span>&gt;(<span class="hljs-params">r</span>: <span class="hljs-type">R</span>) <span class="hljs-keyword">where</span> <span class="hljs-type">R</span>: <span class="hljs-type">Restorable</span>, <span class="hljs-type">R</span>.<span class="hljs-type">State</span> <span class="hljs-operator">==</span> <span class="hljs-type">State</span> &#123;<br>        <span class="hljs-keyword">self</span>.box <span class="hljs-operator">=</span> <span class="hljs-type">AnyRestorableBox</span>(r: r)<br>    &#125;<br>    <br>    <span class="hljs-keyword">var</span> state: <span class="hljs-type">State</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> box.state &#125;<br>        <span class="hljs-keyword">set</span> &#123; box.state <span class="hljs-operator">=</span> newValue&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>当然，类型消除器也可以用any P更加方便的实现，此处略</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-泛型</title>
    <link href="/2023/12/25/swift-advance-generic-type/"/>
    <url>/2023/12/25/swift-advance-generic-type/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>泛型编程的主要目的类型安全和代码重用。泛型可以认为是多态的一种实现方式，所谓多态，就是多个类型可以调用同一个名称的接口。因为泛型只是具体类型不同，接口名称都是相同的，所以可以认为是一种多态的表现。<br>而多态其实还有其他不同的表现形式：</p><ul><li>专属多态（特设多态）：<ul><li>概念：为特定类型的任意集合定义一个共同的接口</li><li>实现1：函数重载，函数名称相同，但传入的参数类型和个数不同</li><li>实现2：协议，多个类型实现同一个协议，这是更结构化的专属多态</li></ul></li><li>子类型多态：<ul><li>概念：一个类型名称表示很多具体类型，这些类具有共同的超类</li><li>实现：同一个函数如果接受父类作为参数，那么也可以传递子类作为参数</li></ul></li><li>参数化多态：<ul><li>概念：指定一个抽象符号表示任意类型</li><li>实现：泛型，接受泛型化参数的函数称为泛型函数，泛型化的参数被称为泛型，也是下面讨论的主要部分</li></ul></li></ul><h2 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h2><ul><li>函数和方法、class、struct和enum都是泛型类型</li></ul><h2 id="泛型和Any"><a href="#泛型和Any" class="headerlink" title="泛型和Any"></a>泛型和Any</h2><ul><li>泛型相比较Any，对于编译器来说能够获得更多的信息，更加安全，但同时也会增大编译产生的体积，因为对于一个具体化的泛型类型，编译器就要生成一个类型</li><li>为每个泛型版本在调用时生成一个特定版本，这称为泛型特化，是C++的默认模板实现，但是对于Swift来说，默认不是，Swift默认是通过额外的间接层将泛型函数调用进行改造以便使其接受任意类型的，但我们可以开启Swift的编译优化选项，使其进行泛型特化</li></ul><h2 id="基于泛型的设计"><a href="#基于泛型的设计" class="headerlink" title="基于泛型的设计"></a>基于泛型的设计</h2><ul><li>主要是抽象出共同的逻辑，将具体类型给泛型化</li></ul><h2 id="泛型的静态派发"><a href="#泛型的静态派发" class="headerlink" title="泛型的静态派发"></a>泛型的静态派发</h2><ul><li>Swift支持函数重载，并且对重载函数的调用确定发生在<strong>编译期间</strong></li><li>Swift只会使用调用侧模块的可用信息来决定调用哪个版本的函数，eg.<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">format</span>&lt;<span class="hljs-type">A</span>&gt;(<span class="hljs-params">value</span>: <span class="hljs-type">A</span>) -&gt; <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-type">String</span>(describing: value)<br>&#125;<br><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">format</span>(<span class="hljs-params">value</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-string">&quot;+<span class="hljs-subst">\(value)</span>+&quot;</span><br>&#125;<br><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">process</span>&lt;<span class="hljs-type">B</span>&gt;(<span class="hljs-params">input</span>: <span class="hljs-type">B</span>) -&gt; <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> formatted <span class="hljs-operator">=</span> format(value: input)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;-<span class="hljs-subst">\(formatted)</span>-&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 这里只会调用泛型版本的函数，而不是更加具体的函数</span><br><span class="hljs-comment">// 因为函数重载发生在编译器，编译器并不确定类型是否是Int，所以只能匹配到更加宽松的版本</span><br>process(input: <span class="hljs-number">1</span>) <span class="hljs-comment">// - 1 -</span><br><br></code></pre></td></tr></table></figure></li><li>协议中的函数则是动态派发的，在运行时才决定调用哪个版本的函数</li></ul><h2 id="泛型的工作方式"><a href="#泛型的工作方式" class="headerlink" title="泛型的工作方式"></a>泛型的工作方式</h2><ul><li>Swift默认是通过间接层来实现一个可以处理任意类型</li><li>间接层需要处理的问题<ul><li>需要知道T的大小</li><li>需要知道如何复制T和销毁T（比如是否需要引用计数）</li><li>需要知道调用重载函数的地址</li></ul></li><li>间接层提供的解决方案<ul><li>Swift使用指针传递函数参数、返回值和变量</li><li>对每个泛型参数，编译器会传递T的类型元数据，包括值目击表VWT，其包含如何对T进行操作，如复制、引用计数</li><li>对T上的每个约束，传递协议目击表PWT，其作用是在运行时决定调用哪个函数，所以泛型机会都是和协议搭配使用的，否则没有PWT功能化大大降低</li></ul></li></ul><h2 id="泛型特化"><a href="#泛型特化" class="headerlink" title="泛型特化"></a>泛型特化</h2><ul><li>之前说过，泛型特化是C++模板的默认实现，但不是Swift的默实现，所以默认是存在一定运行时开销的</li><li>可以Swift -O开启编译优化，但要更好的帮助编译器需要：<ul><li>全模块优化（whole moudle optimize）： 即使开启了优化，默认也只在同一个文件中生效，如果需要整个模块生效，需要开启该选项</li><li>全模块优化还会开启一些额外的优化，如静态派发等等</li><li>将泛型函数标记@inlinable以便其他模块进行导出，这使得编译器容易发现具体类型并进行特化</li></ul></li><li>总体来看，Swift的泛型系统兼具C++的完全特化，又具有Java的只将泛型作为类型检查的能力</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-字符串</title>
    <link href="/2023/12/24/swift-advance-string/"/>
    <url>/2023/12/24/swift-advance-string/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Swift在字符串的实现上尽力去满足Unicode标准，String是Character的值的集合，而Character是人类可读的单个字符，每个Character由多个Unicode标量组成。<br>但是为了实现这种复杂性，Swift会牺牲一些便捷性，比如不能直接通过str[idx+1]访问下一个字符，并且String不支持随机访问</p><h2 id="Unicode，而非固定宽度"><a href="#Unicode，而非固定宽度" class="headerlink" title="Unicode，而非固定宽度"></a>Unicode，而非固定宽度</h2><ul><li>一切都要从Unicode开始说起<ul><li>一开始英文字符由asii码规定，只需要1个字节就可以编码，每个字符的宽度的大小固定</li><li>后来，随着计算机的普及，更多的字符需要被编码，ascii码显然就不够用了</li><li>Unicode就应运而生，他的目标是让天下没有难编码的字符！</li><li>一开始Unicode使用2字节固定宽度进行编码，称为UCS-2，后来不够用，所以现在的Unicode是可变长编码<ul><li>Unicode字符，由一个或者多个Unicode标量组成，每个字符对应一个编码点</li><li>一个Unicode标量可以被编码为多个编码单元</li><li>编码点一般使用U+前缀表示</li><li>Unicode标量在大多数情况下都和编码点相同，在Swift中用Unicode.Scalar表示</li><li>UTF8和UTF16都属于变长编码的编码方式，即每个标量编码的长度并不一致，编码方式中的最小实体称为编码单元，在Swift中用Unicode.UTF8.CodeUnit表示</li><li>单个字符在大多数情况下是由单个标量组成，也可以通过多个标量组成</li><li>总结下：1个可见字符-&gt;1个以上标量 1个标量-&gt;1个以上编码单元，如图所示<br>  <img src="/../images/image-21.png" alt="Alt text"></li></ul></li></ul></li></ul><h2 id="字位簇和标准等价"><a href="#字位簇和标准等价" class="headerlink" title="字位簇和标准等价"></a>字位簇和标准等价</h2><ul><li>标准等价：即一个可见字符可以是单个标量，也可以是多个标量的组合，对于用户来说是等价的，Swift可以正确处理，但对于OC来说，只会按照编码单元去判断</li><li>Unicode为啥要支持两种方式表示同一个字符呢：<ul><li>为了兼容之前的一些编码方式，因为有些预先组合好的字符在别的编码中已经存在了，在Unicode中需要将其视为单个字符</li><li>为了支持以灵活的方式构造展现一个字符</li><li>个人理解，预先组合的字符一定可以表示为多个标量的组合，但反之不一定，因为组合是无穷的</li><li>注意，组合不是任意的，有些标量是可以无限制被添加的，有些则不行</li></ul></li><li>对于emoj，也是Unicode标量组合形成单个字符的典型例子</li><li>那么这些字符是如何被渲染出来的，则是底层字符渲染系统的任务，如果渲染系统无法识别，则会将每个标量单独渲染出来，但是Swift仍然会将语法上有效的标量组合认为是单个字符</li><li>其实OC也有能够支持Unicode标准的api，只不过Swift支持Unicode规范是默认行为</li></ul><h2 id="String和Collection"><a href="#String和Collection" class="headerlink" title="String和Collection"></a>String和Collection</h2><ul><li>String是Character的集合,符合Collection协议</li><li>String是集合，但又不是完全的集合，它不支持随机访问，Swift实现的是BidirectionalCollection，即只能从头或从尾部进行迭代，每次迭代一个字符</li><li>String中的indices代表的是每个字符的索引集合</li><li>String不支持只通过下标修改单个字符，也就是不支持MutableCollection协议。原因说过，因为编码时可变的，替换单个字符需要移动前后的数据。但String实现了RangeReplaceableCollection协议，这允许我们进行范围替换</li></ul><h2 id="String索引"><a href="#String索引" class="headerlink" title="String索引"></a>String索引</h2><ul><li>String不允许直接使用下标索引操作，之前说过，String不能随机访问，所以访问一个字符的时间复杂度是n，所以为了防止我们写出性能糟糕的代码，Swift不支持直接使用下标访问String（个人理解，这牺牲了易用性真的得不偿失…</li><li>String采用String.Index进行索引，其本质是一个字节偏移量。刚开始拿到该字节偏移量的时间复杂度是n，但一旦拿到，则时间复杂度降低为1</li><li>通过将字符串写在#的包围中，可以不必对字符串中的引号进行转义</li></ul><h2 id="Substring"><a href="#Substring" class="headerlink" title="Substring"></a>Substring</h2><ul><li>和所有Collection一样，String有个特定的SubSequence，称为Substring,类似于ArraySlice</li><li>Substring和String的接口几乎一样，这是通过StringProtocol实现的</li></ul><h2 id="编码单元视图"><a href="#编码单元视图" class="headerlink" title="编码单元视图"></a>编码单元视图</h2><ul><li>String允许我们以Unicode标量和特定编码方式的编码单元来查看</li><li>可以直接将utf8的String传递给C函数指针，这是编译器优化过的，如果是utf16，编译器会先进行编码转换，然后传递</li><li>注意，这些视图仍然是不支持随机访问，只支持通过String.Index访问，由于String.Index一般是位于边界的，所以一般从String获取的Index用于视图上不会有啥问题，反之，如果是从视图创建一个String.Index再用于String，则可能崩溃（嘛，不一定在边界了</li></ul><h2 id="String和Foundation"><a href="#String和Foundation" class="headerlink" title="String和Foundation"></a>String和Foundation</h2><ul><li>String和NSString和无缝转换，并且如果引入了Foundation库，String可以使用NSString的api</li><li>NSString的默认编码时UTF16，而String的默认编码时UTF8，所以在调用NSString时会存在一定开销</li><li>Foundation中的CharacterSet，实际上的含义就是Unicode标量的集合，方便我们判断一个字符是否在某个特定集合中（如字母、数字）</li><li>Foundation中的一些关于NSString的api可能还不兼容Swift，需要我们手动转换，比如NSString进行正则匹配，返回的基于标量的NSRange，而swift可能并不认为这个标量在String中能独立存在，所以必须转换会Range再判断</li></ul><h2 id="Unicode属性"><a href="#Unicode属性" class="headerlink" title="Unicode属性"></a>Unicode属性</h2><ul><li>在Swift中，CharacterSet的部分功能放到了Unicode.Scalar.Properties中，比如判断是否为emoji</li><li>一些功能在Charater中也有，比如判断一个字符是否为数字</li></ul><h2 id="String和Character的内部结构"><a href="#String和Character的内部结构" class="headerlink" title="String和Character的内部结构"></a>String和Character的内部结构</h2><ul><li>String也是实现了COW的</li><li>对于长度小于16个编码单元，Swft会进行编译优化，采用内联方式存储</li><li>Character的内部实际就是长度为1的String</li></ul><h2 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h2><ul><li>String和字符串字面量是不同的，String实际上是实现了ExpressibleByStringLiteral的类型</li><li>我们可以为自己的类型实现ExpressibleByStringLiteral</li></ul><h2 id="String插值"><a href="#String插值" class="headerlink" title="String插值"></a>String插值</h2><ul><li>插值使用ExpressibleByStringInterpolation和StringInterpolationProtocol组成，而ExpressibleByStringInterpolation又继承自ExpressibleByStringLiteral</li><li>标准库中实现了一个DefaultStringInterpolation，其符合tringInterpolationProtocol，这使得我们可以直接进行字符串插值</li><li>我们可以自行实现相关协议，为我们自己的类型实现字String插值来转换为对应的对象</li></ul><h2 id="定制字符串描述"><a href="#定制字符串描述" class="headerlink" title="定制字符串描述"></a>定制字符串描述</h2><ul><li>实现CustomStringConvertible和CustomDebugStringConvertible在print时自定义输出内容</li><li>LosslessStringConvertible：继承自CustomStringConvertible，用于将字符串转换会自定义类型，但是很少使用（一般都用codeable进行序列化）</li></ul><h2 id="文本输出流"><a href="#文本输出流" class="headerlink" title="文本输出流"></a>文本输出流</h2><ul><li>print和dump默认是输出到标注输出，但实际上，只要对象支持TextOutputStream协议就可以重定向print和dump到该对象，比如String</li><li>_playgroundPrintHook是个全局变量，可以hook输出的print的内容</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-枚举</title>
    <link href="/2023/12/24/swift-advance-enum/"/>
    <url>/2023/12/24/swift-advance-enum/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>struct和class有时也被称为记录类型，一个记录是任意个属性组成。而枚举称为标签联合或变体类型，它和记录类型也一样强大。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>enum由任意个case组成，每个case有关联值</li><li>Optional和Result实际上都是枚举</li><li>枚举时值类型，和结构体类似，但是没有存储属性，我们可以将关联值视为存储属性</li></ul><h2 id="总和类型和乘积类型"><a href="#总和类型和乘积类型" class="headerlink" title="总和类型和乘积类型"></a>总和类型和乘积类型</h2><ul><li>居留元：简单理解就是一个类型的可能的取值，类型可以理解为取值的集合</li><li>strcut和class中的居留元数量，等于其成员的居留元数量的乘积，因为被称为乘积类型</li><li>enum的居留元数量，等于其所有case的累加</li></ul><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><ul><li>switch通过方便的语法，可以比较成员和提取关联值，这一机制称为模式匹配，类似于<strong>正则匹配</strong></li><li>支持的模式类型<ul><li>通配符，如_,匹配任意值并忽略</li><li>元祖模式，如case (let x, 0, _)</li><li>美爵成员模式， 如.failure(let error)</li><li>值绑定模式，如let x，注意let (x, y) &#x3D; (let x, let y)，但是let x，y则表示绑定x，并且和y进行比较</li><li>可以在绑定模式添加where限定条件，如.success(let status) where 200..&lt;300 ~&#x3D; httpStatus</li><li>如果是在单个case去匹配多个模式，则每个模式中let的数量、变量名和类型均要相同</li><li>可选值模式，let x?，即可选值x不为nil时才匹配并绑定到x</li><li>类型转换模式，let x as Type</li><li>表达式模式，将输入值和模式作为参数传递给定义在标准库中的~&#x3D;操作符进行判断，对于实现了Equatable协议的类型，~&#x3D;的默认行为是转发到&#x3D;&#x3D;</li><li>标准库为范围提供~&#x3D;的重载，可以方便的检查某个值是否在范围内</li><li>可以通过重载~&#x3D;操作符来扩展模式匹配，返回true表示匹配成功</li></ul></li><li>其他情景中的模式匹配：模式匹配并不是enum和switch的专属，我们可以在解构元祖，for循环、catch、if、guard中都可以使用。for case、while case仅在匹配成功的情况下才会执行循环体</li></ul><h2 id="使用enum进行设计"><a href="#使用enum进行设计" class="headerlink" title="使用enum进行设计"></a>使用enum进行设计</h2><ul><li>switch的完备性：即编译器保证所有的分支均能被覆盖到，否则报错</li><li>避免产生非法状态：因为enum的状态有限，每个状态都是单一的，使用enum更加能确保状态的合法性</li><li>enum是实现状态的绝佳选择：比如loading、success、failed，略</li></ul><h2 id="选择enum还是struct"><a href="#选择enum还是struct" class="headerlink" title="选择enum还是struct"></a>选择enum还是struct</h2><ul><li>enum和struct是类似的，有时都能完成相同的事情，比较如下：<ul><li>enum更精确、状态有限、可以使用switch</li><li>struct则可以方便扩展、包含私有成员</li><li>即struct相对来说扩展性更好，更灵活，但enum更加精确，更不容易出错（嘛，凡事皆有代价</li></ul></li></ul><h2 id="enum和protocol的相似之处"><a href="#enum和protocol的相似之处" class="headerlink" title="enum和protocol的相似之处"></a>enum和protocol的相似之处</h2><ul><li>都能表达<strong>某种类型之一</strong>的语义，enum是通过case，而protocol则是通过具体类型</li><li>如果我们侧重于添加成员，则用protocol更好，因为修改enum的case会破坏源码</li></ul><h2 id="使用enum实现递归数据结构"><a href="#使用enum实现递归数据结构" class="headerlink" title="使用enum实现递归数据结构"></a>使用enum实现递归数据结构</h2><ul><li>比如用enum实现树形结构</li><li>用indirect case让某个case表示为引用，indirect只能用在enum上，可以用在case前面，也可以直接加载enum前面</li><li>enum的大小是其最大case的大小+元数据，和c语言中的union及其类似，每个case的大小是其关联值的大小，但如果是indirect的，则是固定大小8（理解为指针嘛</li></ul><h2 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h2><ul><li>enum可以指定原始值类型，即每个case对应一个固定的rawValue，和关联值无关，一般就是一个整数或字符串</li><li>RawRepresentable: 该协议的方法，即init(rawValue:)，RawValue类型为String、整数、浮点类型的enum默认符合，如果需要自定义，可以显示指定enum符合该协议，自己实现init方法，但是注意<strong>rawValue必须唯一！！</strong></li><li>RawRepresentable也可以由struct和class来实现</li><li>注意rawValue并不是enum中存储的，不影响enum的大小，其更加类似于于计算属性</li></ul><h2 id="列举枚举值"><a href="#列举枚举值" class="headerlink" title="列举枚举值"></a>列举枚举值</h2><ul><li>没有关联值的enum，默认是可列举的，我们只需要将其声明为符合CaseIterable，编译器会为我们实现</li><li>CaseIterable也可以用于struct和class，我们自己实现allCases方法即可</li></ul><h2 id="固定和非固定enum"><a href="#固定和非固定enum" class="headerlink" title="固定和非固定enum"></a>固定和非固定enum</h2><ul><li>可能增加case的enum称为非固定的，为了应对以后二进制sdk中新增enum的case，我们一般需要加一个default</li><li>apple的sdk库一般都是弹性库，即可能变化，其中的enum一般都是非固定enum（Optional是个例外</li><li>@unknown default：前面的@unknown告知编译器，这个default只是为了应对为二进制sdk中了可能增加的enum的case，而如果在本次编译时就知道有些case没有处理，仍然要给我报错</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-结构体和类</title>
    <link href="/2023/12/23/swift-advance-struct-and-class/"/>
    <url>/2023/12/23/swift-advance-struct-and-class/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>结构体是值类型，类是引用类型。</p><h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><ul><li>值类型：当赋值时会被copy一份，也就是说，每个值类型变量的数据都是独立的，其变量本身的地址中存储的就是值，具有这种行为的类型称为具有<strong>值语义</strong></li><li>引用类型，变量本身的地址存储的是值的引用（可能是地址，也可能是其他的间接句柄），而非值，具有这种行为的类型称为具有引用语义</li><li>说白了还是和其他语言一样，就是直接存储值还是存储地址的区别</li></ul><h2 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h2><ul><li>对struct中的属性修改，本质是创建了一个新的struct替换了原来的struct</li><li>推荐使用var来声明struct中的属性</li><li>struct中的方法默认不能修改结构体本身，如有必要，添加mutating关键字。属性和下标的stter默认都是mutating的</li><li>调用struct的mutating方法，要求struct本身是var的。如果要调用一个let的struct属性setter，可以将该setter标记为nonmutating set，告知编译器该setter不会修改struct</li><li>inout参数：实际的过程是先copy参数，然后修改参数，最后用修改完的参数覆盖原来的值。编译器有时会将这种行为优化为传递引用，但不要依赖这种行为。并且，如果使用了观察者，则无论在函数中修改了多少次，只会在最终被覆盖的时候得到通知</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li>结构体的生命周期很简单，就是含有结构体实例变量的生命周期一致，一旦离开作用域就会被销毁</li><li>类的生命周期，取决于ARC</li><li>由于结构体不存在引用，所以也就无所谓结构体的循环引用问题</li><li>打破类的循环引用，weak或unowned</li><li>unowened实际的作用就是不持有引用，所以允许我们声明为非可选值，而weak引用必须声明为可选值。但是<strong>unowned不安全</strong>，如果释放之后再访问unowned会崩溃（是runtime崩溃，而不是badaccess崩溃，类似于断言）！！！虽然这里Swift只要unowned引用还存在，对象内存就不会释放，但是会标记为无效，即所谓僵尸内存</li><li>Swift中，类不是唯一的引用类型，actor以及函数（包括闭包表达式&amp;方法）都是引用类型</li><li>捕获列表，实际就是常用的在闭包中使用的[weak self]，但是捕获列表中还可以直接创建变量，例如<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Swift">window<span class="hljs-operator">?</span>.onRotate <span class="hljs-operator">=</span> &#123; [<span class="hljs-keyword">weak</span> view, <span class="hljs-keyword">weak</span> myWindow<span class="hljs-operator">=</span>window, x<span class="hljs-operator">=</span><span class="hljs-number">5</span><span class="hljs-operator">*</span><span class="hljs-number">5</span>] <span class="hljs-keyword">in</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="在struct和class中做选择"><a href="#在struct和class中做选择" class="headerlink" title="在struct和class中做选择"></a>在struct和class中做选择</h2><ul><li>结构体的优点是开销小，不用担心循环引用、多线程、继承问题，缺点不如类具有共享的特性</li><li>类则更加灵活和强大，可以使用类实现结构体的值语义，反之则不行</li></ul><h2 id="具有值语义的类"><a href="#具有值语义的类" class="headerlink" title="具有值语义的类"></a>具有值语义的类</h2><ul><li>我们可以final class，并将其中的属性都声明为let来实现值语义（嘛，这显然没有结构体好用</li></ul><h2 id="具有引用语义的结构体"><a href="#具有引用语义的结构体" class="headerlink" title="具有引用语义的结构体"></a>具有引用语义的结构体</h2><ul><li>可以在struct中使用类属性实现引用语义</li><li>所以在strcut中使用类属性要小心，不然可能会意外修改其值语义</li><li>这种设计可以被用于实现COW，见下</li></ul><h2 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h2><ul><li>即COW，实际的意思就是修改时才发生真正的复制，很常见的优化</li><li>自己实现COW，我们需要知道一般的实现原理：在没有发生修改之前，各变量都持有的值的内部都共享一份引用，如果一旦发生修改内部共享存储的行为（调用了set方法或者其他什么的），就将原来的内部共享存储进行copy，修改该copy属性</li><li>查询Swift的引用类型是否只有一个持有者：isKnownUniquelyReferenced，但是注意该函数不是线程安全的，所以多线程对数组append是非线程安全的，该函数的参数是个inout参数，否则在传递参数的时候肯定会进行一次引用，函数功能就失效了<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">HTTPRequest</span> &#123;<br>    <span class="hljs-comment">// 内部判断是否触发copy以实现COW</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> storageForWriting: <span class="hljs-type">HTTPRequest</span>.<span class="hljs-type">Storage</span> &#123;<br>        <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-operator">!</span><span class="hljs-built_in">isKnownUniquelyReferenced</span>(<span class="hljs-operator">&amp;</span>storage) &#123;<br>            <span class="hljs-keyword">self</span>.storage <span class="hljs-operator">=</span> storage.copy()<br>            &#125;<br>            <span class="hljs-keyword">return</span> storage<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> path: <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123; storage.path &#125;<br>        <span class="hljs-keyword">set</span> &#123; storageForWriting.path <span class="hljs-operator">=</span> newValue &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> headers: [<span class="hljs-type">String</span>: <span class="hljs-type">String</span>] &#123;<br>        <span class="hljs-keyword">get</span> &#123; storage.headers &#125;<br>        <span class="hljs-keyword">set</span> &#123; storageForWriting.headers <span class="hljs-operator">=</span> newValue &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>注意willSet会导致COW性能的破坏，因为如果实现了willSet，则编译器在设置新值之前一定会先创建值，那么会导致值中的共享存储的引用增加，导致判断失效，导致必然发生复制</li><li>在SwiftUI中，由于@Pushlied使用了willSet，所以会造成一些性能问题，每次修改@Published属性，都会导致数组的copy</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-属性</title>
    <link href="/2023/12/23/swift-advance-property/"/>
    <url>/2023/12/23/swift-advance-property/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Swift属性分为存储属性和计算属性，属性可以被看做是一种定义在类型上的变量。</p><h2 id="变更观察者"><a href="#变更观察者" class="headerlink" title="变更观察者"></a>变更观察者</h2><ul><li>为属性和变量实现willSet和didSet方法</li><li>观察方法必须在声明属性时就进行定义，而不能在扩展中添加。注意和OC中KVO不同。KVO是外部用来跟踪对象内部变化的手段</li><li>观察者可以在子类中重写属性以实现观察者</li><li>Swift的观察者是纯编译时特性，而KVO则是OC利用runtime实现的动态特性</li></ul><h2 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h2><ul><li>使用lazy var修饰，只有当第一次使用时才会被创建（仅调用1次）</li><li>扩展中只能声明计算属性，不能声明存储&amp;延迟存储属性</li><li>lazy var是mutating性质的，所以如果访问结构体的延迟存储属性，必须将结构体声明为var，所以通常不要在结构体中声明lazy var</li><li>注意，<strong>lazy var存在线程安全问题，多线程情况下可能会被调用多次！！！</strong>，在oc中，懒加载属性实行可能会在多线程情况下造成崩溃<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-comment">// 如果多线程调用，那么当A线程对_object属性覆盖的时候，可能将会导致B线程的_object被提前释放，如果此时B线程恰好正在对释放之前的地址进行发消息，就会造成崩溃</span><br>- (NSObject *)<span class="hljs-keyword">object</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-number">_</span><span class="hljs-keyword">object</span>) &#123;<br>        <span class="hljs-number">_</span><span class="hljs-keyword">object</span> = [NSObject <span class="hljs-keyword">new</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">_</span><span class="hljs-keyword">object</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>需要谨记，在OC中，读取&amp;设置属性在runtime层面上都不是原子性的，如果存在多线程访问，需要考虑崩溃问题</li></ul><h2 id="属性包装"><a href="#属性包装" class="headerlink" title="属性包装"></a>属性包装</h2><ul><li>和resultBuilder一样，propertyWrapper也是很大程度上就是因为SwiftUI而引入的</li><li>当我们使用propertyWrapper时，其实就是告知编译器向对该属性封装为一个结构体&#x2F;类，对该属性的存取转换为对该结构体&#x2F;类中init和属性计算方法的调用<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">@propertyWrapper</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>&lt;<span class="hljs-title class_">A</span>&gt; &#123;<br>    <span class="hljs-keyword">var</span> wrappedValue: <span class="hljs-type">A</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">wrappedValue</span>: <span class="hljs-type">A</span>) &#123;<br>        <span class="hljs-keyword">self</span>.wrappedValue <span class="hljs-operator">=</span> wrappedValue<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>在SwiftUI中，@State中的管理的值实际是被SwiftUI管理，@Binding的值实际是对应的@State中的值，@Binding并不关心值在哪，值关心setter和ggeter</li><li>投影值，即projectedValue，通过对属性包装调用$而创建</li><li>本质上，@Binding实际也是一个结构体，只不过这个结构体中存储的不是实际的值，而是setter和getter，那么这个setter和getter就是@State的projectValue在创建@Binding时赋值的</li><li>@State&#x2F;@Observedbject -&gt; 投影值 -&gt; @Binding，对@Binding的存取即通过setter&#x2F;getter间接的称为对@State&#x2F;@ObservedObject中属性的存取，就是这么简单~~<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">// 投影值本身，其特殊支出在于存储的东西不是实例而是函数</span><br><span class="hljs-keyword">@propertyWrapper</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Reference</span>&lt;<span class="hljs-title class_">A</span>&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _get: () -&gt; <span class="hljs-type">A</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _set: (<span class="hljs-type">A</span>) -&gt; ()<br>    <br>    <span class="hljs-keyword">var</span> wrappedValue: <span class="hljs-type">A</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            _get()<br>        &#125;<br>        <span class="hljs-keyword">set</span> &#123;<br>            _set(newValue)<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">get</span>: <span class="hljs-keyword">@escaping</span> () -&gt; <span class="hljs-type">A</span>, <span class="hljs-params">set</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">A</span>) -&gt; ()) &#123;<br>        _get <span class="hljs-operator">=</span> <span class="hljs-keyword">get</span><br>        _set <span class="hljs-operator">=</span> <span class="hljs-keyword">set</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义属性包装的投影值</span><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Box</span> &#123;<br>    <span class="hljs-keyword">var</span> projectedValue: <span class="hljs-type">Reference</span>&lt;<span class="hljs-type">A</span>&gt; &#123;<br>        <span class="hljs-type">Reference</span>&lt;<span class="hljs-type">A</span>&gt; &#123; () -&gt; <span class="hljs-type">A</span> <span class="hljs-keyword">in</span><br>            <span class="hljs-keyword">self</span>.wrappedValue<br>        &#125; <span class="hljs-keyword">set</span>: &#123; (i) <span class="hljs-keyword">in</span><br>            <span class="hljs-keyword">self</span>.wrappedValue <span class="hljs-operator">=</span> i<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>有时，我们并不希望将整个wrapperedValu而通过投影值传递，而是希望让传递wrappedValue中的某个属性，那我们不能写成$A.xxx，因为$Type已经是投影类型了，它没有xxx这个属性。方法自然是有的，我们需要为投影类型实现动态成员查找：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">@propertyWrapper</span><br><span class="hljs-keyword">@dynamicMemberLookup</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Reference</span>&lt;<span class="hljs-title class_">A</span>&gt; &#123;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">subscript</span>&lt;<span class="hljs-type">B</span>&gt;(<span class="hljs-params">dynamicMember</span> <span class="hljs-params">keyPath</span>: <span class="hljs-type">WritableKeyPath</span>&lt;<span class="hljs-type">A</span>, <span class="hljs-type">B</span>&gt;)<br>-&gt; <span class="hljs-type">Reference</span>&lt;<span class="hljs-type">B</span>&gt; &#123;<br>    <span class="hljs-type">Reference</span>&lt;<span class="hljs-type">B</span>&gt;(get: &#123;<br>        <span class="hljs-keyword">self</span>.wrappedValue[keyPath: keyPath]<br>    &#125;) &#123;<br>        <span class="hljs-keyword">self</span>.wrappedValue[keyPath: keyPath] <span class="hljs-operator">=</span> <span class="hljs-variable">$0</span><br>    &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>这样，当我们使用$A.xxxx时，就会转换为对Refrerence&lt;A&gt;[dynmiacMembers:\.xxxx]的调用，从而能够获取到对原始实例的存取</li><li>有时，属性只在能够获取到其宿主时才会发挥作用，比如Combine框架中的@Published，它实际上必须要调用宿主的（ObservableObject类型）的objectWillChanged才work，要想实现这种效果，需要通过实现一个特定的subscript方法，这里暂时不详细探究了</li><li>SwiftUI中的@State实际就是必须获取到宿主View的层级才work的</li><li>由于属性包装编译器必须生成存储属性，而enum在case之外是不能放存储属性的，因而enum中不能使用属性包装</li><li>可以在函数中使用属性包装，并且从Swift 5.5开始，也可以将属性包装作为函数参数传递</li></ul><h2 id="键路径"><a href="#键路径" class="headerlink" title="键路径"></a>键路径</h2><ul><li>也就是KeyPath，表示对一个属性为调用的引用，如\Type.xxx，因为Type可能本身有个static的xxx属性，为了区分开，需要加个\。如果可以类型推断，可省略Type，即\.xxx</li><li>KeyPath可以由任意存储属性和计算属性组合，包括可选类型，编译器会自动为为每个类型生成[keyPath:]下标方法</li><li>WriteableKeyPath：可以通过该KeyPath对属性修改，要求原值是可变的</li><li>ReferenceWritableKeyPath：同上，但是针对于引用语义的值</li><li>KeyPath：不可通过该KeyPath对属性修改</li><li>KeyPath还可以用于描述下标操作，如\.[1].name</li><li>KeyPath某种程度上和函数类似，都是给定参数获取值，或者传入参数设置值，但是KeyPath本身可以比较判等，并且无状态，这和函数不同</li><li>编译器可以自动将KeyPath转换为函数，如xx.map(\.name)等价于xx.map{$0.name}，注意这个仅对直接写的时候有效，如果将KeyPath放到变量中是无效的</li><li>KeyPath还可以组合，需要注意类型必须要匹配<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs julia">// KeyPath&lt;Person, <span class="hljs-built_in">String</span>&gt; + KeyPath&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Int</span>&gt; = KeyPath&lt;Person, <span class="hljs-built_in">Int</span>&gt;<br><span class="hljs-keyword">let</span> nameCountKeyPath = nameKeyPath.appending(path: \.count)<br>// Swift.KeyPath&lt;Person, Swift.<span class="hljs-built_in">Int</span>&gt;<br></code></pre></td></tr></table></figure></li><li>可写的KeyPath在SwiftUI中很常见，比如通过其修改环境值，在之前也看到过结合投影类型的动态成员查找，方便实现任意属性的投影</li><li>总结下5种类型的KeyPath，其中WritableKeyPath和ReferenceWritableKeyPath进行区分是必要的，前一个类型的setter要求它的参数是inout的<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-type">AnyKeyPath</span> like (<span class="hljs-keyword">Any</span>) -&gt; <span class="hljs-keyword">Any</span><span class="hljs-operator">?</span><br><span class="hljs-type">PartialKeyPath</span>&lt;<span class="hljs-type">Source</span>&gt; like (<span class="hljs-type">Source</span>) -&gt; <span class="hljs-keyword">Any</span><span class="hljs-operator">?</span><br><span class="hljs-type">KeyPath</span>&lt;<span class="hljs-type">Source</span>, <span class="hljs-type">Target</span>&gt; like (<span class="hljs-type">Source</span>) -&gt; <span class="hljs-type">Target</span><br><span class="hljs-type">WritableKeyPath</span>&lt;<span class="hljs-type">Source</span>, <span class="hljs-type">Target</span>&gt; like (<span class="hljs-type">Source</span>) -&gt; <span class="hljs-type">Target</span> and (<span class="hljs-keyword">inout</span> <span class="hljs-type">Source</span>,     <span class="hljs-type">Target</span>) -&gt; ()<br><span class="hljs-comment">// 这一对函数相似。第二个函数可以用Target来更新Source值且要求 Source 是一个引用类型 </span><br><span class="hljs-type">ReferenceWritableKeyPath</span>&lt;<span class="hljs-type">Source</span>, <span class="hljs-type">Target</span>&gt; like (<span class="hljs-type">Source</span>) -&gt; <span class="hljs-type">Target</span> and (<span class="hljs-type">Source</span>, <span class="hljs-type">Target</span>) -&gt; ()<br></code></pre></td></tr></table></figure></li><li>相比于OC，OC的键路径是通过字符串实现的，并且没有类型约束，魔种程度上类似于AnyKeyPath，但是不安全</li><li>KeyPath目前还存在性能问题，比直接访问要慢（因为毕竟是动态嘛…</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-函数</title>
    <link href="/2023/12/21/swift-advance-function/"/>
    <url>/2023/12/21/swift-advance-function/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>函数在Swift中和类一样，都是头等公民，可以被赋值给变量，可以被传递，可以捕获外部变量。当函数捕获变量时，可以视作函数和被捕获的变量构成了一个类对象（但是函数不可比较）。<br>函数既可以使用func关键字声明，也可以用闭包表达式来声明，eg.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">let</span> f <span class="hljs-operator">=</span> &#123;(i: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">return</span> i <span class="hljs-operator">*</span> <span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><p>闭包表达式与func的主要区别在于闭包是匿名的，只能被赋值给变量或者作为参数传递。<br>在Swift中，函数&#x3D;&#x3D;闭包，没什么不同，只是写的形式可能有区别。</p><h2 id="函数的灵活性"><a href="#函数的灵活性" class="headerlink" title="函数的灵活性"></a>函数的灵活性</h2><ul><li>如何实现复杂的排序规则，在OC中，可以通过NSSortDescriptor，但仅限于NSObject类，在Swift中使用高阶函数可以完成</li><li>(Value) -&gt; (Value) -&gt; ComparisonResult的含义实际上就是(Value) -&gt; ((Value) -&gt; ComparisonResult)，即给定一个值，返回一个闭包<br>看一个例子：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SortDescriptor</span>&lt;<span class="hljs-title class_">Root</span>&gt; &#123;<br>    <span class="hljs-keyword">var</span> areInIncreasingOrder: (<span class="hljs-type">Root</span>, <span class="hljs-type">Root</span>) -&gt; <span class="hljs-type">Bool</span><br>&#125;<br><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">SortDescriptor</span> &#123;<br>    <span class="hljs-keyword">init</span>&lt;<span class="hljs-type">Value</span>&gt;(<span class="hljs-params">key</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Root</span>) -&gt; <span class="hljs-type">Value</span>,<br>                <span class="hljs-params">compare</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Value</span>) -&gt; ((<span class="hljs-type">Value</span>) -&gt; <span class="hljs-type">ComparisonResult</span>)) &#123;<br>        <span class="hljs-comment">// 注意这里$0和$1表示的是areInIncreasingOrder的两个参数</span><br>        <span class="hljs-keyword">self</span>.areInIncreasingOrder <span class="hljs-operator">=</span> &#123;<br>            compare(key(<span class="hljs-variable">$0</span>))(key(<span class="hljs-variable">$1</span>)) <span class="hljs-operator">==</span> .orderedAscending<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> sortByFirstName: <span class="hljs-type">SortDescriptor</span>&lt;<span class="hljs-type">Person</span>&gt; <span class="hljs-operator">=</span> .<span class="hljs-keyword">init</span>(key: &#123;<span class="hljs-variable">$0</span>.first&#125;, compare: <span class="hljs-type">String</span>.localizedStandardCompare)<br></code></pre></td></tr></table></figure>这里String.localizedStandardCompare的类型就是(String) -&gt; (String) -&gt; ComparisonResult，它等价于string1.localizedStandardCompare(string2)<br>通过高阶函数+泛型，我们可以方便的生成普适性的函数&#x2F;闭包，从而达到简洁的效果。（但是有时也会加大理解负担）</li><li>还可以通过将SortDescriptor进行封装组合，形成更加强大复杂的排序方式，比如<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">SortDescriptor</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">then</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">other</span>: <span class="hljs-type">SortDescriptor</span>&lt;<span class="hljs-type">Root</span>&gt;) -&gt; <span class="hljs-type">SortDescriptor</span>&lt;<span class="hljs-type">Root</span>&gt; &#123;<br>        <span class="hljs-type">SortDescriptor</span> &#123; x, y <span class="hljs-keyword">in</span><br>        <span class="hljs-keyword">if</span> areInIncreasingOrder(x,y) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br>        <span class="hljs-keyword">if</span> areInIncreasingOrder(y,x) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>        <span class="hljs-keyword">return</span> other.areInIncreasingOrder(x,y)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>这里使用then将descriptor进行组合，实际类似于java中的builder模式，在最后调用的时候，按照从里到外的顺序调用每个desriptor的areInIncreasingOrder方法</li></ul><h2 id="函数作为代理"><a href="#函数作为代理" class="headerlink" title="函数作为代理"></a>函数作为代理</h2><ul><li>如果只需要一个函数作为回调，那么使用函数而不需要使用代理</li><li><strong>Swift中的闭包捕获的变量类比于OC来说默认是__block的</strong>，既可以影响外部被捕获的值，而不是copy</li></ul><h2 id="inout参数和可变方法"><a href="#inout参数和可变方法" class="headerlink" title="inout参数和可变方法"></a>inout参数和可变方法</h2><ul><li>inout参数实际上并不是直接修改原来的参数，而是先copy，然后修改，再将修改完之后的值copy回去（但是编译器可能优化为传地址，但是不应依赖该行为）</li><li>只能使用var作为inout参数：肯定啊，不然咋修改</li><li>数组下标也可以作为inout参数，实际上，支持set&#x2F;get的所有下标操作都能被作为inout参数</li><li>在嵌套函数中也可以使用inout，但是嵌套函数不能逃逸</li><li>如果参数声明为UnsafeXXXPointer，则&amp;表示取指针而不是inout参数</li></ul><h2 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h2><ul><li>subscript函数</li><li>参数后…表示可变长度参数，可作为数组使用</li></ul><h2 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h2><ul><li>@autoclosure告知编译器，应当将传入的表达式转换为闭包，eg.<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">and</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">l</span>: <span class="hljs-type">Bool</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">r</span>: <span class="hljs-keyword">@autoclosure</span> () -&gt; <span class="hljs-type">Bool</span>) -&gt; <span class="hljs-type">Bool</span> &#123;<br>    <span class="hljs-keyword">guard</span> l <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-keyword">return</span> r()<br>&#125;<br><br><span class="hljs-keyword">if</span> and(<span class="hljs-operator">!</span>evens.isEmpty, evens[<span class="hljs-number">0</span>] <span class="hljs-operator">&gt;</span> <span class="hljs-number">10</span>) &#123;<br>    <span class="hljs-comment">// 执行操作</span><br>&#125; <br></code></pre></td></tr></table></figure></li><li>#fileId, #function, #line在编译器中表示<strong>调用者</strong>的文件名、函数名和行号</li></ul><h2 id="escaping"><a href="#escaping" class="headerlink" title="@escaping"></a>@escaping</h2><ul><li>表示作为参数传递的闭包可以被保存并在稍后使用</li><li>闭包参数如果是直接参数，默认是非escaping的，但可选值类型、存储属性、封装在元组中的闭包是escaping的</li><li>有时我们确实知道闭包时不会逃逸的，但又不想传递可选值，那么可以使用withoutActuallyEscaping来告知编译器,但是安全性需要自己保证：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Array</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">allSatisfy2</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">predicate</span>: (<span class="hljs-type">Element</span>) -&gt; <span class="hljs-type">Bool</span>) -&gt; <span class="hljs-type">Bool</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">withoutActuallyEscaping</span>(predicate) &#123; escapablePredicate <span class="hljs-keyword">in</span><br>        <span class="hljs-keyword">self</span>.lazy.filter &#123; <span class="hljs-operator">!</span>escapablePredicate(<span class="hljs-variable">$0</span>) &#125;.isEmpty<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="ResultBuilder"><a href="#ResultBuilder" class="headerlink" title="ResultBuilder"></a>ResultBuilder</h2><ul><li>当编译器遇到ResultBuilder注解时，会将被注解函数表达式转换对特定结构体中函数的调用，从而得到最终结果，最典型的例子就是SwiftUI中的ViewBuilder，这可能也是ResultBuilder被引入的动机之一<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">@inlinable</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">alignment</span>: <span class="hljs-type">VerticalAlignment</span> <span class="hljs-operator">=</span> .center, <span class="hljs-params">spacing</span>: <span class="hljs-type">CGFloat</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>, <span class="hljs-meta">@ViewBuilder</span> <span class="hljs-params">content</span>: () -&gt; <span class="hljs-type">Content</span>)<br></code></pre></td></tr></table></figure></li><li>实际上，Swift会将@ViewBuilder注解函数中的表达式转换为调用ViewBuilder结构体中的buildBlock的函数调用，等价于<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">@resultBuilder</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ViewBuilder</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">buildBlock</span>&lt;<span class="hljs-type">C0</span>, <span class="hljs-type">C1</span>, <span class="hljs-type">C2</span>&gt;(<span class="hljs-keyword">_</span> <span class="hljs-params">c0</span>: <span class="hljs-type">C0</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">c1</span>: <span class="hljs-type">C1</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">c2</span>: <span class="hljs-type">C2</span>)<br>    -&gt; <span class="hljs-type">TupleView</span>&lt;(<span class="hljs-type">C0</span>, <span class="hljs-type">C1</span>, <span class="hljs-type">C2</span>)&gt;<br>    <span class="hljs-keyword">where</span> <span class="hljs-type">C0</span>: <span class="hljs-type">View</span>, <span class="hljs-type">C1</span>: <span class="hljs-type">View</span>, <span class="hljs-type">C2</span>: <span class="hljs-type">View</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>注意ViewBuilder前面的注解@resultBuilder，其可以实现一系列不同的buildXXX方法</li><li>注意@resultBuilder注解时Swift 5.4引入的</li><li>最基本的方法是buildBlock和buildExperssion，@resultBuilder要求至少实现一个buildBlock方法</li><li>buildBlock中的参数和类型并不要求一致，但是如果想要函数支持多种类型，使用buildExpression时更加优雅的方式，其作用是在将参数传递给buildXXX之前先应用该函数进行转换</li><li>通过重载buildExpression方法，我们可以实现一些特殊逻辑，比如一般builder函数（即被标记为@XXXBuilder的函数）中是不能调用print方法的，因为print方法返回的是Void。我们可以添加一个将Void转换为需要参数类型的buildExpression来绕过</li><li>@available注解格式<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">@available</span>(版本范围, 可用性, message: 错误消息)<br></code></pre></td></tr></table></figure></li><li>builder还可以通过实现buildIf和buildEither来支持if，if else和switch语句<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">// 支持单个if，因为if语句要么有值，要么值为nil，所以参数是可选值类型</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">buildIf</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">s</span>: <span class="hljs-type">String</span>?) -&gt; <span class="hljs-type">String</span> &#123;<br>    s <span class="hljs-operator">??</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 支持if else的if分支，要求if分支必须返回是String</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">buildEither</span>(<span class="hljs-params">first</span> <span class="hljs-params">component</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> &#123;<br>    component<br>&#125;<br><br><span class="hljs-comment">// 支持if else的else分支，要求else分支必须返回是String</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">buildEither</span>(<span class="hljs-params">second</span> <span class="hljs-params">component</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> &#123;<br>    component<br>&#125;<br><br><span class="hljs-comment">// 实现了if else，switch是实现了，switch也可以看做是if else的嵌套调用，但是实际上switch除了第一个case是buildEither(first:)，其余分支都是buildEdither(second:)</span><br></code></pre></td></tr></table></figure></li><li>builder还可以支持循环<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">buildArray</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">components</span>: [<span class="hljs-type">String</span>]) -&gt; <span class="hljs-type">String</span> &#123;<br>    components.joined(separator: <span class="hljs-string">&quot;&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>buildFindalResult:将会在builder函数的最后的结果被应用</li><li>resultBuilder不支持guard、defer、do…catch等，因为这些语句无法被求值</li><li>总结：通过实现一系列build方法，创建一个XXXBuilder，通过@XXXBuilder将函数&#x2F;闭包转换为对build方法的调用，从而实现自定义DSL的效果</li><li>所以为啥View中的body能返回不同类型的View呢，<strong>实际上View的body就是@ViewBuilder</strong>，但是并不是任何属性都具有该特特性，正常情况下，<strong>某个标记为some View的属性需要返回相同类型的View</strong>，我们可以加上@ViewBuilder注解（因为some View就是某种特定具体类型的View，所以如果返回的类型不同，自然无法编译通过，<strong>通过加上ViewBuilder注解让编译器帮我们将表达式转换为统一的封装类型</strong>就OK了~~）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-可选值</title>
    <link href="/2023/12/20/swift-advance-optional-value/"/>
    <url>/2023/12/20/swift-advance-optional-value/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分主要介绍Swift中可选值的底层原理</p><h2 id="哨岗值"><a href="#哨岗值" class="headerlink" title="哨岗值"></a>哨岗值</h2><ul><li>在许多时候，函数在没有读取到有效值后需要返回给我们一个特定的值，称为哨岗值，比如EOF、-1、null等等</li><li>哨岗值有时是有效的值，比如-1，但有时候这种情况会导致错误的结果，比如OC对nil发消息，如果方法返回的是结构体，则会是一个值全部为0的结构体，这时有可能导致逻辑错误,eg<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-built_in">NSString</span> *someString = ...;<br><span class="hljs-keyword">if</span> ([someString rangeOfString:<span class="hljs-string">@&quot;Swift&quot;</span>].location != <span class="hljs-built_in">NSNotFound</span>) &#123;<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Someone mentioned Swift!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>如果someString是nil，location就会是0而不是NSNotFound（是NSIntegerMax），显然是错误的。</li><li>哨岗值还依赖约定，如果不知道约定，则无法使用。</li><li>Swift通过枚举实现Optional来解决哨岗值的问题,没错，可选值的本质实际就是带有关联值的Swift枚举<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Optional</span>&lt;<span class="hljs-title class_">Wrapped</span>&gt; &#123;<br><span class="hljs-keyword">case</span> none<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">some</span>(<span class="hljs-type">Wrapped</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>Swift中对于可能是哨岗值的返回的都是可选值，从而避免了必须了解哨岗值约定的问题</li><li>语法糖使得使用可选值更加方便：<ul><li>Type? &#x3D; Optional<Type></li><li>nil &#x3D; .none(因为可选值遵守ExpressibleByNilLiteral协议，即可用nil表示)</li><li>在必要时，非可选值会自动封装为可选值，不需要手动调用.some(Type)，比如函数的返回类型标记为可选值类型</li></ul></li><li>可选值匹配：<ul><li>匹配值：switch .some(let v)或者swifth let v?</li><li>匹配nil：switch .none或者switch nil</li></ul></li></ul><h2 id="可选值概览"><a href="#可选值概览" class="headerlink" title="可选值概览"></a>可选值概览</h2><ul><li>if let:可选值绑定,略</li><li>while let:当遇到nil时终止</li><li>双重可选值：即Type??，实际就是Optional(Optional(value))<ul><li>case let v? &#x3D; case let .some(v)，仅匹配值</li></ul></li><li>case实际上的匹配功能很强大，比如 case 0..&lt;10 &#x3D; j可以检查j是否在范围内</li><li>if var&#x2F;while var:可变版本，使得我们在if语句中可以修改变量</li><li>在作用域之外使用解包后的值：使用guard let语句，其else路径必须是要求离开当前作用域，如return或者调用一个Never函数</li><li>返回Never（又称为无人类型）的函数向编译器表明自己绝对不会返回，如fatalError或者dispatchMain;又或者对应的值绝对不会出现，比如将泛型指定为Never</li><li>Never实际在Swift中就是个enum<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Never</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li>Never和Void是不同的，Void实际是空元祖()</li><li>总结，不存在是nil，存在且为空Void，绝对不会发生Never</li><li>在OC中，对nil发消息不会发生，在Swift中，使用可选链实现，如v?.callback(),<strong>可选链的调用结果一定是可选值</strong></li><li>对于可选值成员，默认值是nil，这是Swift中对于成员成员初始化的<strong>唯一例外</strong>。注意这个默认行为支队x?的形式有效，如果写成了Optional<T>就无效了，还是必须初始化</li><li>可选链和赋值：可以使用可选链来对可选值进行赋值，如<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> a: <span class="hljs-type">Int</span>?<br>a<span class="hljs-operator">?+=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>注意不能写成，因为可选值绑定对值类型来说是复制<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> a: <span class="hljs-type">Int</span>? <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">var</span> a <span class="hljs-operator">=</span> a &#123;<br>    <span class="hljs-comment">// 无法改变外层的a</span><br>    a<span class="hljs-operator">+=</span><span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>nil合并操作符：??,略，注意??也是短路操作符</li><li>可选值提供了一个map方法，方便我们在不为nil的请款修改进行转换，注意因为是Optional本身提供的方法，所以调用的时候不能加?,eg.arr.first.map{…}（注意，只要是可选值，就可以调用该map方法，不要求可选值是集合类型！！），但是注意，即使如此，<strong>返回的仍然是可选值类型</strong></li><li>flatMap：如果变换本身返回了可选值类型，那么map得到的结果则是双重可选值，为了去掉一层，可以使用flatMap，注意可选值的类型上也是直接定义了flatMap</li><li>compactMap：可以将变换后为nil的可选值给筛掉</li><li>可选值判等：如果可选值封装的类型符合Equatable，则对应的可选值类型也是Equatable的，所以我们可以方便的判等：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> a: <span class="hljs-type">Int</span>? <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>a <span class="hljs-operator">==</span> <span class="hljs-number">0</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>这里work的原因是swift会在必要时将0升级为可选值</li><li>字典中如果直接设置key的value为nil会移除掉key和value，若要插入值nil，可以使用Optional(nil)</li><li>强制解包的使用：一般不要使用，除非预期是在遇到nil时直接crash</li><li>挂起操作的方式：fatalError直接crash、assert在测试版本不符合条件执行并且crash、precondtion和assert一样只不过在正式版也存在</li><li>隐式解包：标记为Type!的类型<ul><li>情景1：oc返回的类型，并且没有标记nullable和nonnull</li><li>情景2：暂时的为空，不如初始化的过程中</li><li>隐式可选值在使用上既可以假定为非可选值不加？，也可以当做可选值加？</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-内建集合类型</title>
    <link href="/2023/12/19/swift-advance-built-in-collection/"/>
    <url>/2023/12/19/swift-advance-built-in-collection/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>虽然在工作中已经大量使用了Swift了，但总感觉自己停留在使用的层面。从今天开始，开始复习Swift Adavance，回忆、理解、总结。</p><p>本章重点介绍了Swift内建的几种集合类型，并讨论如何高效使用。</p><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><ul><li>值语义： Swift中所有的内建集合类型都具有值语义，数组当然也不例外。值语义的典型表现是当其被赋值给一个变量时，将发生复制。</li><li>使用let和var来表示数组是不可变数组or可变数组。注意，即使是可变数组，仍然是值类型。这和NSMutableArray完全不同。</li><li>Swift编译器会对值语义集合进行优化，如果被赋值给对个变量，只有通过变量修改值时才会发生实际的copy，但我们不应依赖该行为。</li><li>数组越界会直接崩溃。</li><li>数组为空时，调用removeLast会崩溃，但popLast则不会崩溃，而是返回nil。</li><li>支持map、flatMap、filter等函数式编程。</li><li>使用.lazy将变形延迟发生到最终需要结果的时候，比如需要将结果转换为数组输出。</li><li>map：遍历元素，对每个元素应用func得到新集合。</li><li>filter: 遍历元素，删除掉符合func的元素得到新集合。</li><li>reduce: 遍历元素，对每个元素应用和之前的结果应用func得到结果值。</li><li>flatMap: 如果得到的结果外层是数组，则去掉结果外层数组。</li><li>forEach: 遍历元素，应用func但不返回结果。注意func中写return并不会使得遍历停止。</li><li>数组可以切片，类似于python，结果是ArraySlice。但是，<strong>切片完之后的索引和原始数组共享索引和内存</strong>！</li></ul><h2 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h2><ul><li>字典查找总是返回可选值，这和Array不同。</li><li>思想：Array中的索引一般总是通过某种方式计算得到的，一般都是有效的，无效的索引一般意味着开发者的计算失误。所以崩溃就好。但是Dict的key一般是其他取到得来的，比如server下发，所以返回可选值比较好。</li><li>删除值：将对应key的value设置为nil或者removeValue(forKey:),该方法返回删除的value,注意，这同时会将key也给删掉。</li><li>更新值：简单，设置即可，或者使用updateValue(_:forKey:),该方法会返回old value。</li><li>合并dict：merge(_:uniquingKeysWith:),第二个参数是决定决策对于相同的key使用如何获取value的函数，注意<strong>是获取value，而不是选择value</strong>，因为不仅可以选择某一个value，也可以对这两个value进行操作得到新的value。</li><li>mapValues: 对dict的values作map</li><li>Dict的key必须符合Hashable协议。<ul><li>标准库中所有基本数据类型都是Hashable的，如Int、String</li><li>数组、集合或可选值，如果其元素时Hashable，则他们也是Hashable</li><li>结构体和enum，如果是由Hashable的类型组成（对结构体来说，要求存储属性，对enum来说，要求关联值，若无关联值，则默认是Hashable的，不需要声明），只要我们声明他们是Hashable，则Swift会帮我们合成Hashable的实现</li><li>对于通过&#x3D;&#x3D;比较相等的两个对象，hash值必须相同，反之，hash值相同，不一定是相同的对象，因为hash值有限，但对象数量无限，可能存在hash冲突的可能。</li><li>所以一般不要使用可变对象作为key，否则如果对象改变造成hash改变，则会造成dict存储找不到或存储错误。</li></ul></li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul><li>嘛，就是集合</li><li>可以使用数组字面量初始化Set，因为Set遵守ExpressibleByArrayLiteral。</li><li>补集：substring</li><li>交集：intersection</li><li>并集：formUnion，这是union的可变版本，即改变原集合，所有以form开头的版本都是可变版本。</li></ul><h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><ul><li>就是区间</li><li>x..&lt;y左闭右开: Range，只有此类型可以表示空集，如5..&lt;5</li><li>x…y闭区间: ClosedRange,只有此类型可以表示最大值，如0…Int.max，因为Range需要上界是比自身包含的范围还得+1</li><li>Range和ClosedRange都有Bound泛型，Bound需要符合Comparable</li><li>x…，左闭右无界: PratialRangeFrom，可遍历，需自己break<ul><li>对于PartialRangeFrom遍历时，会从下界开始，调用adavanced(by:1)</li></ul></li><li>…y，左无界右闭：PartialRangeThrough，不可遍历</li><li>..&lt;y，左无界右开: PartialRangeUpTo，不可遍历</li><li>检测包含：contains、overlaps</li><li>Range可以遍历，但不能完全遍历emm…，支持遍历的<strong>Range的Bound</strong>需要实现Strideable协议。</li><li>Range必须是可数的才能遍历</li><li>Swift之前为了区分可数还是不可数，引入两个类型，即CountableRange和CountableClosedRange</li><li>所有的Range都满足RangeExpression协议<ul><li>contains：判断元素是否包含在范围中</li><li>relative：对给定集合，能够计算出该集合的Range。<strong>若该RangeExpression缺少上界或者下界，则返回的结果中使用给定集合的startIndex或endIndex作为上界或者下界</strong>。</li><li>所以数组可以使用Range进行切片，原理就是数组的subscript实现了接受RangeExpression作为参数，从而结合自身的startIndex和endIndex得到一个Range，从而执行切片</li></ul></li><li>RangeSet: 即Range的集合，在表示多个区间时更加高效</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo添加Live2D看板娘</title>
    <link href="/2023/12/03/hexo-add-live2d/"/>
    <url>/2023/12/03/hexo-add-live2d/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在浏览别人的blog时，有时可以看到一个类似于下面这个萌萌哒的玩意，这其实是通过Live2D Widget插件实现的。方法也很简单，follow me~<br><img src="/../images/image-19.png" alt="Alt text"></p><h2 id="Step1-安装live-2d插件"><a href="#Step1-安装live-2d插件" class="headerlink" title="Step1 安装live 2d插件"></a>Step1 安装live 2d插件</h2><p>注意，下面的指令都是在Hexo项目目录中使用的</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-helper-live2d</span><br></code></pre></td></tr></table></figure><h2 id="Step2-下载live-2d模型"><a href="#Step2-下载live-2d模型" class="headerlink" title="Step2 下载live 2d模型"></a>Step2 下载live 2d模型</h2><p>通过下载不同的live 2d模型，就可以获得不同的看板娘啦，直接npm下载，贼方便</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">// 下载的model会存放在node_modules中</span><br>npm install live2d-widget-<span class="hljs-keyword">model</span>-tororo<br></code></pre></td></tr></table></figure><h2 id="Step3-配置-config-yml"><a href="#Step3-配置-config-yml" class="headerlink" title="Step3 配置_config.yml"></a>Step3 配置_config.yml</h2><p>添加如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Live2D看板娘</span><br><span class="hljs-attr">live2d:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">pluginModelPath:</span> <span class="hljs-string">assets/</span><br>  <span class="hljs-attr">model:</span><br>    <span class="hljs-comment">#模板目录，在node_modules里</span><br>    <span class="hljs-attr">use:</span> <span class="hljs-string">live2d-widget-model-tororo</span><br>  <span class="hljs-attr">display:</span><br>    <span class="hljs-attr">position:</span> <span class="hljs-string">right</span><br>    <span class="hljs-attr">width:</span> <span class="hljs-number">300</span> <br>    <span class="hljs-attr">height:</span> <span class="hljs-number">600</span><br>  <span class="hljs-attr">mobile:</span><br>    <span class="hljs-comment"># 在手机端显示</span><br>    <span class="hljs-attr">show:</span> <span class="hljs-literal">false</span>   <br>  <span class="hljs-attr">rect:</span><br>    <span class="hljs-string">opacity:0.7</span><br></code></pre></td></tr></table></figure><h2 id="Step4-查看效果"><a href="#Step4-查看效果" class="headerlink" title="Step4 查看效果"></a>Step4 查看效果</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">hexo g <span class="hljs-meta">&amp;&amp; hexo s</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Live2D</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何让Hexo被Google索引到</title>
    <link href="/2023/12/03/about-hexo-google-index/"/>
    <url>/2023/12/03/about-hexo-google-index/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们写blog的目的是让自己的分享被别人看到，如果Google没有收录自己的网址，那么就没有意义了。 本篇文章主要介绍如何让咱们的blog被Google收录。</p><h2 id="Step1-检查收录"><a href="#Step1-检查收录" class="headerlink" title="Step1 检查收录"></a>Step1 检查收录</h2><p>首先检查咱们的blog有没有被Google索引，在搜索框输入site:xxx.github.io，不出意外的话，Google没有收录：<br><img src="/../images/image-13.png" alt="Alt text"></p><h2 id="Step2-验证网址所有权"><a href="#Step2-验证网址所有权" class="headerlink" title="Step2 验证网址所有权"></a>Step2 验证网址所有权</h2><p>按照提示，点击进入Google Search Console，Google会要求验证这个网址的归属权，这里由于采用的GitHub Page，所以按照第二种网址前缀的方式进行验证：<br><img src="/../images/image-14.png" alt="Alt text"><br>接下来，会看到有几种验证的方式，因为不想添加一个乱七八糟的html到网站目录中（强迫症犯了QAQ），所以我选择HTML标记的方式。这种方式会要求我们在index.html的head标签中添加一个meta标签，按照提示复制该标签。<br><img src="/../images/image-15.png" alt="Alt text"><br>接下来，找到Hexo项目的public文件夹下的index.html，将这个标签复制到head标签的末尾。<br><img src="/../images/image-16.png" alt="Alt text"><br>顺便说下，Hexo在部署的就是public文件夹下的内容。<br>我们直接发布，<strong>注意不要generate</strong>，因为generate会重新生成index.html，会将咱们之前的修改给覆盖掉。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">// 直接发布即可</span><br>hexo d<br></code></pre></td></tr></table></figure><p>发布完成之后，稍等1min左右，等待GitHub Page部署完成，点击验证按钮。Congratulations，验证完成~~~<br><img src="/../images/image-17.png" alt="Alt text"></p><h2 id="Step3-添加sitemap-xml"><a href="#Step3-添加sitemap-xml" class="headerlink" title="Step3 添加sitemap.xml"></a>Step3 添加sitemap.xml</h2><p>到上面其实Google已经允许收录咱们的blog了，但是为了Google的蜘蛛机器人更好的爬取到网站的内容，我们可以在网站根目录下放一个sitemap.xml。<br>进入到Hexo项目目录中，安装插件：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-generator-sitemap <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>安装完毕之后，打开_config.yml，添加如下内容</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"># automatically <span class="hljs-keyword">generate</span> sitemap<br>sitemap:<br>  path: sitemap<span class="hljs-variable">.xml</span><br></code></pre></td></tr></table></figure><p>重新生成部署，不再啰嗦啦，hexo g -d一把梭。<br>等待1min。进入到Google Search Console，提交我们的sitemap.xml，如下图，OK收工。<br>但我们这个时候再搜索还是搜不到的，需要等个几天，到时候再来更新~<br><img src="/../images/image-18.png" alt="Alt text"></p><hr><p>12月9日更新，已经可以被索引到了~<br><img src="/../images/image-20.png" alt="Alt text"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Hexo中图片路径问题</title>
    <link href="/2023/12/03/about-hexo-picture-path/"/>
    <url>/2023/12/03/about-hexo-picture-path/</url>
    
    <content type="html"><![CDATA[<p>在编写Hexo时，通常需要粘贴图片到markdown中。默认粘贴的path和咱们的md文件同级别，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![Alt text](image-9.png)</span><br></pre></td></tr></table></figure><p>虽然本地预览没有问题，但是在generate的时候，存在两个问题：<br>1.Hexo会忽略_post下的图片资源<br>2.Hexo会将md文件中的path转换为域名&#x2F;path，例如<a href="http://xxx.github.io/xxx.png">http://xxx.github.io/xxx.png</a><br>这两个问题都会导致无法正常看到我们blog中的图片。  </p><p>问题解决：<br>1.在source下新建images文件夹，专门用来存放图片<br>2.Hexo中使用images&#x2F;xxx.png来引用该图片</p><p>那么还是有问题，在使用VS Code粘贴图片时，还是默认粘贴到_posts下面，这样每次都要移动图片和修改路径，很麻烦。没错，贴心的VS Code可以自定义粘贴的路径，使用cmd+,打开设置，找到如下界面设置默认的粘贴路径：<br><img src="/../images/image-10.png" alt="Alt text"><br>完成！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo的安装与部署</title>
    <link href="/2023/12/03/hexo-install-and-deploy/"/>
    <url>/2023/12/03/hexo-install-and-deploy/</url>
    
    <content type="html"><![CDATA[<p>一时间还没想好要写哪些东西，万事开头难嘛，既然这样，咱就先记录下烂大街的Hexo安装与部署吧。</p><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>我们可以将我们的blog理解成一个app，Hexo项目就是这个app的框架工程源码，通过Node.js进行编译打包，最终生成产品发布到GitHub上被人查看使用。</p><h1 id="安装Git-注册GitHub账号"><a href="#安装Git-注册GitHub账号" class="headerlink" title="安装Git&amp;注册GitHub账号"></a>安装Git&amp;注册GitHub账号</h1><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>传送门：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a><br>作用：用于管理Hexo生成的文件，对接GitHub</p><h2 id="注册GitHub账号"><a href="#注册GitHub账号" class="headerlink" title="注册GitHub账号"></a>注册GitHub账号</h2><p>传送门：<a href="https://github.com/">https://github.com/</a><br>作用：托管Hexo生成的文件，并提供GitHub Page服务，让blog可以被别人浏览  </p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// 校验安装</span><br>git --<span class="hljs-keyword">version</span><br></code></pre></td></tr></table></figure><h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><p>传送门：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a><br>Node.js是一个跨平台的基于Chrome V8引擎的JavaScript运行环境，它可以让JS脚本可以脱离浏览器执行。这么说如果还是不太理解的话，把他理解成Python就可以<br>为啥需要Node.js呢，有两个原因：</p><ul><li>Hexo是基于Node.js作为构建系统来生成网页</li><li>Hexo可以使用npm来下载安装</li><li>等等，这里npm又是啥？别慌，npm是Node.js的包管理器，理解成pip之于Python。最近的Node.js在安装的时候已经会一起安装npm了</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">// 校验安装<br><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br>npm -v<br></code></pre></td></tr></table></figure><h1 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h1><p>使用npm进行安装：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">// -g参数表示将hexo-<span class="hljs-keyword">cli</span>作为全局(<span class="hljs-meta">global</span>)包安装，hexo-<span class="hljs-keyword">cli</span>中的二进制文件加入到PATH中，方便终端调用hexo命令<br>// 全局安装还可以使得在创建其他Node<span class="hljs-number">.</span><span class="hljs-keyword">js</span>项目的时候也方便引用到<br>npm install hexo-<span class="hljs-keyword">cli</span> -g<br></code></pre></td></tr></table></figure><h1 id="创建Hexo项目"><a href="#创建Hexo项目" class="headerlink" title="创建Hexo项目"></a>创建Hexo项目</h1><p>1.在你喜欢的地方创建一个文件夹，例如桌面上，就叫做hexo_blog吧<br>2.cd到该目录<br>3.执行命令，创建Hexo项目</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 创建Hexo项目</span><br>hexo <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p>4.执行命令，在本地生成网页产物</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// 生成网页产物</span><br>hexo <span class="hljs-keyword">generate</span><br></code></pre></td></tr></table></figure><p>5.执行命令，启动本地服务器查看</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">// 启动本地server</span><br>hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>6.在浏览器中打开 <a href="http://localhost:4000/">http://localhost:4000/</a> 查看效果<br>不出意外的话，恭喜，已经曙光初现了，接下来就是将我们的blog发布到GitHub Page上供别人浏览了</p><h1 id="部署到GitHub-Page"><a href="#部署到GitHub-Page" class="headerlink" title="部署到GitHub Page"></a>部署到GitHub Page</h1><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>之前我们创建了GitHub账号，我们新建一个仓库<br><img src="/../images/image.png" alt="Alt text"><br><img src="/../images/image-1.png" alt="Alt text"></p><h2 id="配置SSH密钥"><a href="#配置SSH密钥" class="headerlink" title="配置SSH密钥"></a>配置SSH密钥</h2><p>等等，啥是SSH，啥是密钥？我们要把本地的Hexo产物文件push到GitHub，是通过ssh的方式。那GitHub肯定需要鉴权把。鉴权我们可以使用账号密码，但是如果每次push都要输入账号密码，那想想都很痛苦。<br>那有没有更加轻松的方式呢？GitHub很贴心的为你想好啦，我们只要把我们的设备添加到GitHub的信任名单中，那就不用每次都输入账号密码了，so easy!<br>那么，GitHub是怎么信任咱们的设备呢，它需要一个凭证，这个凭证就是SSH密钥。通过SSH密钥能够唯一标识请求来自于这台设备。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 生成ssh密钥，引号中的内容是注释，可以写我们自己的邮箱账号<br><span class="hljs-regexp">//</span> 一路回车即可，记录下保存密钥的文件，例如~<span class="hljs-regexp">/.ssh/i</span>d_rsa，对应的公钥就是~<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub<br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;your email@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>查看公钥并复制到剪切板中，然后按找到下面的位置将公钥粘贴进去<br><img src="/../images/image-2.png" alt="Alt text"><br><img src="/../images/image-3.png" alt="Alt text"><br><img src="/../images/image-4.png" alt="Alt text"><br><img src="/../images/image-5.png" alt="Alt text"><br>测试下添加是否成功</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// 当出现提示时回车即可</span><br>ssh -T <span class="hljs-symbol">git@</span>github.com<br></code></pre></td></tr></table></figure><h2 id="配置Git个人信息"><a href="#配置Git个人信息" class="headerlink" title="配置Git个人信息"></a>配置Git个人信息</h2><p>上面的ssh密钥只是前提条件，GitHub在我们push文件时还会根据邮箱和用户名做校验，因而需要设置下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;此处填你的用户名&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;此处填你的邮箱&quot;</span><br></code></pre></td></tr></table></figure><h2 id="将Hexo部署到GitHub-Page"><a href="#将Hexo部署到GitHub-Page" class="headerlink" title="将Hexo部署到GitHub Page"></a>将Hexo部署到GitHub Page</h2><p>首先，回到我们之前在GitHub上创建的仓库，复制我们仓库的ssh地址<br><img src="/../images/image-6.png" alt="Alt text"><br>打开我们创建的Hexo项目中的_config.yml文件(推荐Visual Studio Code，后续写blog也很方便)，找到如下入位置进行修改<br><img src="/../images/image-12.png" alt="Alt text"><br><img src="/../images/image-11.png" alt="Alt text"></p><p><strong>敲黑板！！注意branch不要填入master，要填入main。</strong> 分支填错会就看不到了页面了，GitHub Page使用默认分支部署。不知道啥时候开始，GitHub为了zzzq把默认分支的名称从master修改为main了QAQ  </p><p>我们还需要安装一个hexo部署到git的插件来完成最终部署，进入到我们之前创建的Hexo项目目录中，执行：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span> 这里<span class="hljs-params">--save</span>是将该插件添加到Hexo项目的依赖中，记录到package.json<br>npm install hexo-deployer-git <span class="hljs-params">--save</span><br></code></pre></td></tr></table></figure><p>最后一步，激动人心的时刻就要到了，执行</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g -d</span><br></code></pre></td></tr></table></figure><p>完成之后，访问user_name.github.io（user_name替换成你自己的GitHub账号名称），我们就可以看到我们的blog啦，完结撒花~~~~</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇正式的blog</title>
    <link href="/2023/12/03/first_blog/"/>
    <url>/2023/12/03/first_blog/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到我的blog，从今天起，开始正式坚持写blog，记录下工作生活中遇到的一些问题，同时也希望分享一些有价值的经验。<br>作为一个曾经幻想着推动人类文明进步的孩子，到现在休息日只想躺着的废柴，终究还是被现实磨平了棱角。<br>那至少，希望用技术创造一些有价值的东西吧。<br>emmm，虽然也很难就是了，但梦想还是要有的嘛，万一呢</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hello</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
