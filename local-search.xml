<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Swift进阶-结构体和类</title>
    <link href="/2023/12/23/swift-advance-struct-and-class/"/>
    <url>/2023/12/23/swift-advance-struct-and-class/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>结构体是值类型，类是引用类型。</p><h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><ul><li>值类型：当赋值时会被copy一份，也就是说，每个值类型变量的数据都是独立的，其变量本身的地址中存储的就是值，具有这种行为的类型称为具有<strong>值语义</strong></li><li>引用类型，变量本身的地址存储的是值的引用（可能是地址，也可能是其他的间接句柄），而非值，具有这种行为的类型称为具有引用语义</li><li>说白了还是和其他语言一样，就是直接存储值还是存储地址的区别</li></ul><h2 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h2><ul><li>对struct中的属性修改，本质是创建了一个新的struct替换了原来的struct</li><li>推荐使用var来声明struct中的属性</li><li>struct中的方法默认不能修改结构体本身，如有必要，添加mutating关键字。属性和下标的stter默认都是mutating的</li><li>调用struct的mutating方法，要求struct本身是var的。如果要调用一个let的struct属性setter，可以将该setter标记为nonmutating set，告知编译器该setter不会修改struct</li><li>inout参数：实际的过程是先copy参数，然后修改参数，最后用修改完的参数覆盖原来的值。编译器有时会将这种行为优化为传递引用，但不要依赖这种行为。并且，如果使用了观察者，则无论在函数中修改了多少次，只会在最终被覆盖的时候得到通知</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li>结构体的生命周期很简单，就是含有结构体实例变量的生命周期一致，一旦离开作用域就会被销毁</li><li>类的生命周期，取决于ARC</li><li>由于结构体不存在引用，所以也就无所谓结构体的循环引用问题</li><li>打破类的循环引用，weak或unowned</li><li>unowened实际的作用就是不持有引用，所以允许我们声明为非可选值，而weak引用必须声明为可选值。但是<strong>unowned不安全</strong>，如果释放之后再访问unowned会崩溃（是runtime崩溃，而不是badaccess崩溃，类似于断言）！！！虽然这里Swift只要unowned引用还存在，对象内存就不会释放，但是会标记为无效，即所谓僵尸内存</li><li>Swift中，类不是唯一的引用类型，actor以及函数（包括闭包表达式&amp;方法）都是引用类型</li><li>捕获列表，实际就是常用的在闭包中使用的[weak self]，但是捕获列表中还可以直接创建变量，例如<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Swift">window<span class="hljs-operator">?</span>.onRotate <span class="hljs-operator">=</span> &#123; [<span class="hljs-keyword">weak</span> view, <span class="hljs-keyword">weak</span> myWindow<span class="hljs-operator">=</span>window, x<span class="hljs-operator">=</span><span class="hljs-number">5</span><span class="hljs-operator">*</span><span class="hljs-number">5</span>] <span class="hljs-keyword">in</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="在struct和class中做选择"><a href="#在struct和class中做选择" class="headerlink" title="在struct和class中做选择"></a>在struct和class中做选择</h2><ul><li>结构体的优点是开销小，不用担心循环引用、多线程、继承问题，缺点不如类具有共享的特性</li><li>类则更加灵活和强大，可以使用类实现结构体的值语义，反之则不行</li></ul><h2 id="具有值语义的类"><a href="#具有值语义的类" class="headerlink" title="具有值语义的类"></a>具有值语义的类</h2><ul><li>我们可以final class，并将其中的属性都声明为let来实现值语义（嘛，这显然没有结构体好用</li></ul><h2 id="具有引用语义的结构体"><a href="#具有引用语义的结构体" class="headerlink" title="具有引用语义的结构体"></a>具有引用语义的结构体</h2><ul><li>可以在struct中使用类属性实现引用语义</li><li>所以在strcut中使用类属性要小心，不然可能会意外修改其值语义</li><li>这种设计可以被用于实现COW，见下</li></ul><h2 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h2><ul><li>即COW，实际的意思就是修改时才发生真正的复制，很常见的优化</li><li>自己实现COW，我们需要知道一般的实现原理：在没有发生修改之前，各变量都持有的值的内部都共享一份引用，如果一旦发生修改内部共享存储的行为（调用了set方法或者其他什么的），就将原来的内部共享存储进行copy，修改该copy属性</li><li>查询Swift的引用类型是否只有一个持有者：isKnownUniquelyReferenced，但是注意该函数不是线程安全的，所以多线程对数组append是非线程安全的，该函数的参数是个inout参数，否则在传递参数的时候肯定会进行一次引用，函数功能就失效了<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">HTTPRequest</span> &#123;<br>    <span class="hljs-comment">// 内部判断是否触发copy以实现COW</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> storageForWriting: <span class="hljs-type">HTTPRequest</span>.<span class="hljs-type">Storage</span> &#123;<br>        <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-operator">!</span><span class="hljs-built_in">isKnownUniquelyReferenced</span>(<span class="hljs-operator">&amp;</span>storage) &#123;<br>            <span class="hljs-keyword">self</span>.storage <span class="hljs-operator">=</span> storage.copy()<br>            &#125;<br>            <span class="hljs-keyword">return</span> storage<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> path: <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123; storage.path &#125;<br>        <span class="hljs-keyword">set</span> &#123; storageForWriting.path <span class="hljs-operator">=</span> newValue &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> headers: [<span class="hljs-type">String</span>: <span class="hljs-type">String</span>] &#123;<br>        <span class="hljs-keyword">get</span> &#123; storage.headers &#125;<br>        <span class="hljs-keyword">set</span> &#123; storageForWriting.headers <span class="hljs-operator">=</span> newValue &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>注意willSet会导致COW性能的破坏，因为如果实现了willSet，则编译器在设置新值之前一定会先创建值，那么会导致值中的共享存储的引用增加，导致判断失效，导致必然发生复制</li><li>在SwiftUI中，由于@Pushlied使用了willSet，所以会造成一些性能问题，每次修改@Published属性，都会导致数组的copy</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-属性</title>
    <link href="/2023/12/23/swift-advance-property/"/>
    <url>/2023/12/23/swift-advance-property/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Swift属性分为存储属性和计算属性，属性可以被看做是一种定义在类型上的变量。</p><h2 id="变更观察者"><a href="#变更观察者" class="headerlink" title="变更观察者"></a>变更观察者</h2><ul><li>为属性和变量实现willSet和didSet方法</li><li>观察方法必须在声明属性时就进行定义，而不能在扩展中添加。注意和OC中KVO不同。KVO是外部用来跟踪对象内部变化的手段</li><li>观察者可以在子类中重写属性以实现观察者</li><li>Swift的观察者是纯编译时特性，而KVO则是OC利用runtime实现的动态特性</li></ul><h2 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h2><ul><li>使用lazy var修饰，只有当第一次使用时才会被创建（仅调用1次）</li><li>扩展中只能声明计算属性，不能声明存储&amp;延迟存储属性</li><li>lazy var是mutating性质的，所以如果访问结构体的延迟存储属性，必须将结构体声明为var，所以通常不要在结构体中声明lazy var</li><li>注意，<strong>lazy var存在线程安全问题，多线程情况下可能会被调用多次！！！</strong>，在oc中，懒加载属性实行可能会在多线程情况下造成崩溃<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-comment">// 如果多线程调用，那么当A线程对_object属性覆盖的时候，可能将会导致B线程的_object被提前释放，如果此时B线程恰好正在对释放之前的地址进行发消息，就会造成崩溃</span><br>- (NSObject *)<span class="hljs-keyword">object</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-number">_</span><span class="hljs-keyword">object</span>) &#123;<br>        <span class="hljs-number">_</span><span class="hljs-keyword">object</span> = [NSObject <span class="hljs-keyword">new</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">_</span><span class="hljs-keyword">object</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>需要谨记，在OC中，读取&amp;设置属性在runtime层面上都不是原子性的，如果存在多线程访问，需要考虑崩溃问题</li></ul><h2 id="属性包装"><a href="#属性包装" class="headerlink" title="属性包装"></a>属性包装</h2><ul><li>和resultBuilder一样，propertyWrapper也是很大程度上就是因为SwiftUI而引入的</li><li>当我们使用propertyWrapper时，其实就是告知编译器向对该属性封装为一个结构体&#x2F;类，对该属性的存取转换为对该结构体&#x2F;类中init和属性计算方法的调用<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">@propertyWrapper</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>&lt;<span class="hljs-title class_">A</span>&gt; &#123;<br>    <span class="hljs-keyword">var</span> wrappedValue: <span class="hljs-type">A</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">wrappedValue</span>: <span class="hljs-type">A</span>) &#123;<br>        <span class="hljs-keyword">self</span>.wrappedValue <span class="hljs-operator">=</span> wrappedValue<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>在SwiftUI中，@State中的管理的值实际是被SwiftUI管理，@Binding的值实际是对应的@State中的值，@Binding并不关心值在哪，值关心setter和ggeter</li><li>投影值，即projectedValue，通过对属性包装调用$而创建</li><li>本质上，@Binding实际也是一个结构体，只不过这个结构体中存储的不是实际的值，而是setter和getter，那么这个setter和getter就是@State的projectValue在创建@Binding时赋值的</li><li>@State&#x2F;@Observedbject -&gt; 投影值 -&gt; @Binding，对@Binding的存取即通过setter&#x2F;getter间接的称为对@State&#x2F;@ObservedObject中属性的存取，就是这么简单~~<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">// 投影值本身，其特殊支出在于存储的东西不是实例而是函数</span><br><span class="hljs-keyword">@propertyWrapper</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Reference</span>&lt;<span class="hljs-title class_">A</span>&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _get: () -&gt; <span class="hljs-type">A</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _set: (<span class="hljs-type">A</span>) -&gt; ()<br>    <br>    <span class="hljs-keyword">var</span> wrappedValue: <span class="hljs-type">A</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            _get()<br>        &#125;<br>        <span class="hljs-keyword">set</span> &#123;<br>            _set(newValue)<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">get</span>: <span class="hljs-keyword">@escaping</span> () -&gt; <span class="hljs-type">A</span>, <span class="hljs-params">set</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">A</span>) -&gt; ()) &#123;<br>        _get <span class="hljs-operator">=</span> <span class="hljs-keyword">get</span><br>        _set <span class="hljs-operator">=</span> <span class="hljs-keyword">set</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义属性包装的投影值</span><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Box</span> &#123;<br>    <span class="hljs-keyword">var</span> projectedValue: <span class="hljs-type">Reference</span>&lt;<span class="hljs-type">A</span>&gt; &#123;<br>        <span class="hljs-type">Reference</span>&lt;<span class="hljs-type">A</span>&gt; &#123; () -&gt; <span class="hljs-type">A</span> <span class="hljs-keyword">in</span><br>            <span class="hljs-keyword">self</span>.wrappedValue<br>        &#125; <span class="hljs-keyword">set</span>: &#123; (i) <span class="hljs-keyword">in</span><br>            <span class="hljs-keyword">self</span>.wrappedValue <span class="hljs-operator">=</span> i<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>有时，我们并不希望将整个wrapperedValu而通过投影值传递，而是希望让传递wrappedValue中的某个属性，那我们不能写成$A.xxx，因为$Type已经是投影类型了，它没有xxx这个属性。方法自然是有的，我们需要为投影类型实现动态成员查找：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">@propertyWrapper</span><br><span class="hljs-keyword">@dynamicMemberLookup</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Reference</span>&lt;<span class="hljs-title class_">A</span>&gt; &#123;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">subscript</span>&lt;<span class="hljs-type">B</span>&gt;(<span class="hljs-params">dynamicMember</span> <span class="hljs-params">keyPath</span>: <span class="hljs-type">WritableKeyPath</span>&lt;<span class="hljs-type">A</span>, <span class="hljs-type">B</span>&gt;)<br>-&gt; <span class="hljs-type">Reference</span>&lt;<span class="hljs-type">B</span>&gt; &#123;<br>    <span class="hljs-type">Reference</span>&lt;<span class="hljs-type">B</span>&gt;(get: &#123;<br>        <span class="hljs-keyword">self</span>.wrappedValue[keyPath: keyPath]<br>    &#125;) &#123;<br>        <span class="hljs-keyword">self</span>.wrappedValue[keyPath: keyPath] <span class="hljs-operator">=</span> <span class="hljs-variable">$0</span><br>    &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>这样，当我们使用$A.xxxx时，就会转换为对Refrerence&lt;A&gt;[dynmiacMembers:\.xxxx]的调用，从而能够获取到对原始实例的存取</li><li>有时，属性只在能够获取到其宿主时才会发挥作用，比如Combine框架中的@Published，它实际上必须要调用宿主的（ObservableObject类型）的objectWillChanged才work，要想实现这种效果，需要通过实现一个特定的subscript方法，这里暂时不详细探究了</li><li>SwiftUI中的@State实际就是必须获取到宿主View的层级才work的</li><li>由于属性包装编译器必须生成存储属性，而enum在case之外是不能放存储属性的，因而enum中不能使用属性包装</li><li>可以在函数中使用属性包装，并且从Swift 5.5开始，也可以将属性包装作为函数参数传递</li></ul><h2 id="键路径"><a href="#键路径" class="headerlink" title="键路径"></a>键路径</h2><ul><li>也就是KeyPath，表示对一个属性为调用的引用，如\Type.xxx，因为Type可能本身有个static的xxx属性，为了区分开，需要加个\。如果可以类型推断，可省略Type，即\.xxx</li><li>KeyPath可以由任意存储属性和计算属性组合，包括可选类型，编译器会自动为为每个类型生成[keyPath:]下标方法</li><li>WriteableKeyPath：可以通过该KeyPath对属性修改，要求原值是可变的</li><li>ReferenceWritableKeyPath：同上，但是针对于引用语义的值</li><li>KeyPath：不可通过该KeyPath对属性修改</li><li>KeyPath还可以用于描述下标操作，如\.[1].name</li><li>KeyPath某种程度上和函数类似，都是给定参数获取值，或者传入参数设置值，但是KeyPath本身可以比较判等，并且无状态，这和函数不同</li><li>编译器可以自动将KeyPath转换为函数，如xx.map(\.name)等价于xx.map{$0.name}，注意这个仅对直接写的时候有效，如果将KeyPath放到变量中是无效的</li><li>KeyPath还可以组合，需要注意类型必须要匹配<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs julia">// KeyPath&lt;Person, <span class="hljs-built_in">String</span>&gt; + KeyPath&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Int</span>&gt; = KeyPath&lt;Person, <span class="hljs-built_in">Int</span>&gt;<br><span class="hljs-keyword">let</span> nameCountKeyPath = nameKeyPath.appending(path: \.count)<br>// Swift.KeyPath&lt;Person, Swift.<span class="hljs-built_in">Int</span>&gt;<br></code></pre></td></tr></table></figure></li><li>可写的KeyPath在SwiftUI中很常见，比如通过其修改环境值，在之前也看到过结合投影类型的动态成员查找，方便实现任意属性的投影</li><li>总结下5种类型的KeyPath，其中WritableKeyPath和ReferenceWritableKeyPath进行区分是必要的，前一个类型的setter要求它的参数是inout的<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-type">AnyKeyPath</span> like (<span class="hljs-keyword">Any</span>) -&gt; <span class="hljs-keyword">Any</span><span class="hljs-operator">?</span><br><span class="hljs-type">PartialKeyPath</span>&lt;<span class="hljs-type">Source</span>&gt; like (<span class="hljs-type">Source</span>) -&gt; <span class="hljs-keyword">Any</span><span class="hljs-operator">?</span><br><span class="hljs-type">KeyPath</span>&lt;<span class="hljs-type">Source</span>, <span class="hljs-type">Target</span>&gt; like (<span class="hljs-type">Source</span>) -&gt; <span class="hljs-type">Target</span><br><span class="hljs-type">WritableKeyPath</span>&lt;<span class="hljs-type">Source</span>, <span class="hljs-type">Target</span>&gt; like (<span class="hljs-type">Source</span>) -&gt; <span class="hljs-type">Target</span> and (<span class="hljs-keyword">inout</span> <span class="hljs-type">Source</span>,     <span class="hljs-type">Target</span>) -&gt; ()<br><span class="hljs-comment">// 这一对函数相似。第二个函数可以用Target来更新Source值且要求 Source 是一个引用类型 </span><br><span class="hljs-type">ReferenceWritableKeyPath</span>&lt;<span class="hljs-type">Source</span>, <span class="hljs-type">Target</span>&gt; like (<span class="hljs-type">Source</span>) -&gt; <span class="hljs-type">Target</span> and (<span class="hljs-type">Source</span>, <span class="hljs-type">Target</span>) -&gt; ()<br></code></pre></td></tr></table></figure></li><li>相比于OC，OC的键路径是通过字符串实现的，并且没有类型约束，魔种程度上类似于AnyKeyPath，但是不安全</li><li>KeyPath目前还存在性能问题，比直接访问要慢（因为毕竟是动态嘛…</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-函数</title>
    <link href="/2023/12/21/swift-advance-function/"/>
    <url>/2023/12/21/swift-advance-function/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>函数在Swift中和类一样，都是头等公民，可以被赋值给变量，可以被传递，可以捕获外部变量。当函数捕获变量时，可以视作函数和被捕获的变量构成了一个类对象（但是函数不可比较）。<br>函数既可以使用func关键字声明，也可以用闭包表达式来声明，eg.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">let</span> f <span class="hljs-operator">=</span> &#123;(i: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">return</span> i <span class="hljs-operator">*</span> <span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><p>闭包表达式与func的主要区别在于闭包是匿名的，只能被赋值给变量或者作为参数传递。<br>在Swift中，函数&#x3D;&#x3D;闭包，没什么不同，只是写的形式可能有区别。</p><h2 id="函数的灵活性"><a href="#函数的灵活性" class="headerlink" title="函数的灵活性"></a>函数的灵活性</h2><ul><li>如何实现复杂的排序规则，在OC中，可以通过NSSortDescriptor，但仅限于NSObject类，在Swift中使用高阶函数可以完成</li><li>(Value) -&gt; (Value) -&gt; ComparisonResult的含义实际上就是(Value) -&gt; ((Value) -&gt; ComparisonResult)，即给定一个值，返回一个闭包<br>看一个例子：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SortDescriptor</span>&lt;<span class="hljs-title class_">Root</span>&gt; &#123;<br>    <span class="hljs-keyword">var</span> areInIncreasingOrder: (<span class="hljs-type">Root</span>, <span class="hljs-type">Root</span>) -&gt; <span class="hljs-type">Bool</span><br>&#125;<br><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">SortDescriptor</span> &#123;<br>    <span class="hljs-keyword">init</span>&lt;<span class="hljs-type">Value</span>&gt;(<span class="hljs-params">key</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Root</span>) -&gt; <span class="hljs-type">Value</span>,<br>                <span class="hljs-params">compare</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Value</span>) -&gt; ((<span class="hljs-type">Value</span>) -&gt; <span class="hljs-type">ComparisonResult</span>)) &#123;<br>        <span class="hljs-comment">// 注意这里$0和$1表示的是areInIncreasingOrder的两个参数</span><br>        <span class="hljs-keyword">self</span>.areInIncreasingOrder <span class="hljs-operator">=</span> &#123;<br>            compare(key(<span class="hljs-variable">$0</span>))(key(<span class="hljs-variable">$1</span>)) <span class="hljs-operator">==</span> .orderedAscending<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> sortByFirstName: <span class="hljs-type">SortDescriptor</span>&lt;<span class="hljs-type">Person</span>&gt; <span class="hljs-operator">=</span> .<span class="hljs-keyword">init</span>(key: &#123;<span class="hljs-variable">$0</span>.first&#125;, compare: <span class="hljs-type">String</span>.localizedStandardCompare)<br></code></pre></td></tr></table></figure>这里String.localizedStandardCompare的类型就是(String) -&gt; (String) -&gt; ComparisonResult，它等价于string1.localizedStandardCompare(string2)<br>通过高阶函数+泛型，我们可以方便的生成普适性的函数&#x2F;闭包，从而达到简洁的效果。（但是有时也会加大理解负担）</li><li>还可以通过将SortDescriptor进行封装组合，形成更加强大复杂的排序方式，比如<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">SortDescriptor</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">then</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">other</span>: <span class="hljs-type">SortDescriptor</span>&lt;<span class="hljs-type">Root</span>&gt;) -&gt; <span class="hljs-type">SortDescriptor</span>&lt;<span class="hljs-type">Root</span>&gt; &#123;<br>        <span class="hljs-type">SortDescriptor</span> &#123; x, y <span class="hljs-keyword">in</span><br>        <span class="hljs-keyword">if</span> areInIncreasingOrder(x,y) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br>        <span class="hljs-keyword">if</span> areInIncreasingOrder(y,x) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>        <span class="hljs-keyword">return</span> other.areInIncreasingOrder(x,y)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>这里使用then将descriptor进行组合，实际类似于java中的builder模式，在最后调用的时候，按照从里到外的顺序调用每个desriptor的areInIncreasingOrder方法</li></ul><h2 id="函数作为代理"><a href="#函数作为代理" class="headerlink" title="函数作为代理"></a>函数作为代理</h2><ul><li>如果只需要一个函数作为回调，那么使用函数而不需要使用代理</li><li><strong>Swift中的闭包捕获的变量类比于OC来说默认是__block的</strong>，既可以影响外部被捕获的值，而不是copy</li></ul><h2 id="inout参数和可变方法"><a href="#inout参数和可变方法" class="headerlink" title="inout参数和可变方法"></a>inout参数和可变方法</h2><ul><li>inout参数实际上并不是直接修改原来的参数，而是先copy，然后修改，再将修改完之后的值copy回去（但是编译器可能优化为传地址，但是不应依赖该行为）</li><li>只能使用var作为inout参数：肯定啊，不然咋修改</li><li>数组下标也可以作为inout参数，实际上，支持set&#x2F;get的所有下标操作都能被作为inout参数</li><li>在嵌套函数中也可以使用inout，但是嵌套函数不能逃逸</li><li>如果参数声明为UnsafeXXXPointer，则&amp;表示取指针而不是inout参数</li></ul><h2 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h2><ul><li>subscript函数</li><li>参数后…表示可变长度参数，可作为数组使用</li></ul><h2 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h2><ul><li>@autoclosure告知编译器，应当将传入的表达式转换为闭包，eg.<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">and</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">l</span>: <span class="hljs-type">Bool</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">r</span>: <span class="hljs-keyword">@autoclosure</span> () -&gt; <span class="hljs-type">Bool</span>) -&gt; <span class="hljs-type">Bool</span> &#123;<br>    <span class="hljs-keyword">guard</span> l <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-keyword">return</span> r()<br>&#125;<br><br><span class="hljs-keyword">if</span> and(<span class="hljs-operator">!</span>evens.isEmpty, evens[<span class="hljs-number">0</span>] <span class="hljs-operator">&gt;</span> <span class="hljs-number">10</span>) &#123;<br>    <span class="hljs-comment">// 执行操作</span><br>&#125; <br></code></pre></td></tr></table></figure></li><li>#fileId, #function, #line在编译器中表示<strong>调用者</strong>的文件名、函数名和行号</li></ul><h2 id="escaping"><a href="#escaping" class="headerlink" title="@escaping"></a>@escaping</h2><ul><li>表示作为参数传递的闭包可以被保存并在稍后使用</li><li>闭包参数如果是直接参数，默认是非escaping的，但可选值类型、存储属性、封装在元组中的闭包是escaping的</li><li>有时我们确实知道闭包时不会逃逸的，但又不想传递可选值，那么可以使用withoutActuallyEscaping来告知编译器,但是安全性需要自己保证：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Array</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">allSatisfy2</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">predicate</span>: (<span class="hljs-type">Element</span>) -&gt; <span class="hljs-type">Bool</span>) -&gt; <span class="hljs-type">Bool</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">withoutActuallyEscaping</span>(predicate) &#123; escapablePredicate <span class="hljs-keyword">in</span><br>        <span class="hljs-keyword">self</span>.lazy.filter &#123; <span class="hljs-operator">!</span>escapablePredicate(<span class="hljs-variable">$0</span>) &#125;.isEmpty<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="ResultBuilder"><a href="#ResultBuilder" class="headerlink" title="ResultBuilder"></a>ResultBuilder</h2><ul><li>当编译器遇到ResultBuilder注解时，会将被注解函数表达式转换对特定结构体中函数的调用，从而得到最终结果，最典型的例子就是SwiftUI中的ViewBuilder，这可能也是ResultBuilder被引入的动机之一<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">@inlinable</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">alignment</span>: <span class="hljs-type">VerticalAlignment</span> <span class="hljs-operator">=</span> .center, <span class="hljs-params">spacing</span>: <span class="hljs-type">CGFloat</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>, <span class="hljs-meta">@ViewBuilder</span> <span class="hljs-params">content</span>: () -&gt; <span class="hljs-type">Content</span>)<br></code></pre></td></tr></table></figure></li><li>实际上，Swift会将@ViewBuilder注解函数中的表达式转换为调用ViewBuilder结构体中的buildBlock的函数调用，等价于<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">@resultBuilder</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ViewBuilder</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">buildBlock</span>&lt;<span class="hljs-type">C0</span>, <span class="hljs-type">C1</span>, <span class="hljs-type">C2</span>&gt;(<span class="hljs-keyword">_</span> <span class="hljs-params">c0</span>: <span class="hljs-type">C0</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">c1</span>: <span class="hljs-type">C1</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">c2</span>: <span class="hljs-type">C2</span>)<br>    -&gt; <span class="hljs-type">TupleView</span>&lt;(<span class="hljs-type">C0</span>, <span class="hljs-type">C1</span>, <span class="hljs-type">C2</span>)&gt;<br>    <span class="hljs-keyword">where</span> <span class="hljs-type">C0</span>: <span class="hljs-type">View</span>, <span class="hljs-type">C1</span>: <span class="hljs-type">View</span>, <span class="hljs-type">C2</span>: <span class="hljs-type">View</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>注意ViewBuilder前面的注解@resultBuilder，其可以实现一系列不同的buildXXX方法</li><li>注意@resultBuilder注解时Swift 5.4引入的</li><li>最基本的方法是buildBlock和buildExperssion，@resultBuilder要求至少实现一个buildBlock方法</li><li>buildBlock中的参数和类型并不要求一致，但是如果想要函数支持多种类型，使用buildExpression时更加优雅的方式，其作用是在将参数传递给buildXXX之前先应用该函数进行转换</li><li>通过重载buildExpression方法，我们可以实现一些特殊逻辑，比如一般builder函数（即被标记为@XXXBuilder的函数）中是不能调用print方法的，因为print方法返回的是Void。我们可以添加一个将Void转换为需要参数类型的buildExpression来绕过</li><li>@available注解格式<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">@available</span>(版本范围, 可用性, message: 错误消息)<br></code></pre></td></tr></table></figure></li><li>builder还可以通过实现buildIf和buildEither来支持if，if else和switch语句<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">// 支持单个if，因为if语句要么有值，要么值为nil，所以参数是可选值类型</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">buildIf</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">s</span>: <span class="hljs-type">String</span>?) -&gt; <span class="hljs-type">String</span> &#123;<br>    s <span class="hljs-operator">??</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 支持if else的if分支，要求if分支必须返回是String</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">buildEither</span>(<span class="hljs-params">first</span> <span class="hljs-params">component</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> &#123;<br>    component<br>&#125;<br><br><span class="hljs-comment">// 支持if else的else分支，要求else分支必须返回是String</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">buildEither</span>(<span class="hljs-params">second</span> <span class="hljs-params">component</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> &#123;<br>    component<br>&#125;<br><br><span class="hljs-comment">// 实现了if else，switch是实现了，switch也可以看做是if else的嵌套调用，但是实际上switch除了第一个case是buildEither(first:)，其余分支都是buildEdither(second:)</span><br></code></pre></td></tr></table></figure></li><li>builder还可以支持循环<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">buildArray</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">components</span>: [<span class="hljs-type">String</span>]) -&gt; <span class="hljs-type">String</span> &#123;<br>    components.joined(separator: <span class="hljs-string">&quot;&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>buildFindalResult:将会在builder函数的最后的结果被应用</li><li>resultBuilder不支持guard、defer、do…catch等，因为这些语句无法被求值</li><li>总结：通过实现一系列build方法，创建一个XXXBuilder，通过@XXXBuilder将函数&#x2F;闭包转换为对build方法的调用，从而实现自定义DSL的效果</li><li>所以为啥View中的body能返回不同类型的View呢，<strong>实际上View的body就是@ViewBuilder</strong>，但是并不是任何属性都具有该特特性，正常情况下，<strong>某个标记为some View的属性需要返回相同类型的View</strong>，我们可以加上@ViewBuilder注解（因为some View就是某种特定具体类型的View，所以如果返回的类型不同，自然无法编译通过，<strong>通过加上ViewBuilder注解让编译器帮我们将表达式转换为统一的封装类型</strong>就OK了~~）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-可选值</title>
    <link href="/2023/12/20/swift-advance-optional-value/"/>
    <url>/2023/12/20/swift-advance-optional-value/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分主要介绍Swift中可选值的底层原理</p><h2 id="哨岗值"><a href="#哨岗值" class="headerlink" title="哨岗值"></a>哨岗值</h2><ul><li>在许多时候，函数在没有读取到有效值后需要返回给我们一个特定的值，称为哨岗值，比如EOF、-1、null等等</li><li>哨岗值有时是有效的值，比如-1，但有时候这种情况会导致错误的结果，比如OC对nil发消息，如果方法返回的是结构体，则会是一个值全部为0的结构体，这时有可能导致逻辑错误,eg<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-built_in">NSString</span> *someString = ...;<br><span class="hljs-keyword">if</span> ([someString rangeOfString:<span class="hljs-string">@&quot;Swift&quot;</span>].location != <span class="hljs-built_in">NSNotFound</span>) &#123;<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Someone mentioned Swift!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>如果someString是nil，location就会是0而不是NSNotFound（是NSIntegerMax），显然是错误的。</li><li>哨岗值还依赖约定，如果不知道约定，则无法使用。</li><li>Swift通过枚举实现Optional来解决哨岗值的问题,没错，可选值的本质实际就是带有关联值的Swift枚举<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Optional</span>&lt;<span class="hljs-title class_">Wrapped</span>&gt; &#123;<br><span class="hljs-keyword">case</span> none<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">some</span>(<span class="hljs-type">Wrapped</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>Swift中对于可能是哨岗值的返回的都是可选值，从而避免了必须了解哨岗值约定的问题</li><li>语法糖使得使用可选值更加方便：<ul><li>Type? &#x3D; Optional<Type></li><li>nil &#x3D; .none(因为可选值遵守ExpressibleByNilLiteral协议，即可用nil表示)</li><li>在必要时，非可选值会自动封装为可选值，不需要手动调用.some(Type)，比如函数的返回类型标记为可选值类型</li></ul></li><li>可选值匹配：<ul><li>匹配值：switch .some(let v)或者swifth let v?</li><li>匹配nil：switch .none或者switch nil</li></ul></li></ul><h2 id="可选值概览"><a href="#可选值概览" class="headerlink" title="可选值概览"></a>可选值概览</h2><ul><li>if let:可选值绑定,略</li><li>while let:当遇到nil时终止</li><li>双重可选值：即Type??，实际就是Optional(Optional(value))<ul><li>case let v? &#x3D; case let .some(v)，仅匹配值</li></ul></li><li>case实际上的匹配功能很强大，比如 case 0..&lt;10 &#x3D; j可以检查j是否在范围内</li><li>if var&#x2F;while var:可变版本，使得我们在if语句中可以修改变量</li><li>在作用域之外使用解包后的值：使用guard let语句，其else路径必须是要求离开当前作用域，如return或者调用一个Never函数</li><li>返回Never（又称为无人类型）的函数向编译器表明自己绝对不会返回，如fatalError或者dispatchMain;又或者对应的值绝对不会出现，比如将泛型指定为Never</li><li>Never实际在Swift中就是个enum<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Never</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li>Never和Void是不同的，Void实际是空元祖()</li><li>总结，不存在是nil，存在且为空Void，绝对不会发生Never</li><li>在OC中，对nil发消息不会发生，在Swift中，使用可选链实现，如v?.callback(),<strong>可选链的调用结果一定是可选值</strong></li><li>对于可选值成员，默认值是nil，这是Swift中对于成员成员初始化的<strong>唯一例外</strong>。注意这个默认行为支队x?的形式有效，如果写成了Optional<T>就无效了，还是必须初始化</li><li>可选链和赋值：可以使用可选链来对可选值进行赋值，如<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> a: <span class="hljs-type">Int</span>?<br>a<span class="hljs-operator">?+=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>注意不能写成，因为可选值绑定对值类型来说是复制<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> a: <span class="hljs-type">Int</span>? <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">var</span> a <span class="hljs-operator">=</span> a &#123;<br>    <span class="hljs-comment">// 无法改变外层的a</span><br>    a<span class="hljs-operator">+=</span><span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>nil合并操作符：??,略，注意??也是短路操作符</li><li>可选值提供了一个map方法，方便我们在不为nil的请款修改进行转换，注意因为是Optional本身提供的方法，所以调用的时候不能加?,eg.arr.first.map{…}（注意，只要是可选值，就可以调用该map方法，不要求可选值是集合类型！！），但是注意，即使如此，<strong>返回的仍然是可选值类型</strong></li><li>flatMap：如果变换本身返回了可选值类型，那么map得到的结果则是双重可选值，为了去掉一层，可以使用flatMap，注意可选值的类型上也是直接定义了flatMap</li><li>compactMap：可以将变换后为nil的可选值给筛掉</li><li>可选值判等：如果可选值封装的类型符合Equatable，则对应的可选值类型也是Equatable的，所以我们可以方便的判等：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> a: <span class="hljs-type">Int</span>? <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>a <span class="hljs-operator">==</span> <span class="hljs-number">0</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>这里work的原因是swift会在必要时将0升级为可选值</li><li>字典中如果直接设置key的value为nil会移除掉key和value，若要插入值nil，可以使用Optional(nil)</li><li>强制解包的使用：一般不要使用，除非预期是在遇到nil时直接crash</li><li>挂起操作的方式：fatalError直接crash、assert在测试版本不符合条件执行并且crash、precondtion和assert一样只不过在正式版也存在</li><li>隐式解包：标记为Type!的类型<ul><li>情景1：oc返回的类型，并且没有标记nullable和nonnull</li><li>情景2：暂时的为空，不如初始化的过程中</li><li>隐式可选值在使用上既可以假定为非可选值不加？，也可以当做可选值加？</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-内建集合类型</title>
    <link href="/2023/12/19/swift-advance-built-in-collection/"/>
    <url>/2023/12/19/swift-advance-built-in-collection/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>虽然在工作中已经大量使用了Swift了，但总感觉自己停留在使用的层面。从今天开始，开始复习Swift Adavance，回忆、理解、总结。</p><p>本章重点介绍了Swift内建的几种集合类型，并讨论如何高效使用。</p><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><ul><li>值语义： Swift中所有的内建集合类型都具有值语义，数组当然也不例外。值语义的典型表现是当其被赋值给一个变量时，将发生复制。</li><li>使用let和var来表示数组是不可变数组or可变数组。注意，即使是可变数组，仍然是值类型。这和NSMutableArray完全不同。</li><li>Swift编译器会对值语义集合进行优化，如果被赋值给对个变量，只有通过变量修改值时才会发生实际的copy，但我们不应依赖该行为。</li><li>数组越界会直接崩溃。</li><li>数组为空时，调用removeLast会崩溃，但popLast则不会崩溃，而是返回nil。</li><li>支持map、flatMap、filter等函数式编程。</li><li>使用.lazy将变形延迟发生到最终需要结果的时候，比如需要将结果转换为数组输出。</li><li>map：遍历元素，对每个元素应用func得到新集合。</li><li>filter: 遍历元素，删除掉符合func的元素得到新集合。</li><li>reduce: 遍历元素，对每个元素应用和之前的结果应用func得到结果值。</li><li>flatMap: 如果得到的结果外层是数组，则去掉结果外层数组。</li><li>forEach: 遍历元素，应用func但不返回结果。注意func中写return并不会使得遍历停止。</li><li>数组可以切片，类似于python，结果是ArraySlice。但是，<strong>切片完之后的索引和原始数组共享索引和内存</strong>！</li></ul><h2 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h2><ul><li>字典查找总是返回可选值，这和Array不同。</li><li>思想：Array中的索引一般总是通过某种方式计算得到的，一般都是有效的，无效的索引一般意味着开发者的计算失误。所以崩溃就好。但是Dict的key一般是其他取到得来的，比如server下发，所以返回可选值比较好。</li><li>删除值：将对应key的value设置为nil或者removeValue(forKey:),该方法返回删除的value,注意，这同时会将key也给删掉。</li><li>更新值：简单，设置即可，或者使用updateValue(_:forKey:),该方法会返回old value。</li><li>合并dict：merge(_:uniquingKeysWith:),第二个参数是决定决策对于相同的key使用如何获取value的函数，注意<strong>是获取value，而不是选择value</strong>，因为不仅可以选择某一个value，也可以对这两个value进行操作得到新的value。</li><li>mapValues: 对dict的values作map</li><li>Dict的key必须符合Hashable协议。<ul><li>标准库中所有基本数据类型都是Hashable的，如Int、String</li><li>数组、集合或可选值，如果其元素时Hashable，则他们也是Hashable</li><li>结构体和enum，如果是由Hashable的类型组成（对结构体来说，要求存储属性，对enum来说，要求关联值，若无关联值，则默认是Hashable的，不需要声明），只要我们声明他们是Hashable，则Swift会帮我们合成Hashable的实现</li><li>对于通过&#x3D;&#x3D;比较相等的两个对象，hash值必须相同，反之，hash值相同，不一定是相同的对象，因为hash值有限，但对象数量无限，可能存在hash冲突的可能。</li><li>所以一般不要使用可变对象作为key，否则如果对象改变造成hash改变，则会造成dict存储找不到或存储错误。</li></ul></li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul><li>嘛，就是集合</li><li>可以使用数组字面量初始化Set，因为Set遵守ExpressibleByArrayLiteral。</li><li>补集：substring</li><li>交集：intersection</li><li>并集：formUnion，这是union的可变版本，即改变原集合，所有以form开头的版本都是可变版本。</li></ul><h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><ul><li>就是区间</li><li>x..&lt;y左闭右开: Range，只有此类型可以表示空集，如5..&lt;5</li><li>x…y闭区间: ClosedRange,只有此类型可以表示最大值，如0…Int.max，因为Range需要上界是比自身包含的范围还得+1</li><li>Range和ClosedRange都有Bound泛型，Bound需要符合Comparable</li><li>x…，左闭右无界: PratialRangeFrom，可遍历，需自己break<ul><li>对于PartialRangeFrom遍历时，会从下界开始，调用adavanced(by:1)</li></ul></li><li>…y，左无界右闭：PartialRangeThrough，不可遍历</li><li>..&lt;y，左无界右开: PartialRangeUpTo，不可遍历</li><li>检测包含：contains、overlaps</li><li>Range可以遍历，但不能完全遍历emm…，支持遍历的<strong>Range的Bound</strong>需要实现Strideable协议。</li><li>Range必须是可数的才能遍历</li><li>Swift之前为了区分可数还是不可数，引入两个类型，即CountableRange和CountableClosedRange</li><li>所有的Range都满足RangeExpression协议<ul><li>contains：判断元素是否包含在范围中</li><li>relative：对给定集合，能够计算出该集合的Range。<strong>若该RangeExpression缺少上界或者下界，则返回的结果中使用给定集合的startIndex或endIndex作为上界或者下界</strong>。</li><li>所以数组可以使用Range进行切片，原理就是数组的subscript实现了接受RangeExpression作为参数，从而结合自身的startIndex和endIndex得到一个Range，从而执行切片</li></ul></li><li>RangeSet: 即Range的集合，在表示多个区间时更加高效</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo添加Live2D看板娘</title>
    <link href="/2023/12/03/hexo-add-live2d/"/>
    <url>/2023/12/03/hexo-add-live2d/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在浏览别人的blog时，有时可以看到一个类似于下面这个萌萌哒的玩意，这其实是通过Live2D Widget插件实现的。方法也很简单，follow me~<br><img src="/../images/image-19.png" alt="Alt text"></p><h2 id="Step1-安装live-2d插件"><a href="#Step1-安装live-2d插件" class="headerlink" title="Step1 安装live 2d插件"></a>Step1 安装live 2d插件</h2><p>注意，下面的指令都是在Hexo项目目录中使用的</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-helper-live2d</span><br></code></pre></td></tr></table></figure><h2 id="Step2-下载live-2d模型"><a href="#Step2-下载live-2d模型" class="headerlink" title="Step2 下载live 2d模型"></a>Step2 下载live 2d模型</h2><p>通过下载不同的live 2d模型，就可以获得不同的看板娘啦，直接npm下载，贼方便</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">// 下载的model会存放在node_modules中</span><br>npm install live2d-widget-<span class="hljs-keyword">model</span>-tororo<br></code></pre></td></tr></table></figure><h2 id="Step3-配置-config-yml"><a href="#Step3-配置-config-yml" class="headerlink" title="Step3 配置_config.yml"></a>Step3 配置_config.yml</h2><p>添加如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Live2D看板娘</span><br><span class="hljs-attr">live2d:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">pluginModelPath:</span> <span class="hljs-string">assets/</span><br>  <span class="hljs-attr">model:</span><br>    <span class="hljs-comment">#模板目录，在node_modules里</span><br>    <span class="hljs-attr">use:</span> <span class="hljs-string">live2d-widget-model-tororo</span><br>  <span class="hljs-attr">display:</span><br>    <span class="hljs-attr">position:</span> <span class="hljs-string">right</span><br>    <span class="hljs-attr">width:</span> <span class="hljs-number">300</span> <br>    <span class="hljs-attr">height:</span> <span class="hljs-number">600</span><br>  <span class="hljs-attr">mobile:</span><br>    <span class="hljs-comment"># 在手机端显示</span><br>    <span class="hljs-attr">show:</span> <span class="hljs-literal">false</span>   <br>  <span class="hljs-attr">rect:</span><br>    <span class="hljs-string">opacity:0.7</span><br></code></pre></td></tr></table></figure><h2 id="Step4-查看效果"><a href="#Step4-查看效果" class="headerlink" title="Step4 查看效果"></a>Step4 查看效果</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">hexo g <span class="hljs-meta">&amp;&amp; hexo s</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何让Hexo被Google索引到</title>
    <link href="/2023/12/03/about-hexo-google-index/"/>
    <url>/2023/12/03/about-hexo-google-index/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们写blog的目的是让自己的分享被别人看到，如果Google没有收录自己的网址，那么就没有意义了。 本篇文章主要介绍如何让咱们的blog被Google收录。</p><h2 id="Step1-检查收录"><a href="#Step1-检查收录" class="headerlink" title="Step1 检查收录"></a>Step1 检查收录</h2><p>首先检查咱们的blog有没有被Google索引，在搜索框输入site:xxx.github.io，不出意外的话，Google没有收录：<br><img src="/../images/image-13.png" alt="Alt text"></p><h2 id="Step2-验证网址所有权"><a href="#Step2-验证网址所有权" class="headerlink" title="Step2 验证网址所有权"></a>Step2 验证网址所有权</h2><p>按照提示，点击进入Google Search Console，Google会要求验证这个网址的归属权，这里由于采用的GitHub Page，所以按照第二种网址前缀的方式进行验证：<br><img src="/../images/image-14.png" alt="Alt text"><br>接下来，会看到有几种验证的方式，因为不想添加一个乱七八糟的html到网站目录中（强迫症犯了QAQ），所以我选择HTML标记的方式。这种方式会要求我们在index.html的head标签中添加一个meta标签，按照提示复制该标签。<br><img src="/../images/image-15.png" alt="Alt text"><br>接下来，找到Hexo项目的public文件夹下的index.html，将这个标签复制到head标签的末尾。<br><img src="/../images/image-16.png" alt="Alt text"><br>顺便说下，Hexo在部署的就是public文件夹下的内容。<br>我们直接发布，<strong>注意不要generate</strong>，因为generate会重新生成index.html，会将咱们之前的修改给覆盖掉。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">// 直接发布即可</span><br>hexo d<br></code></pre></td></tr></table></figure><p>发布完成之后，稍等1min左右，等待GitHub Page部署完成，点击验证按钮。Congratulations，验证完成~~~<br><img src="/../images/image-17.png" alt="Alt text"></p><h2 id="Step3-添加sitemap-xml"><a href="#Step3-添加sitemap-xml" class="headerlink" title="Step3 添加sitemap.xml"></a>Step3 添加sitemap.xml</h2><p>到上面其实Google已经允许收录咱们的blog了，但是为了Google的蜘蛛机器人更好的爬取到网站的内容，我们可以在网站根目录下放一个sitemap.xml。<br>进入到Hexo项目目录中，安装插件：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-generator-sitemap <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>安装完毕之后，打开_config.yml，添加如下内容</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"># automatically <span class="hljs-keyword">generate</span> sitemap<br>sitemap:<br>  path: sitemap<span class="hljs-variable">.xml</span><br></code></pre></td></tr></table></figure><p>重新生成部署，不再啰嗦啦，hexo g -d一把梭。<br>等待1min。进入到Google Search Console，提交我们的sitemap.xml，如下图，OK收工。<br>但我们这个时候再搜索还是搜不到的，需要等个几天，到时候再来更新~<br><img src="/../images/image-18.png" alt="Alt text"></p><hr><p>12月9日更新，已经可以被索引到了~<br><img src="/../images/image-20.png" alt="Alt text"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Hexo中图片路径问题</title>
    <link href="/2023/12/03/about-hexo-picture-path/"/>
    <url>/2023/12/03/about-hexo-picture-path/</url>
    
    <content type="html"><![CDATA[<p>在编写Hexo时，通常需要粘贴图片到markdown中。默认粘贴的path和咱们的md文件同级别，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![Alt text](image-9.png)</span><br></pre></td></tr></table></figure><p>虽然本地预览没有问题，但是在generate的时候，存在两个问题：<br>1.Hexo会忽略_post下的图片资源<br>2.Hexo会将md文件中的path转换为域名&#x2F;path，例如<a href="http://xxx.github.io/xxx.png">http://xxx.github.io/xxx.png</a><br>这两个问题都会导致无法正常看到我们blog中的图片。  </p><p>问题解决：<br>1.在source下新建images文件夹，专门用来存放图片<br>2.Hexo中使用images&#x2F;xxx.png来引用该图片</p><p>那么还是有问题，在使用VS Code粘贴图片时，还是默认粘贴到_posts下面，这样每次都要移动图片和修改路径，很麻烦。没错，贴心的VS Code可以自定义粘贴的路径，使用cmd+,打开设置，找到如下界面设置默认的粘贴路径：<br><img src="/../images/image-10.png" alt="Alt text"><br>完成！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo的安装与部署</title>
    <link href="/2023/12/03/hexo-install-and-deploy/"/>
    <url>/2023/12/03/hexo-install-and-deploy/</url>
    
    <content type="html"><![CDATA[<p>一时间还没想好要写哪些东西，万事开头难嘛，既然这样，咱就先记录下烂大街的Hexo安装与部署吧。</p><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>我们可以将我们的blog理解成一个app，Hexo项目就是这个app的框架工程源码，通过Node.js进行编译打包，最终生成产品发布到GitHub上被人查看使用。</p><h1 id="安装Git-注册GitHub账号"><a href="#安装Git-注册GitHub账号" class="headerlink" title="安装Git&amp;注册GitHub账号"></a>安装Git&amp;注册GitHub账号</h1><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>传送门：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a><br>作用：用于管理Hexo生成的文件，对接GitHub</p><h2 id="注册GitHub账号"><a href="#注册GitHub账号" class="headerlink" title="注册GitHub账号"></a>注册GitHub账号</h2><p>传送门：<a href="https://github.com/">https://github.com/</a><br>作用：托管Hexo生成的文件，并提供GitHub Page服务，让blog可以被别人浏览  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 校验安装</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure><h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><p>传送门：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a><br>Node.js是一个跨平台的基于Chrome V8引擎的JavaScript运行环境，它可以让JS脚本可以脱离浏览器执行。这么说如果还是不太理解的话，把他理解成Python就可以<br>为啥需要Node.js呢，有两个原因：</p><ul><li>Hexo是基于Node.js作为构建系统来生成网页</li><li>Hexo可以使用npm来下载安装</li><li>等等，这里npm又是啥？别慌，npm是Node.js的包管理器，理解成pip之于Python。最近的Node.js在安装的时候已经会一起安装npm了</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 校验安装</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><h1 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h1><p>使用npm进行安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// -g参数表示将hexo-cli作为全局(global)包安装，hexo-cli中的二进制文件加入到PATH中，方便终端调用hexo命令</span><br><span class="line">// 全局安装还可以使得在创建其他Node.js项目的时候也方便引用到</span><br><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h1 id="创建Hexo项目"><a href="#创建Hexo项目" class="headerlink" title="创建Hexo项目"></a>创建Hexo项目</h1><p>1.在你喜欢的地方创建一个文件夹，例如桌面上，就叫做hexo_blog吧<br>2.cd到该目录<br>3.执行命令，创建Hexo项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 创建Hexo项目</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>4.执行命令，在本地生成网页产物</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 生成网页产物</span><br><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>5.执行命令，启动本地服务器查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 启动本地server</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>6.在浏览器中打开 <a href="http://localhost:4000/">http://localhost:4000/</a> 查看效果<br>不出意外的话，恭喜，已经曙光初现了，接下来就是将我们的blog发布到GitHub Page上供别人浏览了</p><h1 id="部署到GitHub-Page"><a href="#部署到GitHub-Page" class="headerlink" title="部署到GitHub Page"></a>部署到GitHub Page</h1><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>之前我们创建了GitHub账号，我们新建一个仓库<br><img src="/../images/image.png" alt="Alt text"><br><img src="/../images/image-1.png" alt="Alt text"></p><h2 id="配置SSH密钥"><a href="#配置SSH密钥" class="headerlink" title="配置SSH密钥"></a>配置SSH密钥</h2><p>等等，啥是SSH，啥是密钥？我们要把本地的Hexo产物文件push到GitHub，是通过ssh的方式。那GitHub肯定需要鉴权把。鉴权我们可以使用账号密码，但是如果每次push都要输入账号密码，那想想都很痛苦。<br>那有没有更加轻松的方式呢？GitHub很贴心的为你想好啦，我们只要把我们的设备添加到GitHub的信任名单中，那就不用每次都输入账号密码了，so easy!<br>那么，GitHub是怎么信任咱们的设备呢，它需要一个凭证，这个凭证就是SSH密钥。通过SSH密钥能够唯一标识请求来自于这台设备。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 生成ssh密钥，引号中的内容是注释，可以写我们自己的邮箱账号</span><br><span class="line">// 一路回车即可，记录下保存密钥的文件，例如~/.ssh/id_rsa，对应的公钥就是~/.ssh/id_rsa.pub</span><br><span class="line">ssh-keygen -t rsa -C &quot;your email@example.com&quot;</span><br></pre></td></tr></table></figure><p>查看公钥并复制到剪切板中，然后按找到下面的位置将公钥粘贴进去<br><img src="/../images/image-2.png" alt="Alt text"><br><img src="/../images/image-3.png" alt="Alt text"><br><img src="/../images/image-4.png" alt="Alt text"><br><img src="/../images/image-5.png" alt="Alt text"><br>测试下添加是否成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 当出现提示时回车即可</span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><h2 id="配置Git个人信息"><a href="#配置Git个人信息" class="headerlink" title="配置Git个人信息"></a>配置Git个人信息</h2><p>上面的ssh密钥只是前提条件，GitHub在我们push文件时还会根据邮箱和用户名做校验，因而需要设置下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;此处填你的用户名&quot;</span><br><span class="line">git config --global user.email &quot;此处填你的邮箱&quot;</span><br></pre></td></tr></table></figure><h2 id="将Hexo部署到GitHub-Page"><a href="#将Hexo部署到GitHub-Page" class="headerlink" title="将Hexo部署到GitHub Page"></a>将Hexo部署到GitHub Page</h2><p>首先，回到我们之前在GitHub上创建的仓库，复制我们仓库的ssh地址<br><img src="/../images/image-6.png" alt="Alt text"><br>打开我们创建的Hexo项目中的_config.yml文件(推荐Visual Studio Code，后续写blog也很方便)，找到如下入位置进行修改<br><img src="/../images/image-12.png" alt="Alt text"><br><img src="/../images/image-11.png" alt="Alt text"></p><p><strong>敲黑板！！注意branch不要填入master，要填入main。</strong> 分支填错会就看不到了页面了，GitHub Page使用默认分支部署。不知道啥时候开始，GitHub为了zzzq把默认分支的名称从master修改为main了QAQ  </p><p>我们还需要安装一个hexo部署到git的插件来完成最终部署，进入到我们之前创建的Hexo项目目录中，执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这里--save是将该插件添加到Hexo项目的依赖中，记录到package.json</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>最后一步，激动人心的时刻就要到了，执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>完成之后，访问user_name.github.io（user_name替换成你自己的GitHub账号名称），我们就可以看到我们的blog啦，完结撒花~~~~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第一篇正式的blog</title>
    <link href="/2023/12/03/first_blog/"/>
    <url>/2023/12/03/first_blog/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到我的blog，从今天起，开始正式坚持写blog，记录下工作生活中遇到的一些问题，同时也希望分享一些有价值的经验。<br>作为一个曾经幻想着推动人类文明进步的孩子，到现在休息日只想躺着的废柴，终究还是被现实磨平了棱角。<br>那至少，希望用技术创造一些有价值的东西吧。<br>emmm，虽然也很难就是了，但梦想还是要有的嘛，万一呢</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/12/03/hello-world/"/>
    <url>/2023/12/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
