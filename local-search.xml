<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Swift进阶-互用性</title>
    <link href="/2023/12/31/swift-advance-interop/"/>
    <url>/2023/12/31/swift-advance-interop/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>所谓互用性，也称为互操作性，大白话就是Swift如何和其他编码语言的二进制进行交互调用。Swift的强大之处在于，可以方便的和OC、C混用。</p><h2 id="封装一个用C编写的程序库"><a href="#封装一个用C编写的程序库" class="headerlink" title="封装一个用C编写的程序库"></a>封装一个用C编写的程序库</h2><ul><li>设置包管理器：<ul><li>brew install cmark: 安装cmark</li><li>创建SwiftPM项目目录：swift package init –type executable</li><li>如何找到cmark库<ul><li>需要按照clang moudule格式使用module map封装cmark为module</li><li>需要在Package.swift中定义一个.systemLibaryay target，标志由系统包管理器，如apt、homebrew提供的库，并将其添加到主target的依赖中</li><li>那么创建一个目录，包含shime.h，其中包含cmark.h，module map文件中指定header为shime.h，并link cmark二进制</li><li>然后就可以在Swift中调用了</li></ul></li></ul></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">import</span> PackageDescription<br><span class="hljs-keyword">let</span> package <span class="hljs-operator">=</span> <span class="hljs-type">Package</span>(<br>    name: <span class="hljs-string">&quot;CommonMarkExample&quot;</span>,<br>    dependencies: [],<br>    targets: [<br>        .executableTarget(<br>            name: <span class="hljs-string">&quot;CommonMarkExample&quot;</span>,<br>            dependencies: [<span class="hljs-string">&quot;Ccmark&quot;</span>]),<br>        .systemLibrary(<br>            name: <span class="hljs-string">&quot;Ccmark&quot;</span>,<br>            pkgConfig: <span class="hljs-string">&quot;libcmark&quot;</span>,<br>            providers: [<br>                .brew([<span class="hljs-string">&quot;cmark&quot;</span>]),<br>                .apt([<span class="hljs-string">&quot;cmark&quot;</span>]),<br>        ]),<br>    ]<br>)<br></code></pre></td></tr></table></figure><ul><li>封装CmmonMark程序库<ul><li>Swift在调用是，会将c的数据类型转换为Swift数据类型</li><li>注意在调用后，需要手动free c返回的数据对象</li></ul></li><li>对于不透明指针，Swift使用OpaquePointer</li><li>对于C枚举，Swift使用struct表示，而对于OC的NS_Enum会转换为Swift Enum</li></ul><h2 id="底层类型概览"><a href="#底层类型概览" class="headerlink" title="底层类型概览"></a>底层类型概览</h2><ul><li>含有managed表示内存时自动管理</li><li>含有unsafe表示安全性需要自己保证，不提供内存管理，需要手动管理</li><li>含有buffer表示作用于连续内存上的多个元素而非单一元素</li><li>含有pointer表示具有指针语义</li><li>含有raw表示无类型原始数据，等价于void*</li><li>含有mutable表示允许修改指向的内存</li><li>指针：<ul><li>UnsafePointer等价于const int*，即不能修改指针指向的内存</li><li>const int *p,const修饰指向的内容，指向的内容不可变</li><li>int *const p,const修饰指针，指针不可变，指向的内容可变</li><li>使用可选值代表空指针</li></ul></li></ul><h2 id="闭包用作C的回调函数"><a href="#闭包用作C的回调函数" class="headerlink" title="闭包用作C的回调函数"></a>闭包用作C的回调函数</h2><ul><li>只允许向C函数指针传递不捕获任何外部变量的block或者函数，使用@convention(C)告知编译器，因为C函数指针时静态的，但是Swift闭包本质上可以理解为一个带有上下文和函数的结构体</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-编码和解码</title>
    <link href="/2023/12/31/swift-advance-encode-decode/"/>
    <url>/2023/12/31/swift-advance-encode-decode/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>和别的语言序列化的概念相似，Swift中定义了Codeable协议，其实际就是Decodeable&amp;Encodeable。标准库所有基本类型都实现了Codeable，如果struct和class内部属性都满足Codeable，则编译器可以自动生成其Codeable实现。</p><h2 id="一个最小的例子"><a href="#一个最小的例子" class="headerlink" title="一个最小的例子"></a>一个最小的例子</h2><ul><li>当strcut中的成员都是Codeable时，编译器可以自动生成Codeable实现，我们只要声明Codeable即可</li><li>编码：Swift自带JSONEncoder和PropertyListEncoder，可以将Codeable转换为对应数据，不同的encoder返回的数据格式是不同的</li><li>解码：将编码之后的数据传递给decoder，从而重新创建出实例</li><li>自定义编码格式：如果不自定义，那么编码后的数据格式完全由编码器的默认实现决定，比如Double就是json中的浮点。如果想要让Double编码为字符串，我们可以实现一个自定义的@propertyWrapper，让其符合Encodeable，然后自己实现encode和init(from decoder)方法<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">@propertyWrapper</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CodedAsString</span>: <span class="hljs-title class_">Codable</span> &#123;<br>    <span class="hljs-keyword">var</span> wrappedValue: <span class="hljs-type">Double</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">wrappedValue</span>: <span class="hljs-type">Double</span>) &#123;<br>        <span class="hljs-keyword">self</span>.wrappedValue <span class="hljs-operator">=</span> wrappedValue<br>    &#125;<br>    <br>    <span class="hljs-comment">// 自定义属性解码</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">from</span> <span class="hljs-params">decoder</span>: <span class="hljs-type">Decoder</span>) <span class="hljs-keyword">throws</span> &#123;<br>        <span class="hljs-keyword">let</span> container <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> decoder.singleValueContainer()<br>        <span class="hljs-keyword">let</span> str <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">String</span>.<span class="hljs-keyword">self</span>)<br>        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> value <span class="hljs-operator">=</span> <span class="hljs-type">Double</span>(str) <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 抛出错误</span><br>        &#125;<br>        wrappedValue <span class="hljs-operator">=</span> value<br>    &#125;<br>    <br>    <span class="hljs-comment">// 自定义属性编码</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">encode</span>(<span class="hljs-params">to</span> <span class="hljs-params">encoder</span>: <span class="hljs-type">Encoder</span>) <span class="hljs-keyword">throws</span> &#123;<br>        <span class="hljs-keyword">var</span> container <span class="hljs-operator">=</span> encoder.singleValueContainer()<br>        <span class="hljs-keyword">try</span> container.encode(<span class="hljs-type">String</span>(wrappedValue))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="编码过程"><a href="#编码过程" class="headerlink" title="编码过程"></a>编码过程</h2><ul><li>实际是每个被编码的值调用自身的encode方法，传递对应的Encoder实例进行编码</li><li>容器：先看下Encoder协议<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">/// 一个可以把值编码成某种外部表现形式的类型。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Encoder</span> &#123;<br>    <span class="hljs-comment">/// 编码到当前位置的编码键 (coding key) 路径</span><br>    <span class="hljs-keyword">var</span> codingPath: [<span class="hljs-type">CodingKey</span>] &#123; <span class="hljs-keyword">get</span> &#125;<br>    <span class="hljs-comment">/// 用户为编码设置的上下文信息。</span><br>    <span class="hljs-keyword">var</span> userInfo: [<span class="hljs-type">CodingUserInfoKey</span> : <span class="hljs-keyword">Any</span>] &#123; <span class="hljs-keyword">get</span> &#125;<br>    <span class="hljs-comment">/// 返回一个容器，用于存放多个由给定键索引的值。</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">container</span>&lt;<span class="hljs-type">Key</span>: <span class="hljs-type">CodingKey</span>&gt;(<span class="hljs-params">keyedBy</span> <span class="hljs-params">type</span>: <span class="hljs-type">Key</span>.<span class="hljs-keyword">Type</span>)<br>    -&gt; <span class="hljs-type">KeyedEncodingContainer</span>&lt;<span class="hljs-type">Key</span>&gt;<br>    <span class="hljs-comment">/// 返回一个容器，用于存放多个没有键索引的值。</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">unkeyedContainer</span>() -&gt; <span class="hljs-type">UnkeyedEncodingContainer</span><br>    <span class="hljs-comment">/// 返回一个适合存放单一值的编码容器。</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">singleValueContainer</span>() -&gt; <span class="hljs-type">SingleValueEncodingContainer</span><br>&#125;<br></code></pre></td></tr></table></figure>为每个要编码的值创建一个编码容器，保证每个值不会覆盖彼此，有三种类型的容器：<ul><li>keyed contianer：用于编码键值对，可以看做是个特殊的dict</li><li>unkeyed container：编码值，不需要key，可以懒做是编码结果数组</li><li>single value container：对单一值编码，处理由单个属性定义的类型，如Int<br>每种容器都对应一个协议，约束容器应该如何接受值并进行编码，以single value container举例：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">SingleValueEncodingContainer</span> &#123;<br>    <span class="hljs-comment">/// 编码到当前位置的编码键路径。</span><br>    <span class="hljs-keyword">var</span> codingPath: [<span class="hljs-type">CodingKey</span>] &#123; <span class="hljs-keyword">get</span> &#125;<br>    <span class="hljs-comment">/// 编码空值。</span><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">encodeNil</span>() <span class="hljs-keyword">throws</span><br>    <span class="hljs-comment">/// 编码原始类型的方法</span><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">encode</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">value</span>: <span class="hljs-type">Bool</span>) <span class="hljs-keyword">throws</span><br>    <span class="hljs-comment">/// TL;DR</span><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">encode</span>&lt;<span class="hljs-type">T</span>: <span class="hljs-type">Encodable</span>&gt;(<span class="hljs-keyword">_</span> <span class="hljs-params">value</span>: <span class="hljs-type">T</span>) <span class="hljs-keyword">throws</span><br>&#125; <br></code></pre></td></tr></table></figure>可以看到，如果是单个简单类型的值，直接调用对应函数，如果不属于这个简单类型，那么则调用该对象的encode(to:)递归。其他两种类型的容器也是和single value container有类似的结构，但是具备更多的能力，比如可以创建嵌套容器，具体使用哪个，取决于类型实现者自己。比如数组既可以调用single value container，也可以使用unkeyed container，显然后者更佳。</li></ul></li><li>总结下：编码器提供底层编码能力，被编码的类型自己调用编码器去编码。</li></ul><h2 id="合成的代码"><a href="#合成的代码" class="headerlink" title="合成的代码"></a>合成的代码</h2><ul><li>当编译器自己合成Codeable方法时，其实现时什么<ul><li>首先，会生成一个枚举CodingKeys，用来表示内部的属性，该enum符合CodingKey协议，该协议允许使用String和Int转换</li><li>encode：使用一个keyed container，将属性分别encode并放到container中，最终的结果是递归的</li><li>init方法：同样先获取keyed container，然后递归调用decode获得属性值并最终创建自身</li></ul></li></ul><h2 id="手动遵守协议"><a href="#手动遵守协议" class="headerlink" title="手动遵守协议"></a>手动遵守协议</h2><ul><li>如果不想使用编译器生成的Codeable方法，可以自己实现</li><li>自定义CodingKeys：<ul><li>实现键的重命名：将对应case的rawValue修改为指定值</li><li>不含某个case：编码时将跳过对应属性</li></ul></li><li>自定义encode和init<ul><li>比如处理json字符串中缺失某个字段</li><li>但是这也反应了一个问题，就是对于非正常值的处理，使用编码系统还是不够灵活和普适合，但是，理想情况下是要求server返回正确的数据，但是因为在实际工作中总是有各种各样的case，所以一般还是手动解析更多</li></ul></li></ul><h2 id="常见的编码任务"><a href="#常见的编码任务" class="headerlink" title="常见的编码任务"></a>常见的编码任务</h2><ul><li>编码非自己的类型：可以自定义encode或者封装嵌套实现，但是不能直接通过extension别人的类型为Codeable，或者使用计算属性来动态创建非Codeable的类型</li><li>让类满足Codable：对值来说，很简单，直接符合Codeable，但是对于类来说，不能通过extension的方式追加Codeable（required方法不能添加到extension中，required表示所有子类都要实现，所以required方法能被动态派发，所以必须在编译期间检查创建，而不不能通过事后extension的方式创建）。我们可以通过变通的方法，比如使用可Codeable的类型，然后动态创建出非Codeable的类型</li><li>解码多态的集合：比如数组中包含多个UIView的子类型，但是解码时我们只能将其解码为固定的UIView类型，实际上这种情况我们只能case by case解决，因为要保证类型安全，否则就有可能创建意外类型的对象</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-错误处理</title>
    <link href="/2023/12/30/swift-advance-error-handle/"/>
    <url>/2023/12/30/swift-advance-error-handle/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>错误处理很枯燥，错误处理也很重要，skr~</p><h2 id="错误分类"><a href="#错误分类" class="headerlink" title="错误分类"></a>错误分类</h2><ul><li>预期中的error，如网络连接失败<ul><li>可忽略的eror：如字典中key不存在，一般这种返回可选值更好</li><li>需提供详细信息的error：如网络失败，需要网络失败的类型<br>-非预期的error：如数组越界</li></ul></li></ul><h2 id="Result类型"><a href="#Result类型" class="headerlink" title="Result类型"></a>Result类型</h2><ul><li>实际就是个enum<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;<span class="hljs-title class_">Success</span>, <span class="hljs-title class_">Failure</span>: <span class="hljs-title class_">Error</span>&gt; &#123;<br>    <span class="hljs-keyword">case</span> success(<span class="hljs-type">Success</span>)<br>    <span class="hljs-keyword">case</span> failure(<span class="hljs-type">Failure</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="抛出和捕获"><a href="#抛出和捕获" class="headerlink" title="抛出和捕获"></a>抛出和捕获</h2><ul><li>函数后使用throws表示函数可能抛出错误，调用时需要加try</li><li>任意类型都可以是Error类型，Error类型实际就是个标记类型</li><li>使用do…catch…捕获error</li><li>本质上，抛出error就是创建result，只不过编译器帮我们完成了</li></ul><h2 id="具体类型error和无类型error"><a href="#具体类型error和无类型error" class="headerlink" title="具体类型error和无类型error"></a>具体类型error和无类型error</h2><ul><li>throw属于无类型error，因为我们并不能穷举所有error类型，大多数情况下也没有必要</li><li>Result属于具体类型error</li></ul><h2 id="不可忽而略的error"><a href="#不可忽而略的error" class="headerlink" title="不可忽而略的error"></a>不可忽而略的error</h2><ul><li>相比于Result，当使用throws，编译器强制我们进行处理</li></ul><h2 id="错误转换"><a href="#错误转换" class="headerlink" title="错误转换"></a>错误转换</h2><ul><li>try?可以将throws转换为可选值，但是会丢失error信息</li><li>try!表示如果throw，直接崩掉</li><li>Result提供了api将可throw的代码封装为Result，很简单，就是内部catch</li></ul><h2 id="错误链"><a href="#错误链" class="headerlink" title="错误链"></a>错误链</h2><ul><li>throws链：只要有一个函数throw，那么整个函数都会throw</li><li>result链：略，比较复杂，并且没啥用</li></ul><h2 id="错误和回调"><a href="#错误和回调" class="headerlink" title="错误和回调"></a>错误和回调</h2><ul><li>回调不兼容throws，而是只能使用回调Result结果</li></ul><h2 id="使用defer进行清理"><a href="#使用defer进行清理" class="headerlink" title="使用defer进行清理"></a>使用defer进行清理</h2><ul><li>类似于finally，但可以使用在任何地方</li><li>多个defer执行的顺序取决于声明顺序逆序，可以认为是个栈</li><li>defer发生在return的求值之后，在实际return之前</li></ul><h2 id="Rethrows"><a href="#Rethrows" class="headerlink" title="Rethrows"></a>Rethrows</h2><ul><li>如果将一个函数标记为throws，则任何调用的地方都必须加try</li><li>可以将函数标记为rethrows，这时，只有其参数是throws标记时，他才是throws的</li></ul><h2 id="将错误桥接到OC"><a href="#将错误桥接到OC" class="headerlink" title="将错误桥接到OC"></a>将错误桥接到OC</h2><ul><li>Swift将OC中接受NSError**的函数姿容转换为throws的版本</li><li>Swift的Error将会转换为NSError</li><li>LocalizedError协议：提供本地化信息表示</li><li>RecoverableError：描述用户可恢复的错误</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-并发</title>
    <link href="/2023/12/30/swift-advance-concurrency/"/>
    <url>/2023/12/30/swift-advance-concurrency/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Swift 5.5引入了async&#x2F;await特性，类似于go的go func。本质上是用户级线程，即在线程之上又抽象了自己的任务调度。</p><h2 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async&#x2F;Await"></a>Async&#x2F;Await</h2><ul><li>之前，一般通过回调编写异步代码，缺点就是有可能导致深度嵌套，可读性差，并且，也无法使用Swift的错误处理和defer</li><li>每个await都有可能导致任务被suspend，在await的函数返回之后再执行之后的代码</li><li>Swift的编发模型称为协同式多任务，函数是自愿暂停并且只在await才能暂停</li><li>被暂停的函数<strong>再继续后可能在和原先不同的线程上执行</strong>，所以在函数中执行和线程相关的代码时要小心，如thread local变量需要修改为task local变量</li><li>适合io密集型任务</li><li>支持cancel，但是这个cancel只是标记了一个flag，具体是否结束任务需要自行决定，这也是协作式的一种表现</li><li>每次await都会创建一个异步作业，两个个await之间的代码是同步执行的</li><li>但有时多个作用会被合并，也就是说，虽然await创建了一个新任务，但是实际情况该任务可能和await之前的任务一起是同步执行的，所以await是<strong>潜在</strong>的暂停，不一定是必然暂停</li><li>可将将异步回调通过withCheckedThrowingContinuationg封装为async函数，checked表示运行时会进行检查，确保回调仅调用1次</li><li>withXXXContinuation除了用来封装异步回调，本质上，允许我们手动暂停任务，并在之后恢复</li><li>async方法需要标记为@objc才能被oc通过回调方式调用</li></ul><h2 id="结构化并发"><a href="#结构化并发" class="headerlink" title="结构化并发"></a>结构化并发</h2><ul><li>task是Swift并发模型的基本执行上下文，每个async函数都位于一个task中</li><li>task中遇到await，可能暂停，将控制权交还给调度器，再次调度后可能位于不同的线程上执行</li><li>await调用async函数，被调用函数和调用者属于同一个task，想要创建新任务，需要进行明确的动作<ul><li>子任务：async let，高招属性结构组织，有作用域和生命周期</li><li>非结构化任务：单独的任务，称为独立任务树的根节点，调用Task或者Task.detached创建非结构化任务</li></ul></li><li>任务树中<ul><li>子任务相互之间可以并发运行</li><li>子任务生命周期不能超过父任务，父任务需要等待所有子任务完成才退出</li><li>取消从父任务传递给子任务</li><li>子任务继承父任务优先级和任务本地值</li></ul></li><li>async let：使用该语法创建子任务，会立即执行，没有被await的async let将会在作用域结束后隐式被cancel并且await，只是因为必须保证子任务有机会退出</li><li>任务组在正常退出时，不会隐式cancel和await</li><li>async let即使包含多个异步调用，也只会创建一个任务</li><li>async let是在编译期间确定了子任务数量，如果想要运行时动态添加子任务，则需要任务组</li></ul><h2 id="任务组"><a href="#任务组" class="headerlink" title="任务组"></a>任务组</h2><ul><li>提供动态数量的子任务</li><li>使用withTaskGroup和withThrowingTaskGroup创建任务组</li><li>一些规则：<ul><li>子任务结果按照完成顺序传递</li><li>子任务结果类型需要完全相同</li><li>子任务声明周期不能超过任务组闭包范围</li><li>如果在退出任务组闭包时仍然有未经等待的子任务，运行时会在继续前隐式等待这些任务直到结束并丢弃结果，注意不会自动cancel</li><li>任务组不会限制并发数量</li></ul></li><li>传递给任务组的参数闭包类型是@Sendable修饰的，这个注解表示多任务执行该代码是安全的，即并发安全，即代码中不会引起race condition<ul><li>@Sendable捕获的值自己需要是Sendable的</li><li>Sendable是个空协议，即标记协议</li><li>非public的struct和enum，只要其成员是Sendable，则本身也是Sendable</li><li>Actor默认是Sendable</li><li>对于没有标记为final的class，编译器无法保证是Sendable，但是我们可以通过修饰@uncheckSendable告知编译器，安全性由开发者保证</li><li>虽然Swift闭包默认将捕获作为引用，但@Sendable中需要将捕获变量作为值处理，这也是保证安全性的手段</li><li>目前来说，@Sendable编译器还无法保证完全的安全，还处在不断的完善中</li></ul></li><li>取消是协作式的，即需要任务自己检查取消状态并执行相应逻辑，可以执行Task.checkCancellation让取消时抛出error</li><li>大部分情况下，我们调用系统异步函数时无需自己检查cancel，然是如果我们自己实现一个耗时任务，还是需要的</li><li>如果一个任务被取消，应该抛出error</li><li>当任务组被cancel时，子任务也会被canel</li><li>可以使用withTaskCancellationHandler为取消设置回调函数</li><li>可以使用Task.init开启独立任务，该任务会立即开始，并且称为一个新的任务树的根节点，Task类似于js中的promise或者java中的Future</li><li>通过Task启动的非结构化任务，会继承原上下文的优先级、本地值和actor隔离域，即如果开启Task的任务是运行在actor队列中的，那么Task也是会加到该actor队列中</li><li>若不想Task在当前上下文中执行，可以使用Task.detached创建游离任务，游离任务不会继承当前任务的优先级、本地址和actor隔离</li><li>若要在非async函数中开启任务，则必须借助于Task</li><li>非结构化任务中，不会抛出错误</li></ul><h2 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h2><ul><li>无论是传统的多线程还是最近兴起的协程，都需要处理race condition问题，解决方式包括锁、串行队列等，而Swift并发使用的方案是Actor作为资源隔离机制</li><li>actor是引用类型，和声明class一样。在actor内部访问var属性是没有问题的，访问let属性更没问题（实际上，let可以跨actor也是安全的），对于方法的访问，其<strong>内部采用串行队列加以保护</strong></li><li>actor并不是将整个方法都隔离，在await之间的函数视为原子操作</li><li>actor的方法是可重入的，即一旦actor中的方法因执行async函数而不suspend时，其他方法再次调用actor中的方法时，能够在actor的队列中执行</li><li>因为actor方法是可重入的，所以不要暂停点前后的数据是有可能发生变化的</li><li>同一个任务如果执行多个actor的方法，那么会产生actor跳跃，不可避免产生开销</li><li>@MainActor，是个globalActor，使用该标记让我们的属性或者方法都运行在主线程队列中</li><li>nonisolated：将其标记为非保护</li><li>大多数情况下，@MainActor都是符合预期的，但要分3种情况<ul><li>标记async方法：没问题</li><li>标记非async方法：编译器会执行静态检查，在main actor上下文中直接调用，其他上下文需要await，但是在oc中可能失效</li><li>标记属性：同样是编译期间检查，不能在非main actor上下中访问</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-集合协议类型</title>
    <link href="/2023/12/28/swift-advance-collection-protocol/"/>
    <url>/2023/12/28/swift-advance-collection-protocol/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Swift中的集合，如Array、Dictionary、Set是建立在Swift标准库提供的协议之上的。这部分主要介绍Sequence和Collection协议，他们的关系如图：<br><img src="/../images/image-22.png" alt="Alt text"></p><ul><li>Sequence: 提供迭代方法，但是不保证能够支持多次迭代</li><li>Collection: 继承自Sequence，可以支持多次遍历，允许使用索引访问元素，通过SubSequence提供切片能力</li><li>MutableCollection:允许通过下标修改Collection，但是不允许修改元素数量</li><li>RangeReplaceableCollection: 提供替换集合中连续区间中的元素，进而支持插入、删除</li><li>BidirectionalCollection：提供双向遍历能力</li><li>RandomeAccessCollection：继承自BidirectionalCollection，保证计算索引和移动索引位置都是常数时间操作</li><li>LazySequenceProtocol: 只有在开始遍历是才计算其中元素的序列</li><li>LayzCollectionProtocol：和LazySequenceProtocol类似，只不过额外支持Collection的能力</li></ul><h2 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h2><ul><li>Sequence代表一系列相同类型的值</li><li>支持使用for进行迭代<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Sequence</span> &#123;<br>    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Element</span><br>    <span class="hljs-comment">// 约束迭代器的元素类型和自身元素类型一致</span><br>    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Iterator</span>: <span class="hljs-type">IteratorProtocol</span> <span class="hljs-keyword">where</span> <span class="hljs-type">Iterator</span>.<span class="hljs-type">Element</span> <span class="hljs-operator">==</span> <span class="hljs-type">Element</span><br>    <span class="hljs-comment">// 必要方法，获取迭代器</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeIterator</span>() -&gt; <span class="hljs-type">Iterator</span><br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>迭代器的作用：每次生成一个值并管理迭代状态<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">IteratorProtocol</span> &#123;<br>    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Element</span><br>    <span class="hljs-comment">// 必要方法，next</span><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">next</span>() -&gt; <span class="hljs-type">Element</span>?<br>&#125;<br></code></pre></td></tr></table></figure></li><li>迭代器只允许单向迭代</li><li>当我们自己实现了Sequence时，就可以调用许多便捷方法了，如contains（因为Protocol对方法有默认实现）</li><li>迭代器一般是具有值语义的，即也有例外，比如AnyIterator，其内部就封装了一个类类型的迭代器，所以具有引用语义</li><li>可以通过函数闭包创建AnyIterator，并通过将其传递给AnySequence方便的创建序列，但是性能上会有所损耗</li><li>也可以通过sequence函数来方便的创建Sequence，性能也会有所损耗</li><li>注意Sequence本身并<strong>不保证能够对Sequence多次遍历的结果相同</strong>，要多次遍历，需要使用Collection</li></ul><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><ul><li>支持多次遍历并且每次遍历的结果一致</li><li>支持下标访问</li><li><strong>Collection是有限的</strong>，但是Sequence可以是无限的</li><li>Collection有关联的SubSequence，表示Collection的一个切片</li><li>自己实现Collection，略</li><li>实现的Collection可以遵守ExpressibleByArrayLiteral，这样可以方便的使用数组创建</li><li>Collection中的一些关联类型都有默认的实现，比如Indices的默认类型是DefaultIndices&lt;Self&gt;，有时通过实现自定义的关联类型，有助于性能优化，比如将DefaultIndices替换为Range，从而避免对Self的引用，从而避免在迭代时修改Collection而可能造成的额外的COW</li></ul><h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><ul><li>Index表示Collection中的位置</li><li>每个Collection都有startIndex和endIndex，注意endIndex是最后一个元素的<strong>下一个位置</strong>，也就是说endIndex实际是个终止哨岗</li><li>Index不必是Int，但必须是Comparable的</li><li>使用Index作为下标操作返回的是非可选值，因为Index必须由开发者保证是有效的</li><li>当Collection改变时，Index将会失效</li><li>Collection和其切片类型共享Index</li><li>可以调用Collection的indexAfter方法来步进Index</li><li>自定义集合Index，不一定是整数，只要实现时保证语义即可和对应方法即可</li></ul><h2 id="SubSequence"><a href="#SubSequence" class="headerlink" title="SubSequence"></a>SubSequence</h2><ul><li>Collection中有个关联类型叫做SubSequence，SubSequnce本身也是符合Collection的，默认实现时Slice&lt;Self&gt;</li><li>SubSequence和原Collection共享内部存储</li><li>为啥不叫SubCollection而是叫SubSequence呢？别问，问就是历史遗留问题（之前SubSequence是作为Sequence的关联类型的</li><li>SubSequence适合持有中间结果，因为内存开销低。但是不建议长时间持有SubSequence，可能造成内存泄漏，因为SubSequence持有了原Collection</li><li>可以将SubSequence转换为Collection以创建副本</li><li>SubSequence的默认实现时Slice类型，实际只是封装了Range+Collection</li><li>SubSequence和Collection共享Index，注意下标越界</li></ul><h2 id="专门的Collection类型"><a href="#专门的Collection类型" class="headerlink" title="专门的Collection类型"></a>专门的Collection类型</h2><ul><li>Collection协议不提供从后往前移动Index，不提供插入、删除、替换等改变Collection的操作，为此标准库提供了几种特定类型的Collection以宽展功能<ul><li>BidirectionalCollection: 支持双向遍历</li><li>RandomAccessCollection: 支持高效随机访问</li><li>MutableCollection: 支持下标赋值</li><li>RangeReplaceableCollection: 支持范围替换（进而支持插入、删除）</li></ul></li><li>BidirectionalCollection：通过index(before:)索引前移，这种能力一般来说是保证往后移动index的性能是常量级别的，基于此，该协议还提供reversed、removeLast、suffix等操作，注意reversed并不是真的将集合倒转，而是使用特定的索引从后往前遍历罢了，标准库中的大部分Collection同时也是该协议</li><li>RandomAccessCollection:支持最高效的元素存取，需要保证能够在常数时间内完成索引计算</li><li>MutableCollection: 支持原地元素修改，索引必须针对下标提供setter方法。注意该协议只支持改变元素值，但不支持修改Collection的大小和元素位置，所以满足这个协议的只有Array，而Dict、Set、String都不满足该要求</li><li>RangeReplaceableCollection: 支持添加、删除、范围替换，如String，注意该协议并非对MutableCollection的继承，两者的侧重点不一样</li><li>通过将这些一些进行组合约束，可以确保一些算法是满足语义</li></ul><h2 id="延迟序列"><a href="#延迟序列" class="headerlink" title="延迟序列"></a>延迟序列</h2><ul><li>标准库为延迟求值提供了两个协议LazySequenceProtocol和LazyCollectionProtocol</li><li>使用lazy属性，我们不需要自己实现就可以获取延迟计算的能力</li><li>LazyCollectionProtocol相比于LazySequenceProtocol，可以直接使用索引，只有在获取索引元素时，计算才会发生，而LazySequence只能依次延迟计算每个元素，也就是没有索引功能</li><li>但是使用索引未必就是常量时间的，只不过是将计算延迟罢了</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-协议</title>
    <link href="/2023/12/26/swift-advance-protocol/"/>
    <url>/2023/12/26/swift-advance-protocol/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>之前在了解泛型实现原理时，我们知道Swift的泛型使用协议的PWT来动态派发对协议函数的调用，协议和泛型一般同时出现，否则仅用泛型的功能不够强大</li><li>protocol可以被extension，只有protocol中的方法会被动态派发</li><li>被extension的protocol可以约束协议中的泛型所符合的要求来特殊化协议，称为条件化扩展，eg.<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">// 该扩展协议的含义，所有的元素都要符合Comparable</span><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Sequence</span> <span class="hljs-title class_">where</span> <span class="hljs-title class_">Element</span>: <span class="hljs-title class_">Comparable</span><br></code></pre></td></tr></table></figure></li><li>protocol可以继承</li><li>protocol可以组合</li><li>当protocol的实现依赖于其他协议，被称为条件化实现,eg.<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">// 该扩展协议的含义，当Array中元素符合Equatables时，Array才符合Equatable</span><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Array</span>: <span class="hljs-title class_">Equatable</span> <span class="hljs-title class_">where</span> <span class="hljs-title class_">Element</span>: <span class="hljs-title class_">Equatable</span><br></code></pre></td></tr></table></figure></li><li>protocol可以有多个关联类型，如Element，其表示特定类型的占位符，实现协议的特定类型需要定义该具体的类型</li></ul><h2 id="protcol目击者"><a href="#protcol目击者" class="headerlink" title="protcol目击者"></a>protcol目击者</h2><ul><li>所谓protocol目击者，可以理解为具有具体类型的类型实例方法</li><li>目击者，即witness，个人理解翻译为证明者，即向编译器证明这个类型确实实现了协议所规定的方法，也包含了实现的方法的相关信息，编译器可以通过witness拿到要调用的具体方法</li><li>swift中的协议目击者是编译器生成并自动传递的，在调用协议方法的地方，会转换为对协议目击者方法的调用</li></ul><h2 id="条件化protocol实现"><a href="#条件化protocol实现" class="headerlink" title="条件化protocol实现"></a>条件化protocol实现</h2><ul><li>其本质就是对其中的关联类型提供目击者</li></ul><h2 id="protocol继承"><a href="#protocol继承" class="headerlink" title="protocol继承"></a>protocol继承</h2><ul><li>其本质也是通过协议目击者的组合实现</li></ul><h2 id="使用protocol进行设计"><a href="#使用protocol进行设计" class="headerlink" title="使用protocol进行设计"></a>使用protocol进行设计</h2><ul><li>协议扩展功能extension protcol，可以在协议总添加方法实现调用协议所规定的方法，调用规定的方法是动态派发的</li><li>协议扩展和类型扩展可以重复定义同一个函数<ul><li>通过类型直接调用同名函数，则调用的是类型扩展中的函数</li><li>通过协议扩展中的方法调用同名函数，则调用的是协议扩展中的函数<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">DrawingContext</span> &#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">DrawingContext</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addCircle</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这是协议扩展中的addCircle&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">DrawingContext</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">drawSomething</span>() &#123;<br>        addCircle()<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SVG</span>: <span class="hljs-title class_">DrawingContext</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addCircle</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这是类型扩展中的addCircle&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> svg <span class="hljs-operator">=</span> <span class="hljs-type">SVG</span>()<br><span class="hljs-comment">// 会调用类型扩展中的addCircle</span><br>svg.addCircle()<br><span class="hljs-comment">// 调用协议扩展中的addCircle</span><br>svg.drawSomething()<br></code></pre></td></tr></table></figure></li></ul></li><li>记住：<strong>只有协议中要求的方法才能被动态派发到具体的类型的实现</strong>，而对于协议扩展中实现的方法，则不能动态派发，在编译期间就会被确定，并且是优先静态派发到协议扩展中的方法</li><li>协议的要求的方法可以有默认实现，并且可以被重写</li><li>协议可以被组合：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">typealias</span> <span class="hljs-type">Codable</span> <span class="hljs-operator">=</span> <span class="hljs-type">Decodeable</span> &amp; <span class="hljs-type">Encodable</span><br></code></pre></td></tr></table></figure></li><li>协议可以继承</li></ul><h2 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h2><ul><li>有些protocol需要约束相关类型，可以使用关联类型</li><li>使用associatedtype Element标记一个关联类型，他实际就是一个具体类型的占位符，在实现协议时需要使用typealias Element &#x3D; XXX指定这个占位符的具体类型</li><li>当编译器可以自动推断出关联的具体类型时，可以省略typealias</li><li>关联类型可以指定默认类型</li><li>等等，关联类型和泛型是不是看着很相似？确实如此，他们的区别在于，关联类型是类型设计者显式确定的，但是泛型则是调用者在调用时通过编译器创建的</li></ul><h2 id="Self"><a href="#Self" class="headerlink" title="Self"></a>Self</h2><ul><li>在协议或扩展中，Self是指实现了该协议的类型本身</li></ul><h2 id="再谈实现协议"><a href="#再谈实现协议" class="headerlink" title="再谈实现协议"></a>再谈实现协议</h2><ul><li>建议：不要让不属于你的类型去实现一个不属于你的协议，因为可能不属于你的类型的作者再会自己添加一个协议，这可能导致不符合预期</li></ul><h2 id="存在体"><a href="#存在体" class="headerlink" title="存在体"></a>存在体</h2><ul><li>严格来说，Swift中的协议不是一个特定类型，只能用来约束泛型，但实际上，使用时还是能够以类似a: P的方式声明</li><li>这个实际是编译器为我们处理了，当我们将协议当做类型使用时，<strong>编译器会创建一个包装类型，称为存在体</strong></li><li>所谓存在，就是告知你，确实存在那么一个类型符合该协议</li><li>Swift 5.6之前，使用的语法直接就是xx: P，但是Swift其实并不鼓励直接使用协议作为类型，Swift 5.6就提出了any P更加清晰的表示这是符合某个协议的类型的语义，用来取代这种隐式的表达</li><li>any P可以看做等价于Any<P>，即创建了封装任意符合协议的Any类型，这层封装称为<strong>存在体容器</strong>，由于存在体容器需要记录协议的协议目击者信息，协议方法越多，存在体容器越大</li><li>当我们使用any P的时候，我们的语义是接受<strong>任意符合P的类型</strong>，注意这里是任意，而不是特定！！！和下面的some P区分开</li><li>存在体和泛型，any P有时和T: P作用类似，但是any P的更加灵活，调用时需要借助于PWT，需要处理所有可能的实现协议的类型，所以开销也更大。而T:P编译器会有可能生成特化版本，不需要记住与PWT，性能更佳</li><li><strong>如果协议中存在对Self和关联类型的要求，则无法调用协议中对参数绑定了Self或关联类型的方法</strong>，因为存在体会抹除类型具体信息，编译器不确定传递的存在体的类型是否和实现了协议的类型的类型是一致的<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Equatable</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">==</span> (<span class="hljs-params">lhs</span>: <span class="hljs-keyword">Self</span>, <span class="hljs-params">rhs</span>: <span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-type">Bool</span><br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span>: <span class="hljs-title class_">Equatable</span> &#123;<br><br>&#125;<br><br><span class="hljs-comment">// 错误，编译器不确定lhs和rhs中的Self类型是否一致</span><br><span class="hljs-keyword">let</span> s: <span class="hljs-type">Equatable</span> <span class="hljs-operator">=</span> <span class="hljs-type">S</span>()<br></code></pre></td></tr></table></figure>这里，Equatable就无法被当做存在体类型使用，因为其方法参数中规定了Self的要求。注意，如果是返回值的类型是Self，则是可以的，编译器会将返回值类型再次打包为存在体容器。</li><li>对于Self的要求同样适合关联类型</li><li>协议不能遵守本身，所以也就无法将存在体any P传递给接受一个T:P的泛型参数,这一规则对于init方法和静态方法适用，因为这些函数隐式的接受Self为参数<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">P</span> &#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">test</span>&lt;<span class="hljs-type">T</span>: <span class="hljs-type">P</span>&gt;(<span class="hljs-params">t</span>: <span class="hljs-type">T</span>) &#123;<br>    <span class="hljs-built_in">print</span>(t)<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span>: <span class="hljs-title class_">P</span> &#123;<br>    <br>&#125;<br><br><span class="hljs-comment">// 错误： protocol type &#x27;P&#x27; cannot conform to &#x27;P&#x27;</span><br><span class="hljs-comment">// 也就是P的存在体类型不能符合P本身</span><br><span class="hljs-keyword">let</span> s1: <span class="hljs-type">P</span> <span class="hljs-operator">=</span> <span class="hljs-type">S</span>()<br>test(t: s1)<br><br><span class="hljs-comment">// 正确，传递的是结构体具体类型而非存在体类型</span><br><span class="hljs-keyword">let</span> s2: <span class="hljs-type">S</span> <span class="hljs-operator">=</span> <span class="hljs-type">S</span>()<br>test(t: s2)<br></code></pre></td></tr></table></figure></li><li>有一个特例，Error协议的存在体本身确实是遵守Error协议，但是它能作为参数传递给T: Error泛型参数，这个是编译器的白名单，由于Error是个标记协议，所以这么做不存在问题</li><li>不要过早使用存在类型，存在体类型虽然方便，但是会抹除具体类型信息，并且会导致性能开销，<strong>最好是使用代用约束的泛型</strong></li></ul><h2 id="不透明类型"><a href="#不透明类型" class="headerlink" title="不透明类型"></a>不透明类型</h2><ul><li>some P，是<strong>某个满足P的具体类型</strong>，注意这里不是任意类型，和上面的any P区分开</li><li>和any P不同，any P由于能够接受任意符合P的类型，会抹除掉具体类型的信息，而some P则会保留，只是用户无法获知而已</li><li>some P在Swift UI中大量使用，如some View。这使得深层嵌套的泛型更加容易使用并且隐藏实现细节，比如Swift UI每加一个修饰符，返回的具体类型会增加泛型的嵌套层次，显然不便于书写，同时也暴露了内部实现细节，这里用some View表示我们不care，编译器知道就好</li><li>不透明类型的规则：<ul><li>可以出现在函数的返回类型、属性、变量或者下标中</li><li>通常来说约束时协议，但也可以是具体类型，如some UIView表示任意特定的UIView子类</li><li>返回不透明类型的函数必须在所有return分支中返回相同的类型 （所以这里又不得不提到Swift UI中resultBuilder的伟大，他将分支表达式合并为相同的类型）</li><li>返回不透明类型的函数必须在每次调用时都返回相同的具体类型</li><li>可以通过动态转换还原成具体类型</li></ul></li></ul><h2 id="类型消除器"><a href="#类型消除器" class="headerlink" title="类型消除器"></a>类型消除器</h2><ul><li>在标准库中，我们可以将一个具体的Sequence类型转换为一个AnySequence型，这个AnySequence就是类型消除器，但会引入额外的开销</li><li>手动实现一个类型消除器的思路，实际就是利用泛型，创建一个只暴露内部元素泛型类型的封装类型，对协议方法的调用再内部通过方法转发到到对具体类型的调用<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">// 原始协议</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Restorable</span> &#123;<br>    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">State</span>: <span class="hljs-type">Codable</span><br>    <span class="hljs-keyword">var</span> state: <span class="hljs-type">State</span> &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>&#125;<br>&#125;<br><br><span class="hljs-comment">// 实现了协议并只关心State类型的类型的基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnyRestorableBoxBase</span>&lt;<span class="hljs-title class_">State</span>: <span class="hljs-title class_">Codable</span>&gt;: <span class="hljs-title class_">Restorable</span> &#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">init</span>() &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> state: <span class="hljs-type">State</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123;<span class="hljs-built_in">fatalError</span>()&#125;<br>        <span class="hljs-keyword">set</span> &#123;<span class="hljs-built_in">fatalError</span>()&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 上面的类型的实现子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnyRestorableBox</span>&lt;<span class="hljs-title class_">R</span>: <span class="hljs-title class_">Restorable</span>&gt;: <span class="hljs-title class_">AnyRestorableBoxBase</span>&lt;<span class="hljs-title class_">R</span>.<span class="hljs-title class_">State</span>&gt; &#123;<br>    <span class="hljs-keyword">var</span> r: <span class="hljs-type">R</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">r</span>: <span class="hljs-type">R</span>) &#123;<br>        <span class="hljs-keyword">self</span>.r <span class="hljs-operator">=</span> r<br>    &#125;<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> state: <span class="hljs-type">R</span>.<span class="hljs-type">State</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123; r.state &#125;<br>        <span class="hljs-keyword">set</span> &#123; r.state <span class="hljs-operator">=</span> newValue &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 对外暴露的类型，调用方只需要关心State类型，内部封装了上面类型的子类的实例，对协议方法的调用将被转发，外界无需关心具体类型</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AnyRestorable</span>&lt;<span class="hljs-title class_">State</span>: <span class="hljs-title class_">Codable</span>&gt;: <span class="hljs-title class_">Restorable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> box: <span class="hljs-type">AnyRestorableBoxBase</span>&lt;<span class="hljs-type">State</span>&gt;<br>    <br>    <span class="hljs-keyword">init</span>&lt;<span class="hljs-type">R</span>&gt;(<span class="hljs-params">r</span>: <span class="hljs-type">R</span>) <span class="hljs-keyword">where</span> <span class="hljs-type">R</span>: <span class="hljs-type">Restorable</span>, <span class="hljs-type">R</span>.<span class="hljs-type">State</span> <span class="hljs-operator">==</span> <span class="hljs-type">State</span> &#123;<br>        <span class="hljs-keyword">self</span>.box <span class="hljs-operator">=</span> <span class="hljs-type">AnyRestorableBox</span>(r: r)<br>    &#125;<br>    <br>    <span class="hljs-keyword">var</span> state: <span class="hljs-type">State</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> box.state &#125;<br>        <span class="hljs-keyword">set</span> &#123; box.state <span class="hljs-operator">=</span> newValue&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>当然，类型消除器也可以用any P更加方便的实现，此处略</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-泛型</title>
    <link href="/2023/12/25/swift-advance-generic-type/"/>
    <url>/2023/12/25/swift-advance-generic-type/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>泛型编程的主要目的类型安全和代码重用。泛型可以认为是多态的一种实现方式，所谓多态，就是多个类型可以调用同一个名称的接口。因为泛型只是具体类型不同，接口名称都是相同的，所以可以认为是一种多态的表现。<br>而多态其实还有其他不同的表现形式：</p><ul><li>专属多态（特设多态）：<ul><li>概念：为特定类型的任意集合定义一个共同的接口</li><li>实现1：函数重载，函数名称相同，但传入的参数类型和个数不同</li><li>实现2：协议，多个类型实现同一个协议，这是更结构化的专属多态</li></ul></li><li>子类型多态：<ul><li>概念：一个类型名称表示很多具体类型，这些类具有共同的超类</li><li>实现：同一个函数如果接受父类作为参数，那么也可以传递子类作为参数</li></ul></li><li>参数化多态：<ul><li>概念：指定一个抽象符号表示任意类型</li><li>实现：泛型，接受泛型化参数的函数称为泛型函数，泛型化的参数被称为泛型，也是下面讨论的主要部分</li></ul></li></ul><h2 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h2><ul><li>函数和方法、class、struct和enum都是泛型类型</li></ul><h2 id="泛型和Any"><a href="#泛型和Any" class="headerlink" title="泛型和Any"></a>泛型和Any</h2><ul><li>泛型相比较Any，对于编译器来说能够获得更多的信息，更加安全，但同时也会增大编译产生的体积，因为对于一个具体化的泛型类型，编译器就要生成一个类型</li><li>为每个泛型版本在调用时生成一个特定版本，这称为泛型特化，是C++的默认模板实现，但是对于Swift来说，默认不是，Swift默认是通过额外的间接层将泛型函数调用进行改造以便使其接受任意类型的，但我们可以开启Swift的编译优化选项，使其进行泛型特化</li></ul><h2 id="基于泛型的设计"><a href="#基于泛型的设计" class="headerlink" title="基于泛型的设计"></a>基于泛型的设计</h2><ul><li>主要是抽象出共同的逻辑，将具体类型给泛型化</li></ul><h2 id="泛型的静态派发"><a href="#泛型的静态派发" class="headerlink" title="泛型的静态派发"></a>泛型的静态派发</h2><ul><li>Swift支持函数重载，并且对重载函数的调用确定发生在<strong>编译期间</strong></li><li>Swift只会使用调用侧模块的可用信息来决定调用哪个版本的函数，eg.<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">format</span>&lt;<span class="hljs-type">A</span>&gt;(<span class="hljs-params">value</span>: <span class="hljs-type">A</span>) -&gt; <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-type">String</span>(describing: value)<br>&#125;<br><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">format</span>(<span class="hljs-params">value</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-string">&quot;+<span class="hljs-subst">\(value)</span>+&quot;</span><br>&#125;<br><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">process</span>&lt;<span class="hljs-type">B</span>&gt;(<span class="hljs-params">input</span>: <span class="hljs-type">B</span>) -&gt; <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> formatted <span class="hljs-operator">=</span> format(value: input)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;-<span class="hljs-subst">\(formatted)</span>-&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 这里只会调用泛型版本的函数，而不是更加具体的函数</span><br><span class="hljs-comment">// 因为函数重载发生在编译器，编译器并不确定类型是否是Int，所以只能匹配到更加宽松的版本</span><br>process(input: <span class="hljs-number">1</span>) <span class="hljs-comment">// - 1 -</span><br><br></code></pre></td></tr></table></figure></li><li>协议中的函数则是动态派发的，在运行时才决定调用哪个版本的函数</li></ul><h2 id="泛型的工作方式"><a href="#泛型的工作方式" class="headerlink" title="泛型的工作方式"></a>泛型的工作方式</h2><ul><li>Swift默认是通过间接层来实现一个可以处理任意类型</li><li>间接层需要处理的问题<ul><li>需要知道T的大小</li><li>需要知道如何复制T和销毁T（比如是否需要引用计数）</li><li>需要知道调用重载函数的地址</li></ul></li><li>间接层提供的解决方案<ul><li>Swift使用指针传递函数参数、返回值和变量</li><li>对每个泛型参数，编译器会传递T的类型元数据，包括值目击表VWT，其包含如何对T进行操作，如复制、引用计数</li><li>对T上的每个约束，传递协议目击表PWT，其作用是在运行时决定调用哪个函数，所以泛型机会都是和协议搭配使用的，否则没有PWT功能化大大降低</li></ul></li></ul><h2 id="泛型特化"><a href="#泛型特化" class="headerlink" title="泛型特化"></a>泛型特化</h2><ul><li>之前说过，泛型特化是C++模板的默认实现，但不是Swift的默实现，所以默认是存在一定运行时开销的</li><li>可以Swift -O开启编译优化，但要更好的帮助编译器需要：<ul><li>全模块优化（whole moudle optimize）： 即使开启了优化，默认也只在同一个文件中生效，如果需要整个模块生效，需要开启该选项</li><li>全模块优化还会开启一些额外的优化，如静态派发等等</li><li>将泛型函数标记@inlinable以便其他模块进行导出，这使得编译器容易发现具体类型并进行特化</li></ul></li><li>总体来看，Swift的泛型系统兼具C++的完全特化，又具有Java的只将泛型作为类型检查的能力</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-字符串</title>
    <link href="/2023/12/24/swift-advance-string/"/>
    <url>/2023/12/24/swift-advance-string/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Swift在字符串的实现上尽力去满足Unicode标准，String是Character的值的集合，而Character是人类可读的单个字符，每个Character由多个Unicode标量组成。<br>但是为了实现这种复杂性，Swift会牺牲一些便捷性，比如不能直接通过str[idx+1]访问下一个字符，并且String不支持随机访问</p><h2 id="Unicode，而非固定宽度"><a href="#Unicode，而非固定宽度" class="headerlink" title="Unicode，而非固定宽度"></a>Unicode，而非固定宽度</h2><ul><li>一切都要从Unicode开始说起<ul><li>一开始英文字符由asii码规定，只需要1个字节就可以编码，每个字符的宽度的大小固定</li><li>后来，随着计算机的普及，更多的字符需要被编码，ascii码显然就不够用了</li><li>Unicode就应运而生，他的目标是让天下没有难编码的字符！</li><li>一开始Unicode使用2字节固定宽度进行编码，称为UCS-2，后来不够用，所以现在的Unicode是可变长编码<ul><li>Unicode字符，由一个或者多个Unicode标量组成，每个字符对应一个编码点</li><li>一个Unicode标量可以被编码为多个编码单元</li><li>编码点一般使用U+前缀表示</li><li>Unicode标量在大多数情况下都和编码点相同，在Swift中用Unicode.Scalar表示</li><li>UTF8和UTF16都属于变长编码的编码方式，即每个标量编码的长度并不一致，编码方式中的最小实体称为编码单元，在Swift中用Unicode.UTF8.CodeUnit表示</li><li>单个字符在大多数情况下是由单个标量组成，也可以通过多个标量组成</li><li>总结下：1个可见字符-&gt;1个以上标量 1个标量-&gt;1个以上编码单元，如图所示<br>  <img src="/../images/image-21.png" alt="Alt text"></li></ul></li></ul></li></ul><h2 id="字位簇和标准等价"><a href="#字位簇和标准等价" class="headerlink" title="字位簇和标准等价"></a>字位簇和标准等价</h2><ul><li>标准等价：即一个可见字符可以是单个标量，也可以是多个标量的组合，对于用户来说是等价的，Swift可以正确处理，但对于OC来说，只会按照编码单元去判断</li><li>Unicode为啥要支持两种方式表示同一个字符呢：<ul><li>为了兼容之前的一些编码方式，因为有些预先组合好的字符在别的编码中已经存在了，在Unicode中需要将其视为单个字符</li><li>为了支持以灵活的方式构造展现一个字符</li><li>个人理解，预先组合的字符一定可以表示为多个标量的组合，但反之不一定，因为组合是无穷的</li><li>注意，组合不是任意的，有些标量是可以无限制被添加的，有些则不行</li></ul></li><li>对于emoj，也是Unicode标量组合形成单个字符的典型例子</li><li>那么这些字符是如何被渲染出来的，则是底层字符渲染系统的任务，如果渲染系统无法识别，则会将每个标量单独渲染出来，但是Swift仍然会将语法上有效的标量组合认为是单个字符</li><li>其实OC也有能够支持Unicode标准的api，只不过Swift支持Unicode规范是默认行为</li></ul><h2 id="String和Collection"><a href="#String和Collection" class="headerlink" title="String和Collection"></a>String和Collection</h2><ul><li>String是Character的集合,符合Collection协议</li><li>String是集合，但又不是完全的集合，它不支持随机访问，Swift实现的是BidirectionalCollection，即只能从头或从尾部进行迭代，每次迭代一个字符</li><li>String中的indices代表的是每个字符的索引集合</li><li>String不支持只通过下标修改单个字符，也就是不支持MutableCollection协议。原因说过，因为编码时可变的，替换单个字符需要移动前后的数据。但String实现了RangeReplaceableCollection协议，这允许我们进行范围替换</li></ul><h2 id="String索引"><a href="#String索引" class="headerlink" title="String索引"></a>String索引</h2><ul><li>String不允许直接使用下标索引操作，之前说过，String不能随机访问，所以访问一个字符的时间复杂度是n，所以为了防止我们写出性能糟糕的代码，Swift不支持直接使用下标访问String（个人理解，这牺牲了易用性真的得不偿失…</li><li>String采用String.Index进行索引，其本质是一个字节偏移量。刚开始拿到该字节偏移量的时间复杂度是n，但一旦拿到，则时间复杂度降低为1</li><li>通过将字符串写在#的包围中，可以不必对字符串中的引号进行转义</li></ul><h2 id="Substring"><a href="#Substring" class="headerlink" title="Substring"></a>Substring</h2><ul><li>和所有Collection一样，String有个特定的SubSequence，称为Substring,类似于ArraySlice</li><li>Substring和String的接口几乎一样，这是通过StringProtocol实现的</li></ul><h2 id="编码单元视图"><a href="#编码单元视图" class="headerlink" title="编码单元视图"></a>编码单元视图</h2><ul><li>String允许我们以Unicode标量和特定编码方式的编码单元来查看</li><li>可以直接将utf8的String传递给C函数指针，这是编译器优化过的，如果是utf16，编译器会先进行编码转换，然后传递</li><li>注意，这些视图仍然是不支持随机访问，只支持通过String.Index访问，由于String.Index一般是位于边界的，所以一般从String获取的Index用于视图上不会有啥问题，反之，如果是从视图创建一个String.Index再用于String，则可能崩溃（嘛，不一定在边界了</li></ul><h2 id="String和Foundation"><a href="#String和Foundation" class="headerlink" title="String和Foundation"></a>String和Foundation</h2><ul><li>String和NSString和无缝转换，并且如果引入了Foundation库，String可以使用NSString的api</li><li>NSString的默认编码时UTF16，而String的默认编码时UTF8，所以在调用NSString时会存在一定开销</li><li>Foundation中的CharacterSet，实际上的含义就是Unicode标量的集合，方便我们判断一个字符是否在某个特定集合中（如字母、数字）</li><li>Foundation中的一些关于NSString的api可能还不兼容Swift，需要我们手动转换，比如NSString进行正则匹配，返回的基于标量的NSRange，而swift可能并不认为这个标量在String中能独立存在，所以必须转换会Range再判断</li></ul><h2 id="Unicode属性"><a href="#Unicode属性" class="headerlink" title="Unicode属性"></a>Unicode属性</h2><ul><li>在Swift中，CharacterSet的部分功能放到了Unicode.Scalar.Properties中，比如判断是否为emoji</li><li>一些功能在Charater中也有，比如判断一个字符是否为数字</li></ul><h2 id="String和Character的内部结构"><a href="#String和Character的内部结构" class="headerlink" title="String和Character的内部结构"></a>String和Character的内部结构</h2><ul><li>String也是实现了COW的</li><li>对于长度小于16个编码单元，Swft会进行编译优化，采用内联方式存储</li><li>Character的内部实际就是长度为1的String</li></ul><h2 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h2><ul><li>String和字符串字面量是不同的，String实际上是实现了ExpressibleByStringLiteral的类型</li><li>我们可以为自己的类型实现ExpressibleByStringLiteral</li></ul><h2 id="String插值"><a href="#String插值" class="headerlink" title="String插值"></a>String插值</h2><ul><li>插值使用ExpressibleByStringInterpolation和StringInterpolationProtocol组成，而ExpressibleByStringInterpolation又继承自ExpressibleByStringLiteral</li><li>标准库中实现了一个DefaultStringInterpolation，其符合tringInterpolationProtocol，这使得我们可以直接进行字符串插值</li><li>我们可以自行实现相关协议，为我们自己的类型实现字String插值来转换为对应的对象</li></ul><h2 id="定制字符串描述"><a href="#定制字符串描述" class="headerlink" title="定制字符串描述"></a>定制字符串描述</h2><ul><li>实现CustomStringConvertible和CustomDebugStringConvertible在print时自定义输出内容</li><li>LosslessStringConvertible：继承自CustomStringConvertible，用于将字符串转换会自定义类型，但是很少使用（一般都用codeable进行序列化）</li></ul><h2 id="文本输出流"><a href="#文本输出流" class="headerlink" title="文本输出流"></a>文本输出流</h2><ul><li>print和dump默认是输出到标注输出，但实际上，只要对象支持TextOutputStream协议就可以重定向print和dump到该对象，比如String</li><li>_playgroundPrintHook是个全局变量，可以hook输出的print的内容</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-枚举</title>
    <link href="/2023/12/24/swift-advance-enum/"/>
    <url>/2023/12/24/swift-advance-enum/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>struct和class有时也被称为记录类型，一个记录是任意个属性组成。而枚举称为标签联合或变体类型，它和记录类型也一样强大。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>enum由任意个case组成，每个case有关联值</li><li>Optional和Result实际上都是枚举</li><li>枚举时值类型，和结构体类似，但是没有存储属性，我们可以将关联值视为存储属性</li></ul><h2 id="总和类型和乘积类型"><a href="#总和类型和乘积类型" class="headerlink" title="总和类型和乘积类型"></a>总和类型和乘积类型</h2><ul><li>居留元：简单理解就是一个类型的可能的取值，类型可以理解为取值的集合</li><li>strcut和class中的居留元数量，等于其成员的居留元数量的乘积，因为被称为乘积类型</li><li>enum的居留元数量，等于其所有case的累加</li></ul><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><ul><li>switch通过方便的语法，可以比较成员和提取关联值，这一机制称为模式匹配，类似于<strong>正则匹配</strong></li><li>支持的模式类型<ul><li>通配符，如_,匹配任意值并忽略</li><li>元祖模式，如case (let x, 0, _)</li><li>美爵成员模式， 如.failure(let error)</li><li>值绑定模式，如let x，注意let (x, y) &#x3D; (let x, let y)，但是let x，y则表示绑定x，并且和y进行比较</li><li>可以在绑定模式添加where限定条件，如.success(let status) where 200..&lt;300 ~&#x3D; httpStatus</li><li>如果是在单个case去匹配多个模式，则每个模式中let的数量、变量名和类型均要相同</li><li>可选值模式，let x?，即可选值x不为nil时才匹配并绑定到x</li><li>类型转换模式，let x as Type</li><li>表达式模式，将输入值和模式作为参数传递给定义在标准库中的~&#x3D;操作符进行判断，对于实现了Equatable协议的类型，~&#x3D;的默认行为是转发到&#x3D;&#x3D;</li><li>标准库为范围提供~&#x3D;的重载，可以方便的检查某个值是否在范围内</li><li>可以通过重载~&#x3D;操作符来扩展模式匹配，返回true表示匹配成功</li></ul></li><li>其他情景中的模式匹配：模式匹配并不是enum和switch的专属，我们可以在解构元祖，for循环、catch、if、guard中都可以使用。for case、while case仅在匹配成功的情况下才会执行循环体</li></ul><h2 id="使用enum进行设计"><a href="#使用enum进行设计" class="headerlink" title="使用enum进行设计"></a>使用enum进行设计</h2><ul><li>switch的完备性：即编译器保证所有的分支均能被覆盖到，否则报错</li><li>避免产生非法状态：因为enum的状态有限，每个状态都是单一的，使用enum更加能确保状态的合法性</li><li>enum是实现状态的绝佳选择：比如loading、success、failed，略</li></ul><h2 id="选择enum还是struct"><a href="#选择enum还是struct" class="headerlink" title="选择enum还是struct"></a>选择enum还是struct</h2><ul><li>enum和struct是类似的，有时都能完成相同的事情，比较如下：<ul><li>enum更精确、状态有限、可以使用switch</li><li>struct则可以方便扩展、包含私有成员</li><li>即struct相对来说扩展性更好，更灵活，但enum更加精确，更不容易出错（嘛，凡事皆有代价</li></ul></li></ul><h2 id="enum和protocol的相似之处"><a href="#enum和protocol的相似之处" class="headerlink" title="enum和protocol的相似之处"></a>enum和protocol的相似之处</h2><ul><li>都能表达<strong>某种类型之一</strong>的语义，enum是通过case，而protocol则是通过具体类型</li><li>如果我们侧重于添加成员，则用protocol更好，因为修改enum的case会破坏源码</li></ul><h2 id="使用enum实现递归数据结构"><a href="#使用enum实现递归数据结构" class="headerlink" title="使用enum实现递归数据结构"></a>使用enum实现递归数据结构</h2><ul><li>比如用enum实现树形结构</li><li>用indirect case让某个case表示为引用，indirect只能用在enum上，可以用在case前面，也可以直接加载enum前面</li><li>enum的大小是其最大case的大小+元数据，和c语言中的union及其类似，每个case的大小是其关联值的大小，但如果是indirect的，则是固定大小8（理解为指针嘛</li></ul><h2 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h2><ul><li>enum可以指定原始值类型，即每个case对应一个固定的rawValue，和关联值无关，一般就是一个整数或字符串</li><li>RawRepresentable: 该协议的方法，即init(rawValue:)，RawValue类型为String、整数、浮点类型的enum默认符合，如果需要自定义，可以显示指定enum符合该协议，自己实现init方法，但是注意<strong>rawValue必须唯一！！</strong></li><li>RawRepresentable也可以由struct和class来实现</li><li>注意rawValue并不是enum中存储的，不影响enum的大小，其更加类似于于计算属性</li></ul><h2 id="列举枚举值"><a href="#列举枚举值" class="headerlink" title="列举枚举值"></a>列举枚举值</h2><ul><li>没有关联值的enum，默认是可列举的，我们只需要将其声明为符合CaseIterable，编译器会为我们实现</li><li>CaseIterable也可以用于struct和class，我们自己实现allCases方法即可</li></ul><h2 id="固定和非固定enum"><a href="#固定和非固定enum" class="headerlink" title="固定和非固定enum"></a>固定和非固定enum</h2><ul><li>可能增加case的enum称为非固定的，为了应对以后二进制sdk中新增enum的case，我们一般需要加一个default</li><li>apple的sdk库一般都是弹性库，即可能变化，其中的enum一般都是非固定enum（Optional是个例外</li><li>@unknown default：前面的@unknown告知编译器，这个default只是为了应对为二进制sdk中了可能增加的enum的case，而如果在本次编译时就知道有些case没有处理，仍然要给我报错</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-结构体和类</title>
    <link href="/2023/12/23/swift-advance-struct-and-class/"/>
    <url>/2023/12/23/swift-advance-struct-and-class/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>结构体是值类型，类是引用类型。</p><h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><ul><li>值类型：当赋值时会被copy一份，也就是说，每个值类型变量的数据都是独立的，其变量本身的地址中存储的就是值，具有这种行为的类型称为具有<strong>值语义</strong></li><li>引用类型，变量本身的地址存储的是值的引用（可能是地址，也可能是其他的间接句柄），而非值，具有这种行为的类型称为具有引用语义</li><li>说白了还是和其他语言一样，就是直接存储值还是存储地址的区别</li></ul><h2 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h2><ul><li>对struct中的属性修改，本质是创建了一个新的struct替换了原来的struct</li><li>推荐使用var来声明struct中的属性</li><li>struct中的方法默认不能修改结构体本身，如有必要，添加mutating关键字。属性和下标的stter默认都是mutating的</li><li>调用struct的mutating方法，要求struct本身是var的。如果要调用一个let的struct属性setter，可以将该setter标记为nonmutating set，告知编译器该setter不会修改struct</li><li>inout参数：实际的过程是先copy参数，然后修改参数，最后用修改完的参数覆盖原来的值。编译器有时会将这种行为优化为传递引用，但不要依赖这种行为。并且，如果使用了观察者，则无论在函数中修改了多少次，只会在最终被覆盖的时候得到通知</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li>结构体的生命周期很简单，就是含有结构体实例变量的生命周期一致，一旦离开作用域就会被销毁</li><li>类的生命周期，取决于ARC</li><li>由于结构体不存在引用，所以也就无所谓结构体的循环引用问题</li><li>打破类的循环引用，weak或unowned</li><li>unowened实际的作用就是不持有引用，所以允许我们声明为非可选值，而weak引用必须声明为可选值。但是<strong>unowned不安全</strong>，如果释放之后再访问unowned会崩溃（是runtime崩溃，而不是badaccess崩溃，类似于断言）！！！虽然这里Swift只要unowned引用还存在，对象内存就不会释放，但是会标记为无效，即所谓僵尸内存</li><li>Swift中，类不是唯一的引用类型，actor以及函数（包括闭包表达式&amp;方法）都是引用类型</li><li>捕获列表，实际就是常用的在闭包中使用的[weak self]，但是捕获列表中还可以直接创建变量，例如<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Swift">window<span class="hljs-operator">?</span>.onRotate <span class="hljs-operator">=</span> &#123; [<span class="hljs-keyword">weak</span> view, <span class="hljs-keyword">weak</span> myWindow<span class="hljs-operator">=</span>window, x<span class="hljs-operator">=</span><span class="hljs-number">5</span><span class="hljs-operator">*</span><span class="hljs-number">5</span>] <span class="hljs-keyword">in</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="在struct和class中做选择"><a href="#在struct和class中做选择" class="headerlink" title="在struct和class中做选择"></a>在struct和class中做选择</h2><ul><li>结构体的优点是开销小，不用担心循环引用、多线程、继承问题，缺点不如类具有共享的特性</li><li>类则更加灵活和强大，可以使用类实现结构体的值语义，反之则不行</li></ul><h2 id="具有值语义的类"><a href="#具有值语义的类" class="headerlink" title="具有值语义的类"></a>具有值语义的类</h2><ul><li>我们可以final class，并将其中的属性都声明为let来实现值语义（嘛，这显然没有结构体好用</li></ul><h2 id="具有引用语义的结构体"><a href="#具有引用语义的结构体" class="headerlink" title="具有引用语义的结构体"></a>具有引用语义的结构体</h2><ul><li>可以在struct中使用类属性实现引用语义</li><li>所以在strcut中使用类属性要小心，不然可能会意外修改其值语义</li><li>这种设计可以被用于实现COW，见下</li></ul><h2 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h2><ul><li>即COW，实际的意思就是修改时才发生真正的复制，很常见的优化</li><li>自己实现COW，我们需要知道一般的实现原理：在没有发生修改之前，各变量都持有的值的内部都共享一份引用，如果一旦发生修改内部共享存储的行为（调用了set方法或者其他什么的），就将原来的内部共享存储进行copy，修改该copy属性</li><li>查询Swift的引用类型是否只有一个持有者：isKnownUniquelyReferenced，但是注意该函数不是线程安全的，所以多线程对数组append是非线程安全的，该函数的参数是个inout参数，否则在传递参数的时候肯定会进行一次引用，函数功能就失效了<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">HTTPRequest</span> &#123;<br>    <span class="hljs-comment">// 内部判断是否触发copy以实现COW</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> storageForWriting: <span class="hljs-type">HTTPRequest</span>.<span class="hljs-type">Storage</span> &#123;<br>        <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-operator">!</span><span class="hljs-built_in">isKnownUniquelyReferenced</span>(<span class="hljs-operator">&amp;</span>storage) &#123;<br>            <span class="hljs-keyword">self</span>.storage <span class="hljs-operator">=</span> storage.copy()<br>            &#125;<br>            <span class="hljs-keyword">return</span> storage<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> path: <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123; storage.path &#125;<br>        <span class="hljs-keyword">set</span> &#123; storageForWriting.path <span class="hljs-operator">=</span> newValue &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> headers: [<span class="hljs-type">String</span>: <span class="hljs-type">String</span>] &#123;<br>        <span class="hljs-keyword">get</span> &#123; storage.headers &#125;<br>        <span class="hljs-keyword">set</span> &#123; storageForWriting.headers <span class="hljs-operator">=</span> newValue &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>注意willSet会导致COW性能的破坏，因为如果实现了willSet，则编译器在设置新值之前一定会先创建值，那么会导致值中的共享存储的引用增加，导致判断失效，导致必然发生复制</li><li>在SwiftUI中，由于@Pushlied使用了willSet，所以会造成一些性能问题，每次修改@Published属性，都会导致数组的copy</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-属性</title>
    <link href="/2023/12/23/swift-advance-property/"/>
    <url>/2023/12/23/swift-advance-property/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Swift属性分为存储属性和计算属性，属性可以被看做是一种定义在类型上的变量。</p><h2 id="变更观察者"><a href="#变更观察者" class="headerlink" title="变更观察者"></a>变更观察者</h2><ul><li>为属性和变量实现willSet和didSet方法</li><li>观察方法必须在声明属性时就进行定义，而不能在扩展中添加。注意和OC中KVO不同。KVO是外部用来跟踪对象内部变化的手段</li><li>观察者可以在子类中重写属性以实现观察者</li><li>Swift的观察者是纯编译时特性，而KVO则是OC利用runtime实现的动态特性</li></ul><h2 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h2><ul><li>使用lazy var修饰，只有当第一次使用时才会被创建（仅调用1次）</li><li>扩展中只能声明计算属性，不能声明存储&amp;延迟存储属性</li><li>lazy var是mutating性质的，所以如果访问结构体的延迟存储属性，必须将结构体声明为var，所以通常不要在结构体中声明lazy var</li><li>注意，<strong>lazy var存在线程安全问题，多线程情况下可能会被调用多次！！！</strong>，在oc中，懒加载属性实行可能会在多线程情况下造成崩溃<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-comment">// 如果多线程调用，那么当A线程对_object属性覆盖的时候，可能将会导致B线程的_object被提前释放，如果此时B线程恰好正在对释放之前的地址进行发消息，就会造成崩溃</span><br>- (NSObject *)<span class="hljs-keyword">object</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-number">_</span><span class="hljs-keyword">object</span>) &#123;<br>        <span class="hljs-number">_</span><span class="hljs-keyword">object</span> = [NSObject <span class="hljs-keyword">new</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">_</span><span class="hljs-keyword">object</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>需要谨记，在OC中，读取&amp;设置属性在runtime层面上都不是原子性的，如果存在多线程访问，需要考虑崩溃问题</li></ul><h2 id="属性包装"><a href="#属性包装" class="headerlink" title="属性包装"></a>属性包装</h2><ul><li>和resultBuilder一样，propertyWrapper也是很大程度上就是因为SwiftUI而引入的</li><li>当我们使用propertyWrapper时，其实就是告知编译器向对该属性封装为一个结构体&#x2F;类，对该属性的存取转换为对该结构体&#x2F;类中init和属性计算方法的调用<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">@propertyWrapper</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>&lt;<span class="hljs-title class_">A</span>&gt; &#123;<br>    <span class="hljs-keyword">var</span> wrappedValue: <span class="hljs-type">A</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">wrappedValue</span>: <span class="hljs-type">A</span>) &#123;<br>        <span class="hljs-keyword">self</span>.wrappedValue <span class="hljs-operator">=</span> wrappedValue<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>在SwiftUI中，@State中的管理的值实际是被SwiftUI管理，@Binding的值实际是对应的@State中的值，@Binding并不关心值在哪，值关心setter和ggeter</li><li>投影值，即projectedValue，通过对属性包装调用$而创建</li><li>本质上，@Binding实际也是一个结构体，只不过这个结构体中存储的不是实际的值，而是setter和getter，那么这个setter和getter就是@State的projectValue在创建@Binding时赋值的</li><li>@State&#x2F;@Observedbject -&gt; 投影值 -&gt; @Binding，对@Binding的存取即通过setter&#x2F;getter间接的称为对@State&#x2F;@ObservedObject中属性的存取，就是这么简单~~<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">// 投影值本身，其特殊支出在于存储的东西不是实例而是函数</span><br><span class="hljs-keyword">@propertyWrapper</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Reference</span>&lt;<span class="hljs-title class_">A</span>&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _get: () -&gt; <span class="hljs-type">A</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _set: (<span class="hljs-type">A</span>) -&gt; ()<br>    <br>    <span class="hljs-keyword">var</span> wrappedValue: <span class="hljs-type">A</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            _get()<br>        &#125;<br>        <span class="hljs-keyword">set</span> &#123;<br>            _set(newValue)<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">get</span>: <span class="hljs-keyword">@escaping</span> () -&gt; <span class="hljs-type">A</span>, <span class="hljs-params">set</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">A</span>) -&gt; ()) &#123;<br>        _get <span class="hljs-operator">=</span> <span class="hljs-keyword">get</span><br>        _set <span class="hljs-operator">=</span> <span class="hljs-keyword">set</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义属性包装的投影值</span><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Box</span> &#123;<br>    <span class="hljs-keyword">var</span> projectedValue: <span class="hljs-type">Reference</span>&lt;<span class="hljs-type">A</span>&gt; &#123;<br>        <span class="hljs-type">Reference</span>&lt;<span class="hljs-type">A</span>&gt; &#123; () -&gt; <span class="hljs-type">A</span> <span class="hljs-keyword">in</span><br>            <span class="hljs-keyword">self</span>.wrappedValue<br>        &#125; <span class="hljs-keyword">set</span>: &#123; (i) <span class="hljs-keyword">in</span><br>            <span class="hljs-keyword">self</span>.wrappedValue <span class="hljs-operator">=</span> i<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>有时，我们并不希望将整个wrapperedValu而通过投影值传递，而是希望让传递wrappedValue中的某个属性，那我们不能写成$A.xxx，因为$Type已经是投影类型了，它没有xxx这个属性。方法自然是有的，我们需要为投影类型实现动态成员查找：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">@propertyWrapper</span><br><span class="hljs-keyword">@dynamicMemberLookup</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Reference</span>&lt;<span class="hljs-title class_">A</span>&gt; &#123;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">subscript</span>&lt;<span class="hljs-type">B</span>&gt;(<span class="hljs-params">dynamicMember</span> <span class="hljs-params">keyPath</span>: <span class="hljs-type">WritableKeyPath</span>&lt;<span class="hljs-type">A</span>, <span class="hljs-type">B</span>&gt;)<br>-&gt; <span class="hljs-type">Reference</span>&lt;<span class="hljs-type">B</span>&gt; &#123;<br>    <span class="hljs-type">Reference</span>&lt;<span class="hljs-type">B</span>&gt;(get: &#123;<br>        <span class="hljs-keyword">self</span>.wrappedValue[keyPath: keyPath]<br>    &#125;) &#123;<br>        <span class="hljs-keyword">self</span>.wrappedValue[keyPath: keyPath] <span class="hljs-operator">=</span> <span class="hljs-variable">$0</span><br>    &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>这样，当我们使用$A.xxxx时，就会转换为对Refrerence&lt;A&gt;[dynmiacMembers:\.xxxx]的调用，从而能够获取到对原始实例的存取</li><li>有时，属性只在能够获取到其宿主时才会发挥作用，比如Combine框架中的@Published，它实际上必须要调用宿主的（ObservableObject类型）的objectWillChanged才work，要想实现这种效果，需要通过实现一个特定的subscript方法，这里暂时不详细探究了</li><li>SwiftUI中的@State实际就是必须获取到宿主View的层级才work的</li><li>由于属性包装编译器必须生成存储属性，而enum在case之外是不能放存储属性的，因而enum中不能使用属性包装</li><li>可以在函数中使用属性包装，并且从Swift 5.5开始，也可以将属性包装作为函数参数传递</li></ul><h2 id="键路径"><a href="#键路径" class="headerlink" title="键路径"></a>键路径</h2><ul><li>也就是KeyPath，表示对一个属性为调用的引用，如\Type.xxx，因为Type可能本身有个static的xxx属性，为了区分开，需要加个\。如果可以类型推断，可省略Type，即\.xxx</li><li>KeyPath可以由任意存储属性和计算属性组合，包括可选类型，编译器会自动为为每个类型生成[keyPath:]下标方法</li><li>WriteableKeyPath：可以通过该KeyPath对属性修改，要求原值是可变的</li><li>ReferenceWritableKeyPath：同上，但是针对于引用语义的值</li><li>KeyPath：不可通过该KeyPath对属性修改</li><li>KeyPath还可以用于描述下标操作，如\.[1].name</li><li>KeyPath某种程度上和函数类似，都是给定参数获取值，或者传入参数设置值，但是KeyPath本身可以比较判等，并且无状态，这和函数不同</li><li>编译器可以自动将KeyPath转换为函数，如xx.map(\.name)等价于xx.map{$0.name}，注意这个仅对直接写的时候有效，如果将KeyPath放到变量中是无效的</li><li>KeyPath还可以组合，需要注意类型必须要匹配<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs julia">// KeyPath&lt;Person, <span class="hljs-built_in">String</span>&gt; + KeyPath&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Int</span>&gt; = KeyPath&lt;Person, <span class="hljs-built_in">Int</span>&gt;<br><span class="hljs-keyword">let</span> nameCountKeyPath = nameKeyPath.appending(path: \.count)<br>// Swift.KeyPath&lt;Person, Swift.<span class="hljs-built_in">Int</span>&gt;<br></code></pre></td></tr></table></figure></li><li>可写的KeyPath在SwiftUI中很常见，比如通过其修改环境值，在之前也看到过结合投影类型的动态成员查找，方便实现任意属性的投影</li><li>总结下5种类型的KeyPath，其中WritableKeyPath和ReferenceWritableKeyPath进行区分是必要的，前一个类型的setter要求它的参数是inout的<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-type">AnyKeyPath</span> like (<span class="hljs-keyword">Any</span>) -&gt; <span class="hljs-keyword">Any</span><span class="hljs-operator">?</span><br><span class="hljs-type">PartialKeyPath</span>&lt;<span class="hljs-type">Source</span>&gt; like (<span class="hljs-type">Source</span>) -&gt; <span class="hljs-keyword">Any</span><span class="hljs-operator">?</span><br><span class="hljs-type">KeyPath</span>&lt;<span class="hljs-type">Source</span>, <span class="hljs-type">Target</span>&gt; like (<span class="hljs-type">Source</span>) -&gt; <span class="hljs-type">Target</span><br><span class="hljs-type">WritableKeyPath</span>&lt;<span class="hljs-type">Source</span>, <span class="hljs-type">Target</span>&gt; like (<span class="hljs-type">Source</span>) -&gt; <span class="hljs-type">Target</span> and (<span class="hljs-keyword">inout</span> <span class="hljs-type">Source</span>,     <span class="hljs-type">Target</span>) -&gt; ()<br><span class="hljs-comment">// 这一对函数相似。第二个函数可以用Target来更新Source值且要求 Source 是一个引用类型 </span><br><span class="hljs-type">ReferenceWritableKeyPath</span>&lt;<span class="hljs-type">Source</span>, <span class="hljs-type">Target</span>&gt; like (<span class="hljs-type">Source</span>) -&gt; <span class="hljs-type">Target</span> and (<span class="hljs-type">Source</span>, <span class="hljs-type">Target</span>) -&gt; ()<br></code></pre></td></tr></table></figure></li><li>相比于OC，OC的键路径是通过字符串实现的，并且没有类型约束，魔种程度上类似于AnyKeyPath，但是不安全</li><li>KeyPath目前还存在性能问题，比直接访问要慢（因为毕竟是动态嘛…</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-函数</title>
    <link href="/2023/12/21/swift-advance-function/"/>
    <url>/2023/12/21/swift-advance-function/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>函数在Swift中和类一样，都是头等公民，可以被赋值给变量，可以被传递，可以捕获外部变量。当函数捕获变量时，可以视作函数和被捕获的变量构成了一个类对象（但是函数不可比较）。<br>函数既可以使用func关键字声明，也可以用闭包表达式来声明，eg.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">let</span> f <span class="hljs-operator">=</span> &#123;(i: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">return</span> i <span class="hljs-operator">*</span> <span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><p>闭包表达式与func的主要区别在于闭包是匿名的，只能被赋值给变量或者作为参数传递。<br>在Swift中，函数&#x3D;&#x3D;闭包，没什么不同，只是写的形式可能有区别。</p><h2 id="函数的灵活性"><a href="#函数的灵活性" class="headerlink" title="函数的灵活性"></a>函数的灵活性</h2><ul><li>如何实现复杂的排序规则，在OC中，可以通过NSSortDescriptor，但仅限于NSObject类，在Swift中使用高阶函数可以完成</li><li>(Value) -&gt; (Value) -&gt; ComparisonResult的含义实际上就是(Value) -&gt; ((Value) -&gt; ComparisonResult)，即给定一个值，返回一个闭包<br>看一个例子：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SortDescriptor</span>&lt;<span class="hljs-title class_">Root</span>&gt; &#123;<br>    <span class="hljs-keyword">var</span> areInIncreasingOrder: (<span class="hljs-type">Root</span>, <span class="hljs-type">Root</span>) -&gt; <span class="hljs-type">Bool</span><br>&#125;<br><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">SortDescriptor</span> &#123;<br>    <span class="hljs-keyword">init</span>&lt;<span class="hljs-type">Value</span>&gt;(<span class="hljs-params">key</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Root</span>) -&gt; <span class="hljs-type">Value</span>,<br>                <span class="hljs-params">compare</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Value</span>) -&gt; ((<span class="hljs-type">Value</span>) -&gt; <span class="hljs-type">ComparisonResult</span>)) &#123;<br>        <span class="hljs-comment">// 注意这里$0和$1表示的是areInIncreasingOrder的两个参数</span><br>        <span class="hljs-keyword">self</span>.areInIncreasingOrder <span class="hljs-operator">=</span> &#123;<br>            compare(key(<span class="hljs-variable">$0</span>))(key(<span class="hljs-variable">$1</span>)) <span class="hljs-operator">==</span> .orderedAscending<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> sortByFirstName: <span class="hljs-type">SortDescriptor</span>&lt;<span class="hljs-type">Person</span>&gt; <span class="hljs-operator">=</span> .<span class="hljs-keyword">init</span>(key: &#123;<span class="hljs-variable">$0</span>.first&#125;, compare: <span class="hljs-type">String</span>.localizedStandardCompare)<br></code></pre></td></tr></table></figure>这里String.localizedStandardCompare的类型就是(String) -&gt; (String) -&gt; ComparisonResult，它等价于string1.localizedStandardCompare(string2)<br>通过高阶函数+泛型，我们可以方便的生成普适性的函数&#x2F;闭包，从而达到简洁的效果。（但是有时也会加大理解负担）</li><li>还可以通过将SortDescriptor进行封装组合，形成更加强大复杂的排序方式，比如<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">SortDescriptor</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">then</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">other</span>: <span class="hljs-type">SortDescriptor</span>&lt;<span class="hljs-type">Root</span>&gt;) -&gt; <span class="hljs-type">SortDescriptor</span>&lt;<span class="hljs-type">Root</span>&gt; &#123;<br>        <span class="hljs-type">SortDescriptor</span> &#123; x, y <span class="hljs-keyword">in</span><br>        <span class="hljs-keyword">if</span> areInIncreasingOrder(x,y) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br>        <span class="hljs-keyword">if</span> areInIncreasingOrder(y,x) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>        <span class="hljs-keyword">return</span> other.areInIncreasingOrder(x,y)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>这里使用then将descriptor进行组合，实际类似于java中的builder模式，在最后调用的时候，按照从里到外的顺序调用每个desriptor的areInIncreasingOrder方法</li></ul><h2 id="函数作为代理"><a href="#函数作为代理" class="headerlink" title="函数作为代理"></a>函数作为代理</h2><ul><li>如果只需要一个函数作为回调，那么使用函数而不需要使用代理</li><li><strong>Swift中的闭包捕获的变量类比于OC来说默认是__block的</strong>，既可以影响外部被捕获的值，而不是copy</li></ul><h2 id="inout参数和可变方法"><a href="#inout参数和可变方法" class="headerlink" title="inout参数和可变方法"></a>inout参数和可变方法</h2><ul><li>inout参数实际上并不是直接修改原来的参数，而是先copy，然后修改，再将修改完之后的值copy回去（但是编译器可能优化为传地址，但是不应依赖该行为）</li><li>只能使用var作为inout参数：肯定啊，不然咋修改</li><li>数组下标也可以作为inout参数，实际上，支持set&#x2F;get的所有下标操作都能被作为inout参数</li><li>在嵌套函数中也可以使用inout，但是嵌套函数不能逃逸</li><li>如果参数声明为UnsafeXXXPointer，则&amp;表示取指针而不是inout参数</li></ul><h2 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h2><ul><li>subscript函数</li><li>参数后…表示可变长度参数，可作为数组使用</li></ul><h2 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h2><ul><li>@autoclosure告知编译器，应当将传入的表达式转换为闭包，eg.<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">and</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">l</span>: <span class="hljs-type">Bool</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">r</span>: <span class="hljs-keyword">@autoclosure</span> () -&gt; <span class="hljs-type">Bool</span>) -&gt; <span class="hljs-type">Bool</span> &#123;<br>    <span class="hljs-keyword">guard</span> l <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-keyword">return</span> r()<br>&#125;<br><br><span class="hljs-keyword">if</span> and(<span class="hljs-operator">!</span>evens.isEmpty, evens[<span class="hljs-number">0</span>] <span class="hljs-operator">&gt;</span> <span class="hljs-number">10</span>) &#123;<br>    <span class="hljs-comment">// 执行操作</span><br>&#125; <br></code></pre></td></tr></table></figure></li><li>#fileId, #function, #line在编译器中表示<strong>调用者</strong>的文件名、函数名和行号</li></ul><h2 id="escaping"><a href="#escaping" class="headerlink" title="@escaping"></a>@escaping</h2><ul><li>表示作为参数传递的闭包可以被保存并在稍后使用</li><li>闭包参数如果是直接参数，默认是非escaping的，但可选值类型、存储属性、封装在元组中的闭包是escaping的</li><li>有时我们确实知道闭包时不会逃逸的，但又不想传递可选值，那么可以使用withoutActuallyEscaping来告知编译器,但是安全性需要自己保证：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Array</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">allSatisfy2</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">predicate</span>: (<span class="hljs-type">Element</span>) -&gt; <span class="hljs-type">Bool</span>) -&gt; <span class="hljs-type">Bool</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">withoutActuallyEscaping</span>(predicate) &#123; escapablePredicate <span class="hljs-keyword">in</span><br>        <span class="hljs-keyword">self</span>.lazy.filter &#123; <span class="hljs-operator">!</span>escapablePredicate(<span class="hljs-variable">$0</span>) &#125;.isEmpty<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="ResultBuilder"><a href="#ResultBuilder" class="headerlink" title="ResultBuilder"></a>ResultBuilder</h2><ul><li>当编译器遇到ResultBuilder注解时，会将被注解函数表达式转换对特定结构体中函数的调用，从而得到最终结果，最典型的例子就是SwiftUI中的ViewBuilder，这可能也是ResultBuilder被引入的动机之一<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">@inlinable</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">alignment</span>: <span class="hljs-type">VerticalAlignment</span> <span class="hljs-operator">=</span> .center, <span class="hljs-params">spacing</span>: <span class="hljs-type">CGFloat</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>, <span class="hljs-meta">@ViewBuilder</span> <span class="hljs-params">content</span>: () -&gt; <span class="hljs-type">Content</span>)<br></code></pre></td></tr></table></figure></li><li>实际上，Swift会将@ViewBuilder注解函数中的表达式转换为调用ViewBuilder结构体中的buildBlock的函数调用，等价于<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">@resultBuilder</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ViewBuilder</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">buildBlock</span>&lt;<span class="hljs-type">C0</span>, <span class="hljs-type">C1</span>, <span class="hljs-type">C2</span>&gt;(<span class="hljs-keyword">_</span> <span class="hljs-params">c0</span>: <span class="hljs-type">C0</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">c1</span>: <span class="hljs-type">C1</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">c2</span>: <span class="hljs-type">C2</span>)<br>    -&gt; <span class="hljs-type">TupleView</span>&lt;(<span class="hljs-type">C0</span>, <span class="hljs-type">C1</span>, <span class="hljs-type">C2</span>)&gt;<br>    <span class="hljs-keyword">where</span> <span class="hljs-type">C0</span>: <span class="hljs-type">View</span>, <span class="hljs-type">C1</span>: <span class="hljs-type">View</span>, <span class="hljs-type">C2</span>: <span class="hljs-type">View</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>注意ViewBuilder前面的注解@resultBuilder，其可以实现一系列不同的buildXXX方法</li><li>注意@resultBuilder注解时Swift 5.4引入的</li><li>最基本的方法是buildBlock和buildExperssion，@resultBuilder要求至少实现一个buildBlock方法</li><li>buildBlock中的参数和类型并不要求一致，但是如果想要函数支持多种类型，使用buildExpression时更加优雅的方式，其作用是在将参数传递给buildXXX之前先应用该函数进行转换</li><li>通过重载buildExpression方法，我们可以实现一些特殊逻辑，比如一般builder函数（即被标记为@XXXBuilder的函数）中是不能调用print方法的，因为print方法返回的是Void。我们可以添加一个将Void转换为需要参数类型的buildExpression来绕过</li><li>@available注解格式<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">@available</span>(版本范围, 可用性, message: 错误消息)<br></code></pre></td></tr></table></figure></li><li>builder还可以通过实现buildIf和buildEither来支持if，if else和switch语句<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">// 支持单个if，因为if语句要么有值，要么值为nil，所以参数是可选值类型</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">buildIf</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">s</span>: <span class="hljs-type">String</span>?) -&gt; <span class="hljs-type">String</span> &#123;<br>    s <span class="hljs-operator">??</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 支持if else的if分支，要求if分支必须返回是String</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">buildEither</span>(<span class="hljs-params">first</span> <span class="hljs-params">component</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> &#123;<br>    component<br>&#125;<br><br><span class="hljs-comment">// 支持if else的else分支，要求else分支必须返回是String</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">buildEither</span>(<span class="hljs-params">second</span> <span class="hljs-params">component</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> &#123;<br>    component<br>&#125;<br><br><span class="hljs-comment">// 实现了if else，switch是实现了，switch也可以看做是if else的嵌套调用，但是实际上switch除了第一个case是buildEither(first:)，其余分支都是buildEdither(second:)</span><br></code></pre></td></tr></table></figure></li><li>builder还可以支持循环<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">buildArray</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">components</span>: [<span class="hljs-type">String</span>]) -&gt; <span class="hljs-type">String</span> &#123;<br>    components.joined(separator: <span class="hljs-string">&quot;&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>buildFindalResult:将会在builder函数的最后的结果被应用</li><li>resultBuilder不支持guard、defer、do…catch等，因为这些语句无法被求值</li><li>总结：通过实现一系列build方法，创建一个XXXBuilder，通过@XXXBuilder将函数&#x2F;闭包转换为对build方法的调用，从而实现自定义DSL的效果</li><li>所以为啥View中的body能返回不同类型的View呢，<strong>实际上View的body就是@ViewBuilder</strong>，但是并不是任何属性都具有该特特性，正常情况下，<strong>某个标记为some View的属性需要返回相同类型的View</strong>，我们可以加上@ViewBuilder注解（因为some View就是某种特定具体类型的View，所以如果返回的类型不同，自然无法编译通过，<strong>通过加上ViewBuilder注解让编译器帮我们将表达式转换为统一的封装类型</strong>就OK了~~）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-可选值</title>
    <link href="/2023/12/20/swift-advance-optional-value/"/>
    <url>/2023/12/20/swift-advance-optional-value/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分主要介绍Swift中可选值的底层原理</p><h2 id="哨岗值"><a href="#哨岗值" class="headerlink" title="哨岗值"></a>哨岗值</h2><ul><li>在许多时候，函数在没有读取到有效值后需要返回给我们一个特定的值，称为哨岗值，比如EOF、-1、null等等</li><li>哨岗值有时是有效的值，比如-1，但有时候这种情况会导致错误的结果，比如OC对nil发消息，如果方法返回的是结构体，则会是一个值全部为0的结构体，这时有可能导致逻辑错误,eg<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-built_in">NSString</span> *someString = ...;<br><span class="hljs-keyword">if</span> ([someString rangeOfString:<span class="hljs-string">@&quot;Swift&quot;</span>].location != <span class="hljs-built_in">NSNotFound</span>) &#123;<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Someone mentioned Swift!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>如果someString是nil，location就会是0而不是NSNotFound（是NSIntegerMax），显然是错误的。</li><li>哨岗值还依赖约定，如果不知道约定，则无法使用。</li><li>Swift通过枚举实现Optional来解决哨岗值的问题,没错，可选值的本质实际就是带有关联值的Swift枚举<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Optional</span>&lt;<span class="hljs-title class_">Wrapped</span>&gt; &#123;<br><span class="hljs-keyword">case</span> none<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">some</span>(<span class="hljs-type">Wrapped</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>Swift中对于可能是哨岗值的返回的都是可选值，从而避免了必须了解哨岗值约定的问题</li><li>语法糖使得使用可选值更加方便：<ul><li>Type? &#x3D; Optional<Type></li><li>nil &#x3D; .none(因为可选值遵守ExpressibleByNilLiteral协议，即可用nil表示)</li><li>在必要时，非可选值会自动封装为可选值，不需要手动调用.some(Type)，比如函数的返回类型标记为可选值类型</li></ul></li><li>可选值匹配：<ul><li>匹配值：switch .some(let v)或者swifth let v?</li><li>匹配nil：switch .none或者switch nil</li></ul></li></ul><h2 id="可选值概览"><a href="#可选值概览" class="headerlink" title="可选值概览"></a>可选值概览</h2><ul><li>if let:可选值绑定,略</li><li>while let:当遇到nil时终止</li><li>双重可选值：即Type??，实际就是Optional(Optional(value))<ul><li>case let v? &#x3D; case let .some(v)，仅匹配值</li></ul></li><li>case实际上的匹配功能很强大，比如 case 0..&lt;10 &#x3D; j可以检查j是否在范围内</li><li>if var&#x2F;while var:可变版本，使得我们在if语句中可以修改变量</li><li>在作用域之外使用解包后的值：使用guard let语句，其else路径必须是要求离开当前作用域，如return或者调用一个Never函数</li><li>返回Never（又称为无人类型）的函数向编译器表明自己绝对不会返回，如fatalError或者dispatchMain;又或者对应的值绝对不会出现，比如将泛型指定为Never</li><li>Never实际在Swift中就是个enum<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Never</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li>Never和Void是不同的，Void实际是空元祖()</li><li>总结，不存在是nil，存在且为空Void，绝对不会发生Never</li><li>在OC中，对nil发消息不会发生，在Swift中，使用可选链实现，如v?.callback(),<strong>可选链的调用结果一定是可选值</strong></li><li>对于可选值成员，默认值是nil，这是Swift中对于成员成员初始化的<strong>唯一例外</strong>。注意这个默认行为支队x?的形式有效，如果写成了Optional<T>就无效了，还是必须初始化</li><li>可选链和赋值：可以使用可选链来对可选值进行赋值，如<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> a: <span class="hljs-type">Int</span>?<br>a<span class="hljs-operator">?+=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>注意不能写成，因为可选值绑定对值类型来说是复制<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> a: <span class="hljs-type">Int</span>? <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">var</span> a <span class="hljs-operator">=</span> a &#123;<br>    <span class="hljs-comment">// 无法改变外层的a</span><br>    a<span class="hljs-operator">+=</span><span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>nil合并操作符：??,略，注意??也是短路操作符</li><li>可选值提供了一个map方法，方便我们在不为nil的请款修改进行转换，注意因为是Optional本身提供的方法，所以调用的时候不能加?,eg.arr.first.map{…}（注意，只要是可选值，就可以调用该map方法，不要求可选值是集合类型！！），但是注意，即使如此，<strong>返回的仍然是可选值类型</strong></li><li>flatMap：如果变换本身返回了可选值类型，那么map得到的结果则是双重可选值，为了去掉一层，可以使用flatMap，注意可选值的类型上也是直接定义了flatMap</li><li>compactMap：可以将变换后为nil的可选值给筛掉</li><li>可选值判等：如果可选值封装的类型符合Equatable，则对应的可选值类型也是Equatable的，所以我们可以方便的判等：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> a: <span class="hljs-type">Int</span>? <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>a <span class="hljs-operator">==</span> <span class="hljs-number">0</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>这里work的原因是swift会在必要时将0升级为可选值</li><li>字典中如果直接设置key的value为nil会移除掉key和value，若要插入值nil，可以使用Optional(nil)</li><li>强制解包的使用：一般不要使用，除非预期是在遇到nil时直接crash</li><li>挂起操作的方式：fatalError直接crash、assert在测试版本不符合条件执行并且crash、precondtion和assert一样只不过在正式版也存在</li><li>隐式解包：标记为Type!的类型<ul><li>情景1：oc返回的类型，并且没有标记nullable和nonnull</li><li>情景2：暂时的为空，不如初始化的过程中</li><li>隐式可选值在使用上既可以假定为非可选值不加？，也可以当做可选值加？</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-内建集合类型</title>
    <link href="/2023/12/19/swift-advance-built-in-collection/"/>
    <url>/2023/12/19/swift-advance-built-in-collection/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>虽然在工作中已经大量使用了Swift了，但总感觉自己停留在使用的层面。从今天开始，开始复习Swift Adavance，回忆、理解、总结。</p><p>本章重点介绍了Swift内建的几种集合类型，并讨论如何高效使用。</p><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><ul><li>值语义： Swift中所有的内建集合类型都具有值语义，数组当然也不例外。值语义的典型表现是当其被赋值给一个变量时，将发生复制。</li><li>使用let和var来表示数组是不可变数组or可变数组。注意，即使是可变数组，仍然是值类型。这和NSMutableArray完全不同。</li><li>Swift编译器会对值语义集合进行优化，如果被赋值给对个变量，只有通过变量修改值时才会发生实际的copy，但我们不应依赖该行为。</li><li>数组越界会直接崩溃。</li><li>数组为空时，调用removeLast会崩溃，但popLast则不会崩溃，而是返回nil。</li><li>支持map、flatMap、filter等函数式编程。</li><li>使用.lazy将变形延迟发生到最终需要结果的时候，比如需要将结果转换为数组输出。</li><li>map：遍历元素，对每个元素应用func得到新集合。</li><li>filter: 遍历元素，删除掉符合func的元素得到新集合。</li><li>reduce: 遍历元素，对每个元素应用和之前的结果应用func得到结果值。</li><li>flatMap: 如果得到的结果外层是数组，则去掉结果外层数组。</li><li>forEach: 遍历元素，应用func但不返回结果。注意func中写return并不会使得遍历停止。</li><li>数组可以切片，类似于python，结果是ArraySlice。但是，<strong>切片完之后的索引和原始数组共享索引和内存</strong>！</li></ul><h2 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h2><ul><li>字典查找总是返回可选值，这和Array不同。</li><li>思想：Array中的索引一般总是通过某种方式计算得到的，一般都是有效的，无效的索引一般意味着开发者的计算失误。所以崩溃就好。但是Dict的key一般是其他取到得来的，比如server下发，所以返回可选值比较好。</li><li>删除值：将对应key的value设置为nil或者removeValue(forKey:),该方法返回删除的value,注意，这同时会将key也给删掉。</li><li>更新值：简单，设置即可，或者使用updateValue(_:forKey:),该方法会返回old value。</li><li>合并dict：merge(_:uniquingKeysWith:),第二个参数是决定决策对于相同的key使用如何获取value的函数，注意<strong>是获取value，而不是选择value</strong>，因为不仅可以选择某一个value，也可以对这两个value进行操作得到新的value。</li><li>mapValues: 对dict的values作map</li><li>Dict的key必须符合Hashable协议。<ul><li>标准库中所有基本数据类型都是Hashable的，如Int、String</li><li>数组、集合或可选值，如果其元素时Hashable，则他们也是Hashable</li><li>结构体和enum，如果是由Hashable的类型组成（对结构体来说，要求存储属性，对enum来说，要求关联值，若无关联值，则默认是Hashable的，不需要声明），只要我们声明他们是Hashable，则Swift会帮我们合成Hashable的实现</li><li>对于通过&#x3D;&#x3D;比较相等的两个对象，hash值必须相同，反之，hash值相同，不一定是相同的对象，因为hash值有限，但对象数量无限，可能存在hash冲突的可能。</li><li>所以一般不要使用可变对象作为key，否则如果对象改变造成hash改变，则会造成dict存储找不到或存储错误。</li></ul></li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul><li>嘛，就是集合</li><li>可以使用数组字面量初始化Set，因为Set遵守ExpressibleByArrayLiteral。</li><li>补集：substring</li><li>交集：intersection</li><li>并集：formUnion，这是union的可变版本，即改变原集合，所有以form开头的版本都是可变版本。</li></ul><h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><ul><li>就是区间</li><li>x..&lt;y左闭右开: Range，只有此类型可以表示空集，如5..&lt;5</li><li>x…y闭区间: ClosedRange,只有此类型可以表示最大值，如0…Int.max，因为Range需要上界是比自身包含的范围还得+1</li><li>Range和ClosedRange都有Bound泛型，Bound需要符合Comparable</li><li>x…，左闭右无界: PratialRangeFrom，可遍历，需自己break<ul><li>对于PartialRangeFrom遍历时，会从下界开始，调用adavanced(by:1)</li></ul></li><li>…y，左无界右闭：PartialRangeThrough，不可遍历</li><li>..&lt;y，左无界右开: PartialRangeUpTo，不可遍历</li><li>检测包含：contains、overlaps</li><li>Range可以遍历，但不能完全遍历emm…，支持遍历的<strong>Range的Bound</strong>需要实现Strideable协议。</li><li>Range必须是可数的才能遍历</li><li>Swift之前为了区分可数还是不可数，引入两个类型，即CountableRange和CountableClosedRange</li><li>所有的Range都满足RangeExpression协议<ul><li>contains：判断元素是否包含在范围中</li><li>relative：对给定集合，能够计算出该集合的Range。<strong>若该RangeExpression缺少上界或者下界，则返回的结果中使用给定集合的startIndex或endIndex作为上界或者下界</strong>。</li><li>所以数组可以使用Range进行切片，原理就是数组的subscript实现了接受RangeExpression作为参数，从而结合自身的startIndex和endIndex得到一个Range，从而执行切片</li></ul></li><li>RangeSet: 即Range的集合，在表示多个区间时更加高效</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo添加Live2D看板娘</title>
    <link href="/2023/12/03/hexo-add-live2d/"/>
    <url>/2023/12/03/hexo-add-live2d/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在浏览别人的blog时，有时可以看到一个类似于下面这个萌萌哒的玩意，这其实是通过Live2D Widget插件实现的。方法也很简单，follow me~<br><img src="/../images/image-19.png" alt="Alt text"></p><h2 id="Step1-安装live-2d插件"><a href="#Step1-安装live-2d插件" class="headerlink" title="Step1 安装live 2d插件"></a>Step1 安装live 2d插件</h2><p>注意，下面的指令都是在Hexo项目目录中使用的</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-helper-live2d</span><br></code></pre></td></tr></table></figure><h2 id="Step2-下载live-2d模型"><a href="#Step2-下载live-2d模型" class="headerlink" title="Step2 下载live 2d模型"></a>Step2 下载live 2d模型</h2><p>通过下载不同的live 2d模型，就可以获得不同的看板娘啦，直接npm下载，贼方便</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">// 下载的model会存放在node_modules中</span><br>npm install live2d-widget-<span class="hljs-keyword">model</span>-tororo<br></code></pre></td></tr></table></figure><h2 id="Step3-配置-config-yml"><a href="#Step3-配置-config-yml" class="headerlink" title="Step3 配置_config.yml"></a>Step3 配置_config.yml</h2><p>添加如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Live2D看板娘</span><br><span class="hljs-attr">live2d:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">pluginModelPath:</span> <span class="hljs-string">assets/</span><br>  <span class="hljs-attr">model:</span><br>    <span class="hljs-comment">#模板目录，在node_modules里</span><br>    <span class="hljs-attr">use:</span> <span class="hljs-string">live2d-widget-model-tororo</span><br>  <span class="hljs-attr">display:</span><br>    <span class="hljs-attr">position:</span> <span class="hljs-string">right</span><br>    <span class="hljs-attr">width:</span> <span class="hljs-number">300</span> <br>    <span class="hljs-attr">height:</span> <span class="hljs-number">600</span><br>  <span class="hljs-attr">mobile:</span><br>    <span class="hljs-comment"># 在手机端显示</span><br>    <span class="hljs-attr">show:</span> <span class="hljs-literal">false</span>   <br>  <span class="hljs-attr">rect:</span><br>    <span class="hljs-string">opacity:0.7</span><br></code></pre></td></tr></table></figure><h2 id="Step4-查看效果"><a href="#Step4-查看效果" class="headerlink" title="Step4 查看效果"></a>Step4 查看效果</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">hexo g <span class="hljs-meta">&amp;&amp; hexo s</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何让Hexo被Google索引到</title>
    <link href="/2023/12/03/about-hexo-google-index/"/>
    <url>/2023/12/03/about-hexo-google-index/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们写blog的目的是让自己的分享被别人看到，如果Google没有收录自己的网址，那么就没有意义了。 本篇文章主要介绍如何让咱们的blog被Google收录。</p><h2 id="Step1-检查收录"><a href="#Step1-检查收录" class="headerlink" title="Step1 检查收录"></a>Step1 检查收录</h2><p>首先检查咱们的blog有没有被Google索引，在搜索框输入site:xxx.github.io，不出意外的话，Google没有收录：<br><img src="/../images/image-13.png" alt="Alt text"></p><h2 id="Step2-验证网址所有权"><a href="#Step2-验证网址所有权" class="headerlink" title="Step2 验证网址所有权"></a>Step2 验证网址所有权</h2><p>按照提示，点击进入Google Search Console，Google会要求验证这个网址的归属权，这里由于采用的GitHub Page，所以按照第二种网址前缀的方式进行验证：<br><img src="/../images/image-14.png" alt="Alt text"><br>接下来，会看到有几种验证的方式，因为不想添加一个乱七八糟的html到网站目录中（强迫症犯了QAQ），所以我选择HTML标记的方式。这种方式会要求我们在index.html的head标签中添加一个meta标签，按照提示复制该标签。<br><img src="/../images/image-15.png" alt="Alt text"><br>接下来，找到Hexo项目的public文件夹下的index.html，将这个标签复制到head标签的末尾。<br><img src="/../images/image-16.png" alt="Alt text"><br>顺便说下，Hexo在部署的就是public文件夹下的内容。<br>我们直接发布，<strong>注意不要generate</strong>，因为generate会重新生成index.html，会将咱们之前的修改给覆盖掉。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">// 直接发布即可</span><br>hexo d<br></code></pre></td></tr></table></figure><p>发布完成之后，稍等1min左右，等待GitHub Page部署完成，点击验证按钮。Congratulations，验证完成~~~<br><img src="/../images/image-17.png" alt="Alt text"></p><h2 id="Step3-添加sitemap-xml"><a href="#Step3-添加sitemap-xml" class="headerlink" title="Step3 添加sitemap.xml"></a>Step3 添加sitemap.xml</h2><p>到上面其实Google已经允许收录咱们的blog了，但是为了Google的蜘蛛机器人更好的爬取到网站的内容，我们可以在网站根目录下放一个sitemap.xml。<br>进入到Hexo项目目录中，安装插件：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-generator-sitemap <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>安装完毕之后，打开_config.yml，添加如下内容</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"># automatically <span class="hljs-keyword">generate</span> sitemap<br>sitemap:<br>  path: sitemap<span class="hljs-variable">.xml</span><br></code></pre></td></tr></table></figure><p>重新生成部署，不再啰嗦啦，hexo g -d一把梭。<br>等待1min。进入到Google Search Console，提交我们的sitemap.xml，如下图，OK收工。<br>但我们这个时候再搜索还是搜不到的，需要等个几天，到时候再来更新~<br><img src="/../images/image-18.png" alt="Alt text"></p><hr><p>12月9日更新，已经可以被索引到了~<br><img src="/../images/image-20.png" alt="Alt text"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Hexo中图片路径问题</title>
    <link href="/2023/12/03/about-hexo-picture-path/"/>
    <url>/2023/12/03/about-hexo-picture-path/</url>
    
    <content type="html"><![CDATA[<p>在编写Hexo时，通常需要粘贴图片到markdown中。默认粘贴的path和咱们的md文件同级别，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![Alt text](image-9.png)</span><br></pre></td></tr></table></figure><p>虽然本地预览没有问题，但是在generate的时候，存在两个问题：<br>1.Hexo会忽略_post下的图片资源<br>2.Hexo会将md文件中的path转换为域名&#x2F;path，例如<a href="http://xxx.github.io/xxx.png">http://xxx.github.io/xxx.png</a><br>这两个问题都会导致无法正常看到我们blog中的图片。  </p><p>问题解决：<br>1.在source下新建images文件夹，专门用来存放图片<br>2.Hexo中使用images&#x2F;xxx.png来引用该图片</p><p>那么还是有问题，在使用VS Code粘贴图片时，还是默认粘贴到_posts下面，这样每次都要移动图片和修改路径，很麻烦。没错，贴心的VS Code可以自定义粘贴的路径，使用cmd+,打开设置，找到如下界面设置默认的粘贴路径：<br><img src="/../images/image-10.png" alt="Alt text"><br>完成！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo的安装与部署</title>
    <link href="/2023/12/03/hexo-install-and-deploy/"/>
    <url>/2023/12/03/hexo-install-and-deploy/</url>
    
    <content type="html"><![CDATA[<p>一时间还没想好要写哪些东西，万事开头难嘛，既然这样，咱就先记录下烂大街的Hexo安装与部署吧。</p><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>我们可以将我们的blog理解成一个app，Hexo项目就是这个app的框架工程源码，通过Node.js进行编译打包，最终生成产品发布到GitHub上被人查看使用。</p><h1 id="安装Git-注册GitHub账号"><a href="#安装Git-注册GitHub账号" class="headerlink" title="安装Git&amp;注册GitHub账号"></a>安装Git&amp;注册GitHub账号</h1><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>传送门：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a><br>作用：用于管理Hexo生成的文件，对接GitHub</p><h2 id="注册GitHub账号"><a href="#注册GitHub账号" class="headerlink" title="注册GitHub账号"></a>注册GitHub账号</h2><p>传送门：<a href="https://github.com/">https://github.com/</a><br>作用：托管Hexo生成的文件，并提供GitHub Page服务，让blog可以被别人浏览  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 校验安装</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure><h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><p>传送门：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a><br>Node.js是一个跨平台的基于Chrome V8引擎的JavaScript运行环境，它可以让JS脚本可以脱离浏览器执行。这么说如果还是不太理解的话，把他理解成Python就可以<br>为啥需要Node.js呢，有两个原因：</p><ul><li>Hexo是基于Node.js作为构建系统来生成网页</li><li>Hexo可以使用npm来下载安装</li><li>等等，这里npm又是啥？别慌，npm是Node.js的包管理器，理解成pip之于Python。最近的Node.js在安装的时候已经会一起安装npm了</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 校验安装</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><h1 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h1><p>使用npm进行安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// -g参数表示将hexo-cli作为全局(global)包安装，hexo-cli中的二进制文件加入到PATH中，方便终端调用hexo命令</span><br><span class="line">// 全局安装还可以使得在创建其他Node.js项目的时候也方便引用到</span><br><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h1 id="创建Hexo项目"><a href="#创建Hexo项目" class="headerlink" title="创建Hexo项目"></a>创建Hexo项目</h1><p>1.在你喜欢的地方创建一个文件夹，例如桌面上，就叫做hexo_blog吧<br>2.cd到该目录<br>3.执行命令，创建Hexo项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 创建Hexo项目</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>4.执行命令，在本地生成网页产物</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 生成网页产物</span><br><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>5.执行命令，启动本地服务器查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 启动本地server</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>6.在浏览器中打开 <a href="http://localhost:4000/">http://localhost:4000/</a> 查看效果<br>不出意外的话，恭喜，已经曙光初现了，接下来就是将我们的blog发布到GitHub Page上供别人浏览了</p><h1 id="部署到GitHub-Page"><a href="#部署到GitHub-Page" class="headerlink" title="部署到GitHub Page"></a>部署到GitHub Page</h1><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>之前我们创建了GitHub账号，我们新建一个仓库<br><img src="/../images/image.png" alt="Alt text"><br><img src="/../images/image-1.png" alt="Alt text"></p><h2 id="配置SSH密钥"><a href="#配置SSH密钥" class="headerlink" title="配置SSH密钥"></a>配置SSH密钥</h2><p>等等，啥是SSH，啥是密钥？我们要把本地的Hexo产物文件push到GitHub，是通过ssh的方式。那GitHub肯定需要鉴权把。鉴权我们可以使用账号密码，但是如果每次push都要输入账号密码，那想想都很痛苦。<br>那有没有更加轻松的方式呢？GitHub很贴心的为你想好啦，我们只要把我们的设备添加到GitHub的信任名单中，那就不用每次都输入账号密码了，so easy!<br>那么，GitHub是怎么信任咱们的设备呢，它需要一个凭证，这个凭证就是SSH密钥。通过SSH密钥能够唯一标识请求来自于这台设备。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 生成ssh密钥，引号中的内容是注释，可以写我们自己的邮箱账号</span><br><span class="line">// 一路回车即可，记录下保存密钥的文件，例如~/.ssh/id_rsa，对应的公钥就是~/.ssh/id_rsa.pub</span><br><span class="line">ssh-keygen -t rsa -C &quot;your email@example.com&quot;</span><br></pre></td></tr></table></figure><p>查看公钥并复制到剪切板中，然后按找到下面的位置将公钥粘贴进去<br><img src="/../images/image-2.png" alt="Alt text"><br><img src="/../images/image-3.png" alt="Alt text"><br><img src="/../images/image-4.png" alt="Alt text"><br><img src="/../images/image-5.png" alt="Alt text"><br>测试下添加是否成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 当出现提示时回车即可</span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><h2 id="配置Git个人信息"><a href="#配置Git个人信息" class="headerlink" title="配置Git个人信息"></a>配置Git个人信息</h2><p>上面的ssh密钥只是前提条件，GitHub在我们push文件时还会根据邮箱和用户名做校验，因而需要设置下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;此处填你的用户名&quot;</span><br><span class="line">git config --global user.email &quot;此处填你的邮箱&quot;</span><br></pre></td></tr></table></figure><h2 id="将Hexo部署到GitHub-Page"><a href="#将Hexo部署到GitHub-Page" class="headerlink" title="将Hexo部署到GitHub Page"></a>将Hexo部署到GitHub Page</h2><p>首先，回到我们之前在GitHub上创建的仓库，复制我们仓库的ssh地址<br><img src="/../images/image-6.png" alt="Alt text"><br>打开我们创建的Hexo项目中的_config.yml文件(推荐Visual Studio Code，后续写blog也很方便)，找到如下入位置进行修改<br><img src="/../images/image-12.png" alt="Alt text"><br><img src="/../images/image-11.png" alt="Alt text"></p><p><strong>敲黑板！！注意branch不要填入master，要填入main。</strong> 分支填错会就看不到了页面了，GitHub Page使用默认分支部署。不知道啥时候开始，GitHub为了zzzq把默认分支的名称从master修改为main了QAQ  </p><p>我们还需要安装一个hexo部署到git的插件来完成最终部署，进入到我们之前创建的Hexo项目目录中，执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这里--save是将该插件添加到Hexo项目的依赖中，记录到package.json</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>最后一步，激动人心的时刻就要到了，执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>完成之后，访问user_name.github.io（user_name替换成你自己的GitHub账号名称），我们就可以看到我们的blog啦，完结撒花~~~~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第一篇正式的blog</title>
    <link href="/2023/12/03/first_blog/"/>
    <url>/2023/12/03/first_blog/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到我的blog，从今天起，开始正式坚持写blog，记录下工作生活中遇到的一些问题，同时也希望分享一些有价值的经验。<br>作为一个曾经幻想着推动人类文明进步的孩子，到现在休息日只想躺着的废柴，终究还是被现实磨平了棱角。<br>那至少，希望用技术创造一些有价值的东西吧。<br>emmm，虽然也很难就是了，但梦想还是要有的嘛，万一呢</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/12/03/hello-world/"/>
    <url>/2023/12/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
