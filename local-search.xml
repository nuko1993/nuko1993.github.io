<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深入理解GCD-Dispatch Queue</title>
    <link href="/2024/02/21/think-deep-in-gcd-dispatch-queue/"/>
    <url>/2024/02/21/think-deep-in-gcd-dispatch-queue/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前在OC高级中，已经对GCD有了了解，这里通过深入libdispatch的源码进行理解，源码传送门：<a href="https://github.com/apple-oss-distributions/libdispatch/tags">https://github.com/apple-oss-distributions/libdispatch/tags</a></p><h2 id="queue和线程之间的关系"><a href="#queue和线程之间的关系" class="headerlink" title="queue和线程之间的关系"></a>queue和线程之间的关系</h2><ul><li>之前我们知道，queue负责存放任务，queue中任务的具体执行最终需要线程执行</li><li>不同的queue中的任务可以放到同一个线程上，每个线程在执行queue中任务时会记录当前正在执行的是哪个queue的任务</li><li>并发queue可以同时将多个任务放在多个线程上执行，串行queue只能每次在单个线程上执行一个任务</li><li>一个queue可以设置另一个queue为自己的目标queue，即将自己整体作为任务以另一个queue的策略执行，比如一个<code>并发queue设置一个串行queue作为目标，那么并发queue中的所有任务也都变成了串行</code><br>一张图可以解释：<br><img src="/../images/image-43.png" alt="Alt text"><br>可以看到，queue和线程并非一对一关系，一个线程可以执行多个queue的任务（但同一时间肯定是只能执行一个queue的任务，所以有线程的当前queue的概念）。queue可以串行也可以是并行。</li><li>但是对于main queue优点特殊，main queue的任务只能在主线程上执行；反之则不然，主线程也能执行非main queue的任务，如下代码：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">// 测试代码</span><br><span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() &#123;<br>    <span class="hljs-keyword">super</span>.viewDidLoad()<br>    <br>    <span class="hljs-keyword">let</span> sQueue <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>(label: <span class="hljs-string">&quot;sQueue&quot;</span>)<br>    <span class="hljs-comment">// 串行队列同步不会产生新线程，任务在当前线程下执行，因此Thread.current必然是主线程</span><br>    sQueue.sync &#123; <span class="hljs-built_in">print</span>(<span class="hljs-type">Thread</span>.current) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><code>注意是同步执行时不会产生新线程，如果是异步执行，仍然会产生新线程</code></li></ul><h2 id="queue的定义"><a href="#queue的定义" class="headerlink" title="queue的定义"></a>queue的定义</h2><h3 id="dispatch-queue-s"><a href="#dispatch-queue-s" class="headerlink" title="dispatch_queue_s"></a>dispatch_queue_s</h3><p>在源码中，通过dispatch_queue_s来定义queue，为了方便后续分析，先列出一些函数方便理解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_s</span> &#123;<br>    <span class="hljs-comment">// 第一部分：DISPATCH_STRUCT_HEADER(dispatch_queue_s, dispatch_queue_vtable_s)</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_vtable_s</span> *do_vtable; <span class="hljs-comment">// 该类型的结构体包含了对dispatch_queue_s的操作函数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_s</span> *<span class="hljs-keyword">volatile</span> do_next; <span class="hljs-comment">//链表的next</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> do_ref_cnt; <span class="hljs-comment">// 引用计数</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> do_xref_cnt; <span class="hljs-comment">// 外部引用计数</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> do_suspend_cnt; <span class="hljs-comment">// 暂停标志，比如延时处理中，在任务到时后，计时器处理将会将该标志位修改，然后唤醒队列调度</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_s</span> *do_targetq; <span class="hljs-comment">// 目标队列，GCD允许我们将一个队列放在另一个队列里执行任务</span><br><span class="hljs-type">void</span> *do_ctxt; <span class="hljs-comment">// 上下文，用来存储线程池相关数据，比如用于线程挂起和唤醒的信号量、线程池尺寸等</span><br><span class="hljs-type">void</span> *do_finalizer;<br><br>    <span class="hljs-comment">// 第二部分：DISPATCH_QUEUE_HEADER</span><br>    <span class="hljs-type">uint32_t</span> <span class="hljs-keyword">volatile</span> dq_running; <span class="hljs-comment">// 队列运行的任务数量</span><br>    <span class="hljs-type">uint32_t</span> dq_width; <span class="hljs-comment">// 最大并发数：主队列/串行队列的最大并发数为1</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_object_s</span> *<span class="hljs-keyword">volatile</span> dq_items_tail; <span class="hljs-comment">// 队列尾结点</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_object_s</span> *<span class="hljs-keyword">volatile</span> dq_items_head; <span class="hljs-comment">// 队列头结点</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> dq_serialnum; <span class="hljs-comment">// 队列序列号</span><br>    <span class="hljs-type">dispatch_queue_t</span> dq_specific_q; <span class="hljs-comment">// specific队列</span><br><br>    <span class="hljs-type">char</span> dq_label[DISPATCH_QUEUE_MIN_LABEL_SIZE]; <span class="hljs-comment">// 队列名，队列名要少于64个字符    </span><br>    <span class="hljs-type">char</span> _dq_pad[DISPATCH_QUEUE_CACHELINE_PAD]; <span class="hljs-comment">// for static queues only</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="dispatch-queue-vtable-s"><a href="#dispatch-queue-vtable-s" class="headerlink" title="dispatch_queue_vtable_s"></a>dispatch_queue_vtable_s</h3><p>在上面我们可以看到，dispatch_queue_s中包含了dispatch_queue_vtable_s，该结构体包含了针对dispatch_queue_s的操作函数，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// dispatch_queue_vtable_s结构体，声明了一些函数用于操作dispatch_queue_s结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_vtable_s</span> &#123;<br><span class="hljs-comment">// DISPATCH_VTABLE_HEADER(dispatch_queue_s);</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">const</span> do_type;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-type">const</span> do_kind;<br><span class="hljs-built_in">size_t</span> (*<span class="hljs-type">const</span> do_debug)(<span class="hljs-keyword">struct</span> dispatch_queue_s *, <span class="hljs-type">char</span> *, <span class="hljs-type">size_t</span>);<br><span class="hljs-comment">// 唤醒队列的方法，全局队列和主队列此项为NULL</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_s</span> *(*<span class="hljs-type">const</span> do_invoke)(<span class="hljs-keyword">struct</span> dispatch_queue_s); <br><span class="hljs-comment">// 用于检测传入对象中的一些值是否满足条件</span><br><span class="hljs-built_in">bool</span> (*<span class="hljs-type">const</span> do_probe)(<span class="hljs-keyword">struct</span> dispatch_queue_s *);<br><span class="hljs-comment">// 销毁队列的方法，通常内部会调用这个对象的finalizer函数</span><br><span class="hljs-built_in">void</span> (*<span class="hljs-type">const</span> do_dispose)(<span class="hljs-keyword">struct</span> dispatch_queue_s *)<br>&#125;;<br></code></pre></td></tr></table></figure><p>在queue.c中定义了三个预定义的dispatch_queue_vtable_s，分别用于main queue&amp;自定义queue、global queue和manager queue</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 用于主队列和自定义队列</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_vtable_s</span> _dispatch_queue_vtable = &#123;<br>.do_type = DISPATCH_QUEUE_TYPE,<br>.do_kind = <span class="hljs-string">&quot;queue&quot;</span>,<br>.do_dispose = _dispatch_queue_dispose,<br>.do_invoke = <span class="hljs-literal">NULL</span>,<br>.do_probe = (<span class="hljs-type">void</span> *)dummy_function_r0,<br>.do_debug = dispatch_queue_debug,<br>&#125;;<br><br><span class="hljs-comment">// 用于全局队列</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_vtable_s</span> _dispatch_queue_root_vtable = &#123;<br>.do_type = DISPATCH_QUEUE_GLOBAL_TYPE,<br>.do_kind = <span class="hljs-string">&quot;global-queue&quot;</span>,<br>.do_debug = dispatch_queue_debug,<br>.do_probe = _dispatch_queue_wakeup_global,<br>&#125;;<br><br><span class="hljs-comment">// 用于管理队列</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_vtable_s</span> _dispatch_queue_mgr_vtable = &#123;<br>.do_type = DISPATCH_QUEUE_MGR_TYPE,<br>.do_kind = <span class="hljs-string">&quot;mgr-queue&quot;</span>,<br>.do_invoke = _dispatch_mgr_thread,<br>.do_debug = dispatch_queue_debug,<br>.do_probe = _dispatch_mgr_wakeup,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="queue的类型"><a href="#queue的类型" class="headerlink" title="queue的类型"></a>queue的类型</h2><p>queue可以分为main queue、自定义queue、global queue和manager queue</p><h3 id="main-queue"><a href="#main-queue" class="headerlink" title="main queue"></a>main queue</h3><p>我们最为熟悉，通过dispatch_get_main_queue即可获取，其内部定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> dispatch_get_main_queue() (&amp;_dispatch_main_q)</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_s</span> _dispatch_main_q = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !DISPATCH_USE_RESOLVERS</span><br>.do_vtable = &amp;_dispatch_queue_vtable,<br>.do_targetq = &amp;_dispatch_root_queues[<br>DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY], <span class="hljs-comment">// root queue中的其中一个</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>.dq_label = <span class="hljs-string">&quot;com.apple.main-thread&quot;</span>,<br>.dq_running = <span class="hljs-number">1</span>,<br>.dq_width = <span class="hljs-number">1</span>, <span class="hljs-comment">// 说明主队列是一个串行队列</span><br>.dq_serialnum = <span class="hljs-number">1</span>, <span class="hljs-comment">// 主队列序列号</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>main queue的成员说明如下：<ul><li>do_vtable之前已经看到了，是预定义的_dispatch_queue_vtable</li><li>do_targetq，也是一个预定义的queue，其定义如下：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY] = &#123;<br>        .do_vtable = &amp;_dispatch_queue_root_vtable,<br>        .do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>        .do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>        .do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>        .do_ctxt = &amp;_dispatch_root_queue_contexts[<br>                DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY],<br>        .dq_label = <span class="hljs-string">&quot;com.apple.root.default-overcommit-priority&quot;</span>,<br>        .dq_running = <span class="hljs-number">2</span>,<br>        .dq_width = UINT32_MAX,<br>        .dq_serialnum = <span class="hljs-number">7</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li><li>do_ref_cnt、do_xref_cnt,引用计数，和GCD的对象内存管理相关（GCD内部有自己的引用计数规则，不采用ARC），下面是它的引用计数方法：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dispatch_retain</span><span class="hljs-params">(<span class="hljs-type">dispatch_object_t</span> dou)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dou._do-&gt;do_xref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT)) &#123;<br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// global object</span><br>&#125;<br><span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-type">void</span> _dispatch_retain(<span class="hljs-type">dispatch_object_t</span> dou) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dou._do-&gt;do_ref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT)) &#123;<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// global object</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dispatch_release</span><span class="hljs-params">(<span class="hljs-type">dispatch_object_t</span> dou)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dou._do-&gt;do_xref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 调用_dispatch_release函数;</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-type">void</span> _dispatch_release(<span class="hljs-type">dispatch_object_t</span> dou) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dou._do-&gt;do_ref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT)) &#123;<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// global object</span><br>    &#125;<br>    <span class="hljs-comment">// 调用dx_dispose宏即调用do_dispose</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>  从上述代码可以看出：1.由于main queue的ref cnt是DISPATCH_OBJECT_GLOBAL_REFCNT，因而main queue的生命周期是整个进程 2.当ref cnt为0时，GCD中的对象才会释放</li></ul></li></ul><h3 id="manager-queue"><a href="#manager-queue" class="headerlink" title="manager queue"></a>manager queue</h3><p>manager queue是只在GCD内部使用的queue，不对外公开。用于GCD内部的管理角色，比如GCD定时器就用到了它，其内部定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_s</span> _dispatch_mgr_q = &#123;<br>.do_vtable = &amp;_dispatch_queue_mgr_vtable,<br>.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>.do_targetq = &amp;_dispatch_root_queues[<br>DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY],<br>.dq_label = <span class="hljs-string">&quot;com.apple.libdispatch-manager&quot;</span>,<br>.dq_width = <span class="hljs-number">1</span>,<br>.dq_serialnum = <span class="hljs-number">2</span>, <span class="hljs-comment">// 管理队列序列号</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>manager queue的成员说明如下<ul><li>do_vtable：就是前面定义的_dispatch_queue_mgr_vtable</li><li>do_targetq：也是一个内部预定义的queue，如下：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">  [DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY] = &#123;<br>.do_vtable = &amp;_dispatch_queue_root_vtable,<br>.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY],<br>.dq_label = <span class="hljs-string">&quot;com.apple.root.high-overcommit-priority&quot;</span>,<br>.dq_running = <span class="hljs-number">2</span>,<br>.dq_width = UINT32_MAX,<br>.dq_serialnum = <span class="hljs-number">9</span>,<br>  &#125;<br></code></pre></td></tr></table></figure></li><li>do_ref_cnt、do_xref_cnt:和main queue相同，也是DISPATCH_OBJECT_GLOBAL_REFCNT，因而生命周期也是整个进程</li></ul></li></ul><h3 id="自定义queue"><a href="#自定义queue" class="headerlink" title="自定义queue"></a>自定义queue</h3><p>通过dispatch_queue_create创建出来的queue就属于自定义queue，其源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">dispatch_queue_t</span> <span class="hljs-title">dispatch_queue_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *label, <span class="hljs-type">dispatch_queue_attr_t</span> attr)</span> </span>&#123;<br><span class="hljs-type">dispatch_queue_t</span> dq;<br><span class="hljs-type">size_t</span> label_len;<br><br><span class="hljs-keyword">if</span> (!label) &#123;<br>label = <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><br>label_len = <span class="hljs-built_in">strlen</span>(label);<br><span class="hljs-keyword">if</span> (label_len &lt; (DISPATCH_QUEUE_MIN_LABEL_SIZE - <span class="hljs-number">1</span>)) &#123;<br>label_len = (DISPATCH_QUEUE_MIN_LABEL_SIZE - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// XXX switch to malloc()</span><br>dq = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1ul</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> dispatch_queue_s) -<br>DISPATCH_QUEUE_MIN_LABEL_SIZE - DISPATCH_QUEUE_CACHELINE_PAD +<br>label_len + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(!dq)) &#123;<br><span class="hljs-keyword">return</span> dq;<br>&#125;<br><br><span class="hljs-comment">// _dispatch_queue_init(dq);</span><br><span class="hljs-comment">// 队列初始化展开如下</span><br>dq-&gt;do_vtable = &amp;_dispatch_queue_vtable;<br>dq-&gt;do_next = DISPATCH_OBJECT_LISTLESS;<br>dq-&gt;do_ref_cnt = <span class="hljs-number">1</span>;<br>dq-&gt;do_xref_cnt = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// Default target queue is overcommit!</span><br><span class="hljs-comment">// 使用的目标队列：_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY]</span><br>dq-&gt;do_targetq = _dispatch_get_root_queue(<span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>dq-&gt;dq_running = <span class="hljs-number">0</span>;<br>dq-&gt;dq_width = <span class="hljs-number">1</span>;<br>dq-&gt;dq_serialnum = <span class="hljs-built_in">dispatch_atomic_inc</span>(&amp;_dispatch_queue_serial_numbers) - <span class="hljs-number">1</span>;<br><br><span class="hljs-built_in">strcpy</span>(dq-&gt;dq_label, label);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fastpath</span>(!attr)) &#123;<br><span class="hljs-keyword">return</span> dq;<br>&#125;<br><span class="hljs-comment">// 如果是并发队列，设置最大并发数，UINT32_MAX可以看成不限制最大并发数</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fastpath</span>(attr == DISPATCH_QUEUE_CONCURRENT)) &#123;<br>dq-&gt;dq_width = UINT32_MAX;<br><span class="hljs-comment">// 设置目标队列，对于并发队列_dispatch_get_root_queue函数中的overcommit传的是false，获取的值： _dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY]</span><br>dq-&gt;do_targetq = _dispatch_get_root_queue(<span class="hljs-number">0</span>, <span class="hljs-literal">false</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">dispatch_debug_assert</span>(!attr, <span class="hljs-string">&quot;Invalid attribute&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> dq;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于slowpath和fastpath，实际是为了编译器优化，提高执行效率，slowpath表示该分支较少发生，fastpath表示该分支较大可能发生</p><ul><li><p>关于自定义queue的成员：</p><ul><li>do_vtable，和main queue相同，前面已经介绍了</li><li>do_targetq分为两种：<ul><li>自定义串行queue：通过dispatch_get_root_queue(0, true)获取，获取到的是_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY]</li><li>自定义并发queue：通过_dispatch_get_root_queue(0, false)获取，获取到的是_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY]</li><li>可以看到，true&#x2F;false代表是否要针对该queue创建新的线程，若是true，表示需要，否则不需要</li></ul></li><li>dq_serialnum是在_dispatch_queue_serial_numbers的基础上原子自增，从12开始，1到11是被内部保留的，如下：</li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// skip zero</span><br><span class="hljs-comment">// 1 - main_q</span><br><span class="hljs-comment">// 2 - mgr_q</span><br><span class="hljs-comment">// 3 - _unused_</span><br><span class="hljs-comment">// 4,5,6,7,8,9,10,11 - global queues</span><br><span class="hljs-comment">// we use &#x27;xadd&#x27; on Intel, so the initial value == next assigned</span><br></code></pre></td></tr></table></figure><p>  1是main queue，2是manager queue，3暂时未使用，4-11是global queue</p></li></ul><h3 id="global-queue"><a href="#global-queue" class="headerlink" title="global queue"></a>global queue</h3><p>我们使用dispatch_get_global_queue来获取，其源码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">dispatch_queue_t</span> <span class="hljs-title">dispatch_get_global_queue</span><span class="hljs-params">(<span class="hljs-type">long</span> priority, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (flags &amp; ~DISPATCH_QUEUE_OVERCOMMIT) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">return</span> _dispatch_get_root_queue(priority, flags &amp; DISPATCH_QUEUE_OVERCOMMIT);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">dispatch_queue_t</span> _dispatch_get_root_queue(<span class="hljs-type">long</span> priority, <span class="hljs-type">bool</span> overcommit) &#123;<br><span class="hljs-keyword">if</span> (overcommit) <span class="hljs-keyword">switch</span> (priority) &#123;<br><span class="hljs-keyword">case</span> DISPATCH_QUEUE_PRIORITY_LOW:<br><span class="hljs-keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY];<br><span class="hljs-keyword">case</span> DISPATCH_QUEUE_PRIORITY_DEFAULT:<br><span class="hljs-keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY];<br><span class="hljs-keyword">case</span> DISPATCH_QUEUE_PRIORITY_HIGH:<br><span class="hljs-keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY];<br><span class="hljs-keyword">case</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND:<br><span class="hljs-keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY];<br>&#125;<br><br><span class="hljs-keyword">switch</span> (priority) &#123;<br><span class="hljs-keyword">case</span> DISPATCH_QUEUE_PRIORITY_LOW:<br><span class="hljs-keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY];<br><span class="hljs-keyword">case</span> DISPATCH_QUEUE_PRIORITY_DEFAULT:<br><span class="hljs-keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY];<br><span class="hljs-keyword">case</span> DISPATCH_QUEUE_PRIORITY_HIGH:<br><span class="hljs-keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY];<br><span class="hljs-keyword">case</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND:<br><span class="hljs-keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY];<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_s</span> _dispatch_root_queues[] = &#123;<br>[DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY] = &#123;<br>.do_vtable = &amp;_dispatch_queue_root_vtable,<br>.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY],<br><br>.dq_label = <span class="hljs-string">&quot;com.apple.root.low-priority&quot;</span>,<br>.dq_running = <span class="hljs-number">2</span>,<br>.dq_width = UINT32_MAX,<br>.dq_serialnum = <span class="hljs-number">4</span>,<br>&#125;,<br>[DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY] = &#123;<br>.do_vtable = &amp;_dispatch_queue_root_vtable,<br>.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY],<br><br>.dq_label = <span class="hljs-string">&quot;com.apple.root.low-overcommit-priority&quot;</span>,<br>.dq_running = <span class="hljs-number">2</span>,<br>.dq_width = UINT32_MAX,<br>.dq_serialnum = <span class="hljs-number">5</span>,<br>&#125;,<br>[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY] = &#123;<br>.do_vtable = &amp;_dispatch_queue_root_vtable,<br>.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY],<br><br>.dq_label = <span class="hljs-string">&quot;com.apple.root.default-priority&quot;</span>,<br>.dq_running = <span class="hljs-number">2</span>,<br>.dq_width = UINT32_MAX,<br>.dq_serialnum = <span class="hljs-number">6</span>,<br>&#125;,<br>[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY] = &#123;<br>.do_vtable = &amp;_dispatch_queue_root_vtable,<br>.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY],<br><br>.dq_label = <span class="hljs-string">&quot;com.apple.root.default-overcommit-priority&quot;</span>,<br>.dq_running = <span class="hljs-number">2</span>,<br>.dq_width = UINT32_MAX,<br>.dq_serialnum = <span class="hljs-number">7</span>,<br>&#125;,<br>[DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY] = &#123;<br>.do_vtable = &amp;_dispatch_queue_root_vtable,<br>.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY],<br><br>.dq_label = <span class="hljs-string">&quot;com.apple.root.high-priority&quot;</span>,<br>.dq_running = <span class="hljs-number">2</span>,<br>.dq_width = UINT32_MAX,<br>.dq_serialnum = <span class="hljs-number">8</span>,<br>&#125;,<br>[DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY] = &#123;<br>.do_vtable = &amp;_dispatch_queue_root_vtable,<br>.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY],<br><br>.dq_label = <span class="hljs-string">&quot;com.apple.root.high-overcommit-priority&quot;</span>,<br>.dq_running = <span class="hljs-number">2</span>,<br>.dq_width = UINT32_MAX,<br>.dq_serialnum = <span class="hljs-number">9</span>,<br>&#125;,<br>[DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY] = &#123;<br>.do_vtable = &amp;_dispatch_queue_root_vtable,<br>.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY],<br><br>.dq_label = <span class="hljs-string">&quot;com.apple.root.background-priority&quot;</span>,<br>.dq_running = <span class="hljs-number">2</span>,<br>.dq_width = UINT32_MAX,<br>.dq_serialnum = <span class="hljs-number">10</span>,<br>&#125;,<br>[DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY] = &#123;<br>.do_vtable = &amp;_dispatch_queue_root_vtable,<br>.do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,<br>.do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,<br>.do_ctxt = &amp;_dispatch_root_queue_contexts[<br>DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY],<br><br>.dq_label = <span class="hljs-string">&quot;com.apple.root.background-overcommit-priority&quot;</span>,<br>.dq_running = <span class="hljs-number">2</span>,<br>.dq_width = UINT32_MAX,<br>.dq_serialnum = <span class="hljs-number">11</span>,<br>&#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>global queue的成员<ul><li><p>do_vtable是_dispatch_queue_root_vtable，在该vtable中，检测函数do_probe是_dispatch_queue_wakeup_global，用于唤醒global queue</p></li><li><p>do_targetq：之前我们看到，main queue、自定义queue和manager queue都使用预定义的queue作为target，但是global queue并没有，为啥没有呢，因为global queue获取到的就是root queue之一，root queue就不用再找target了，他们只能是其他queue的target</p></li><li><p>do_ref_cnt、do_xref_cnt：和main queue相同，所以也跟着整个进程</p></li><li><p>do_ctxt: 上下文，用于存储线程池相关数据，比如用于线程挂起和唤醒的信号量，其内部预定义：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_root_queue_context_s</span> _dispatch_root_queue_contexts[] = &#123;<br>    [DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>        .dgq_thread_mediator = &amp;_dispatch_thread_mediator[<br>                DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY],<br>        .dgq_thread_pool_size = MAX_THREAD_COUNT,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;,<br>    [DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>        .dgq_thread_mediator = &amp;_dispatch_thread_mediator[<br>                DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY],<br>        .dgq_thread_pool_size = MAX_THREAD_COUNT,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;,<br>    [DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>        .dgq_thread_mediator = &amp;_dispatch_thread_mediator[<br>                DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY],<br>        .dgq_thread_pool_size = MAX_THREAD_COUNT,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;,<br>    [DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>        .dgq_thread_mediator = &amp;_dispatch_thread_mediator[<br>                DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY],<br>        .dgq_thread_pool_size = MAX_THREAD_COUNT,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;,<br>    [DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>        .dgq_thread_mediator = &amp;_dispatch_thread_mediator[<br>                DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY],<br>        .dgq_thread_pool_size = MAX_THREAD_COUNT,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;,<br>    [DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>        .dgq_thread_mediator = &amp;_dispatch_thread_mediator[<br>                DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY],<br>        .dgq_thread_pool_size = MAX_THREAD_COUNT,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;,<br>    [DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>        .dgq_thread_mediator = &amp;_dispatch_thread_mediator[<br>                DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY],<br>        .dgq_thread_pool_size = MAX_THREAD_COUNT,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;,<br>    [DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY] = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br>        .dgq_thread_mediator = &amp;_dispatch_thread_mediator[<br>                DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY],<br>        .dgq_thread_pool_size = MAX_THREAD_COUNT,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="queue中代码的同步执行：dispatch-sync"><a href="#queue中代码的同步执行：dispatch-sync" class="headerlink" title="queue中代码的同步执行：dispatch_sync"></a>queue中代码的同步执行：dispatch_sync</h2><p>首先明确，同步执行，即需要等待queue中代码执行完毕才能接着向下执行。<br>测试代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">// 串行队列</span><br><span class="hljs-keyword">let</span> sQueue <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>(label: <span class="hljs-string">&quot;sQueue&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>)<br>sQueue.sync &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-number">2</span>)</span>：<span class="hljs-subst">\(Thread.current)</span>&quot;</span>) &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-number">3</span>)<br>sQueue.sync &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-number">4</span>)</span>：<span class="hljs-subst">\(Thread.current)</span>&quot;</span>) &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-number">5</span>)<br><br><span class="hljs-comment">// 并行队列</span><br><span class="hljs-keyword">let</span> cQueue <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>(label: <span class="hljs-string">&quot;cQueue&quot;</span>, attributes: [.concurrent])<br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>)<br>cQueue.sync &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-number">2</span>)</span>：<span class="hljs-subst">\(Thread.current)</span>&quot;</span>) &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-number">3</span>)<br>cQueue.sync &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-number">4</span>)</span>：<span class="hljs-subst">\(Thread.current)</span>&quot;</span>) &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-number">1</span><br><span class="hljs-number">2</span>：<span class="hljs-operator">&lt;</span><span class="hljs-type">NSThread</span>: <span class="hljs-number">0x600002478980</span><span class="hljs-operator">&gt;</span>&#123;number <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, name <span class="hljs-operator">=</span> main&#125;<br><span class="hljs-number">3</span><br><span class="hljs-number">4</span>：<span class="hljs-operator">&lt;</span><span class="hljs-type">NSThread</span>: <span class="hljs-number">0x600002478980</span><span class="hljs-operator">&gt;</span>&#123;number <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, name <span class="hljs-operator">=</span> main&#125;<br><span class="hljs-number">5</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span>：<span class="hljs-operator">&lt;</span><span class="hljs-type">NSThread</span>: <span class="hljs-number">0x600002478980</span><span class="hljs-operator">&gt;</span>&#123;number <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, name <span class="hljs-operator">=</span> main&#125;<br><span class="hljs-number">3</span><br><span class="hljs-number">4</span>：<span class="hljs-operator">&lt;</span><span class="hljs-type">NSThread</span>: <span class="hljs-number">0x600002478980</span><span class="hljs-operator">&gt;</span>&#123;number <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, name <span class="hljs-operator">=</span> main&#125;<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>可见，<code>不管是串行queue和并发queue，只要是sync，都是在当前线程执行，不会使用新线程</code>，且会阻塞当前执行流，所以如果是在并发queue上同步执行，那么仍然不会创建新线程，而只是在当前线程执行。但是注意特殊情况：在异步线程执行sync到main queue的任务，仍然会在主线程执行！所以的main queue任务必须在主线程执行！！</p><h3 id="入口函数：dispatch-sync"><a href="#入口函数：dispatch-sync" class="headerlink" title="入口函数：dispatch_sync"></a>入口函数：dispatch_sync</h3><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dispatch_sync</span><span class="hljs-params">(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> (^work)(<span class="hljs-type">void</span>))</span> </span>&#123;<br><span class="hljs-comment">// DISPATCH_COCOA_COMPAT是Mac OS下才会走的</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_COCOA_COMPAT</span><br><span class="hljs-comment">// 是否是主队列</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dq == &amp;_dispatch_main_q)) &#123;<br><span class="hljs-comment">// 内部也是执行dispatch_sync_f函数</span><br><span class="hljs-keyword">return</span> _dispatch_sync_slow(dq, work);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Block_basic</span> *bb = (<span class="hljs-type">void</span> *)work;<br><span class="hljs-built_in">dispatch_sync_f</span>(dq, work, (<span class="hljs-type">dispatch_function_t</span>)bb-&gt;Block_invoke);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>虽然该函数缺乏了main queue，但是最终执行的还是dispatch_sync_f，其源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dispatch_sync_f</span><span class="hljs-params">(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> *ctxt, <span class="hljs-type">dispatch_function_t</span> func)</span> </span>&#123;<br><span class="hljs-comment">// 串行队列包括主队列</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fastpath</span>(dq-&gt;dq_width == <span class="hljs-number">1</span>)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">dispatch_barrier_sync_f</span>(dq, ctxt, func);<br>&#125;<br><span class="hljs-comment">// 全局队列，全局队列是没有do_targetq的，主队列/管理队列/自定义队列都有</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(!dq-&gt;do_targetq)) &#123;<br><span class="hljs-comment">// the global root queues do not need strict ordering</span><br>(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_atomic_add2o</span>(dq, dq_running, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">return</span> _dispatch_sync_f_invoke(dq, ctxt, func);<br>&#125;<br><span class="hljs-comment">// 其他队列</span><br>_dispatch_sync_f2(dq, ctxt, func);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>该函数区分了三种case：</p><ul><li>串行queue：执行dispatch_barrier_sync_f</li><li>并发queue：<ul><li>global queue：_dispatch_sync_f_invoke</li><li>非global queue：_dispatch_sync_f2</li></ul></li></ul><h3 id="重点函数dispatch-barrier-sync-f"><a href="#重点函数dispatch-barrier-sync-f" class="headerlink" title="重点函数dispatch_barrier_sync_f"></a>重点函数dispatch_barrier_sync_f</h3><p>该函数用于串行queue sync的时候，其实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dispatch_barrier_sync</span><span class="hljs-params">(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> (^work)(<span class="hljs-type">void</span>))</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_COCOA_COMPAT</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dq == &amp;_dispatch_main_q)) &#123;<br>   <span class="hljs-comment">// 内部调用dispatch_barrier_sync_f函数</span><br><span class="hljs-keyword">return</span> _dispatch_barrier_sync_slow(dq, work);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Block_basic</span> *bb = (<span class="hljs-type">void</span> *)work;<br><span class="hljs-built_in">dispatch_barrier_sync_f</span>(dq, work, (<span class="hljs-type">dispatch_function_t</span>)bb-&gt;Block_invoke);<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然区分main queue，但最终是调用dispatch_barrier_sync_f。查看源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">DISPATCH_NOINLINE</span><br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">dispatch_barrier_sync_f</span><span class="hljs-params">(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> *ctxt, <span class="hljs-type">dispatch_function_t</span> func)</span> </span>&#123;<br><span class="hljs-comment">// 1) ensure that this thread hasn&#x27;t enqueued anything ahead of this call</span><br><span class="hljs-comment">// 2) the queue is not suspended</span><br><span class="hljs-comment">// 1) 确保此线程在此调用之前没有入队</span><br><span class="hljs-comment">// 2) 队列未挂起</span><br><br><span class="hljs-comment">// 第1步：如果串行队列中存在其他任务或者队列被挂起，进入_dispatch_barrier_sync_f_slow，</span><br><span class="hljs-comment">// 等待这个队列中的其他任务完成(用信号量的方式通知)，然后执行这个任务。</span><br><span class="hljs-comment">// 多数情况下不会发生</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dq-&gt;dq_items_tail) || <span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">DISPATCH_OBJECT_SUSPENDED</span>(dq)))&#123;<br><span class="hljs-keyword">return</span> _dispatch_barrier_sync_f_slow(dq, ctxt, func);<br>&#125;<br><br><span class="hljs-comment">// 第2步：检查队列的dq_running状态，如果没有运行，进入_dispatch_barrier_sync_f_slow，等待激活。</span><br><span class="hljs-comment">// bool __sync_bool_compare_and_swap (type *ptr, type oldval, type newval, ...)</span><br><span class="hljs-comment">// 比较*ptr与oldval的值，如果两者相等，则将newval更新到*ptr并返回true</span><br><span class="hljs-comment">// dispatch_atomic_cmpxchg2o(dq, dq_running, 0, 1)相当于dq-&gt;dq_running为0的时候将</span><br><span class="hljs-comment">// dq-&gt;dq_running设置为1，并返回true</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(!<span class="hljs-built_in">dispatch_atomic_cmpxchg2o</span>(dq, dq_running, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>))) &#123;<br><span class="hljs-comment">// global queues and main queue bound to main thread always falls into</span><br><span class="hljs-comment">// the slow case</span><br><span class="hljs-comment">// 全局队列和绑定到主线程的主队列始终属于慢速情况即会进入_dispatch_barrier_sync_f_slow函数</span><br><span class="hljs-keyword">return</span> _dispatch_barrier_sync_f_slow(dq, ctxt, func);<br>&#125;<br><br><span class="hljs-comment">// 第3步：有多重队列，寻找真正的目标队列，其实还是回到了dispatch_sync_f方法</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dq-&gt;do_targetq-&gt;do_targetq)) &#123;<br><span class="hljs-keyword">return</span> _dispatch_barrier_sync_f_recurse(dq, ctxt, func);<br>&#125;<br><br><span class="hljs-comment">// 第4步：队列无任务执行，调用_dispatch_barrier_sync_f_invoke执行任务。</span><br><span class="hljs-comment">// 内部调用_dispatch_function_invoke去执行任务</span><br>_dispatch_barrier_sync_f_invoke(dq, ctxt, func);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中涉及到三个函数：</p><ul><li>_dispatch_barrier_sync_f_slow：若串行queue有任务正在执行，内部使用线程对应信号量并wait，使得当前线程挂起等待被唤醒</li><li>_dispatch_barrier_sync_f_recurse：内部调用dispatch_sync_f，这样形成递归，目的是查找最终的目标queue</li><li>若queue无任务执行，则可以直接执行，调用_dispatch_barrier_sync_f_invoke执行，执行时调用_dispatch_function_invoke</li><li>总结起来：有任务正在执行，先挂起线程，等待任务执行完毕再唤醒当前线程继续执行</li></ul><h3 id="dispatch-barrier-sync-f-invoke"><a href="#dispatch-barrier-sync-f-invoke" class="headerlink" title="_dispatch_barrier_sync_f_invoke"></a>_dispatch_barrier_sync_f_invoke</h3><p>该函数用于在串行queue当前无任务正在执行时，实际去执行任务，源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++">DISPATCH_NOINLINE<br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br>_dispatch_barrier_sync_f_invoke(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> *ctxt, <span class="hljs-type">dispatch_function_t</span> func) &#123;<br>    <span class="hljs-comment">// _dispatch_function_invoke的实现</span><br>    <span class="hljs-comment">// 将当前线程的dispatch_queue_key设置为dq，然后执行任务，</span><br>    <span class="hljs-comment">// 执行完之后再恢复到之前的old_dq</span><br>    <span class="hljs-type">dispatch_queue_t</span> old_dq = _dispatch_thread_getspecific(dispatch_queue_key);<br>_dispatch_thread_setspecific(dispatch_queue_key, dq);<br>_dispatch_client_callout(ctxt, func);<br>_dispatch_workitem_inc();<br>_dispatch_thread_setspecific(dispatch_queue_key, old_dq);<br><br><span class="hljs-comment">// 如果队列中存在其他任务，用信号量的方法唤醒，然后继续执行下一个任务</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dq-&gt;dq_items_tail)) &#123;<br><span class="hljs-keyword">return</span> _dispatch_barrier_sync_f2(dq);<br>&#125;<br><br><span class="hljs-comment">// dispatch_atomic_dec2o这个宏，会调用GCC内置的函数 __sync_sub_and_fetch，实现减法的原子性操作。因此这一行的意思是将dq_running的值减1，然后判断是否与0相等。</span><br><span class="hljs-comment">// _dispatch_wakeup为唤醒队列函数</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">dispatch_atomic_dec2o</span>(dq, dq_running) == <span class="hljs-number">0</span>)) &#123;<br>_dispatch_wakeup(dq);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>该函数总结就是：先执行任务，任务执行完毕之后若有其他任务在等着，则尝试唤醒，执行下一个任务</p><h3 id="GCD死锁产生的原因"><a href="#GCD死锁产生的原因" class="headerlink" title="GCD死锁产生的原因"></a>GCD死锁产生的原因</h3><p>我们知道，如果在主线程中使用dispatch_sync到main queue会造成死锁，比如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-meta">#import <span class="hljs-string">&quot;DeadLock.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">DeadLock</span></span><br><br>- (<span class="hljs-keyword">instancetype</span>)init &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init]) &#123;<br><span class="hljs-comment">//        [self _mianQueueDeadLock];</span><br>        [<span class="hljs-keyword">self</span> _serialQueueDeadLock];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - Private</span><br><br>- (<span class="hljs-type">void</span>)_mianQueueDeadLock &#123;<br>    <span class="hljs-built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^(<span class="hljs-type">void</span>)&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;这里死锁了&quot;</span>);<br>    &#125;);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)_serialQueueDeadLock &#123;<br>    <span class="hljs-built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="hljs-string">&quot;1serialQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <span class="hljs-built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="hljs-string">&quot;2serialQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <br>    <span class="hljs-built_in">dispatch_sync</span>(queue1, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;11111&quot;</span>);<br>        <br>        <span class="hljs-built_in">dispatch_sync</span>(queue1, ^&#123; <br>            <span class="hljs-comment">// 如果使用queue2就不会发生死锁，使用queue1就会死锁</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;22222&quot;</span>);<br>        &#125;);<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>以_serialQueueDeadLock为例，当我们首次执行串行queue任务时，正常执行，而执行到第二个dispatch_sync时，<code>由于上一个任务还没执行完毕(正在执行sync)，从而使得当前线程进入了wait，从而永远没有机会被唤醒，进入死锁</code></p><h3 id="dispatch-sync-f-invoke"><a href="#dispatch-sync-f-invoke" class="headerlink" title="_dispatch_sync_f_invoke"></a>_dispatch_sync_f_invoke</h3><p>该函数用于在并发的global queue同步执行任务时被调用，具体代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br>_dispatch_sync_f_invoke(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> *ctxt, <span class="hljs-type">dispatch_function_t</span> func) &#123;<br><span class="hljs-comment">// 执行任务</span><br>_dispatch_function_invoke(dq, ctxt, func);<br><span class="hljs-comment">// dq-&gt;dq_running减2后判断是否等于0，是就唤醒队列</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">dispatch_atomic_sub2o</span>(dq, dq_running, <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>)) &#123;<br>_dispatch_wakeup(dq);<br>&#125;<br>&#125;<br><br>``<br>该函数作用：先通过_dispatch_function_invoke执行任务，执行完毕后，判断queue有没有激活，没有激活，则执行激活函数_dispatch_wakeup<br><br>### _dispatch_sync_f2<br>当在非global的并发queue上同步执行任务时，调用该函数，源码<br>```C++<br>_dispatch_sync_f2(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> *ctxt, <span class="hljs-type">dispatch_function_t</span> func) &#123;<br><span class="hljs-comment">// 1) ensure that this thread hasn&#x27;t enqueued anything ahead of this call</span><br><span class="hljs-comment">// 2) the queue is not suspended</span><br><br><span class="hljs-comment">// 第1步：队列中有其他任务或者队列被挂起，压入信号量开始等待</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dq-&gt;dq_items_tail) || <span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">DISPATCH_OBJECT_SUSPENDED</span>(dq)))&#123;<br><span class="hljs-keyword">return</span> _dispatch_sync_f_slow(dq, ctxt, func);<br>&#125;<br><span class="hljs-comment">// 第2步：队列没有激活，激活队列后执行任务，最终还是调用了_dispatch_sync_f_slow函数，只是多了一个_dispatch_wakeup函数</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">dispatch_atomic_add2o</span>(dq, dq_running, <span class="hljs-number">2</span>) &amp; <span class="hljs-number">1</span>)) &#123;<br><span class="hljs-keyword">return</span> _dispatch_sync_f_slow2(dq, ctxt, func);<br>&#125;<br><span class="hljs-comment">// 第3步：队列有多重队列，寻找真正的目标队列</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(dq-&gt;do_targetq-&gt;do_targetq)) &#123;<br><span class="hljs-keyword">return</span> _dispatch_sync_f_recurse(dq, ctxt, func);<br>&#125;<br><span class="hljs-comment">// 第4步：队列无任务执行，调用_dispatch_sync_f_invoke执行任务。</span><br><span class="hljs-comment">// 内部调用_dispatch_function_invoke去执行任务</span><br>_dispatch_sync_f_invoke(dq, ctxt, func);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里涉及到三个函数：</p><ul><li>_dispatch_sync_f_slow：该函数内部使用wait让调用线程进入等待</li><li>_dispatch_sync_f_recurse：该函内部调用了dispatch_sync_f,寻找最终的目标队列</li><li>_dispatch_sync_f_invoke：若队列中无任务，则调用该函数执行，最终调用_dispatch_function_invoke</li></ul><p>从上面的代码可以看出，<code>在queue上执行同步任务都是顺序执行的，这种顺序和queue是串行还是并发没有关系，这些任务按照fifo的方式进入queue，每一个任务都会等待前一个的完成，并且不会开辟新线程，只会在当前线程执行</code></p><p>整理下如图所示<br><img src="/../images/image-44.png" alt="Alt text"></p><h2 id="queue中代码的异步执行：dispatch-async"><a href="#queue中代码的异步执行：dispatch-async" class="headerlink" title="queue中代码的异步执行：dispatch_async"></a>queue中代码的异步执行：dispatch_async</h2><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>串行queue：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">let</span> sQueue <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>(label: <span class="hljs-string">&quot;sQueue&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>)<br>sQueue.async &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-number">2</span>)</span>：<span class="hljs-subst">\(Thread.current)</span>&quot;</span>) &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-number">3</span>)<br>sQueue.async &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-number">4</span>)</span>：<span class="hljs-subst">\(Thread.current)</span>&quot;</span>) &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br><span class="hljs-number">5</span><br><span class="hljs-number">2</span>：<span class="hljs-operator">&lt;</span><span class="hljs-type">NSThread</span>: <span class="hljs-number">0x600000b884c0</span><span class="hljs-operator">&gt;</span>&#123;number <span class="hljs-operator">=</span> <span class="hljs-number">4</span>, name <span class="hljs-operator">=</span> (null)&#125;<br><span class="hljs-number">4</span>：<span class="hljs-operator">&lt;</span><span class="hljs-type">NSThread</span>: <span class="hljs-number">0x600000b884c0</span><span class="hljs-operator">&gt;</span>&#123;number <span class="hljs-operator">=</span> <span class="hljs-number">4</span>, name <span class="hljs-operator">=</span> (null)&#125;<br></code></pre></td></tr></table></figure><p>可见，顺序执行串行queue中的任务，并且新创建了线程</p><p>并发queue：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">let</span> cQueue <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>(label: <span class="hljs-string">&quot;cQueue&quot;</span>, attributes: [.concurrent])<br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>)<br>cQueue.async &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-number">2</span>)</span>：<span class="hljs-subst">\(Thread.current)</span>&quot;</span>) &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-number">3</span>)<br>cQueue.async &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-number">4</span>)</span>：<span class="hljs-subst">\(Thread.current)</span>&quot;</span>) &#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br><span class="hljs-number">5</span><br><span class="hljs-number">4</span>：<span class="hljs-operator">&lt;</span><span class="hljs-type">NSThread</span>: <span class="hljs-number">0x600002bc69c0</span><span class="hljs-operator">&gt;</span>&#123;number <span class="hljs-operator">=</span> <span class="hljs-number">6</span>, name <span class="hljs-operator">=</span> (null)&#125;<br><span class="hljs-number">2</span>：<span class="hljs-operator">&lt;</span><span class="hljs-type">NSThread</span>: <span class="hljs-number">0x600002bc84c0</span><span class="hljs-operator">&gt;</span>&#123;number <span class="hljs-operator">=</span> <span class="hljs-number">5</span>, name <span class="hljs-operator">=</span> (null)&#125;<br></code></pre></td></tr></table></figure><p>可见，然后使用不同线程，乱序执行加入的任务</p><p>总结就是：</p><ul><li>queue的异步任务具有创建新线程的能力</li><li>非main queue的串行queue，会创建一个新线程，然后所有任务串行执行</li><li>并发queue会创建多个线程，具体数量由系统决定，任务之间无顺序</li></ul><h3 id="入口函数：dispatch-async"><a href="#入口函数：dispatch-async" class="headerlink" title="入口函数：dispatch_async"></a>入口函数：dispatch_async</h3><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dispatch_async</span><span class="hljs-params">(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> (^work)(<span class="hljs-type">void</span>))</span> </span>&#123;<br><span class="hljs-built_in">dispatch_async_f</span>(dq, _dispatch_Block_copy(work), _dispatch_call_block_and_release);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数会将任务block copy到堆，或者增加引用计数（如果block已经在堆上），调用dispatch_async_f进入执行策略</p><p>dispatch_async_f函数的试实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">dispatch_async_f</span><span class="hljs-params">(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> *ctxt, <span class="hljs-type">dispatch_function_t</span> func)</span> </span>&#123;<br><span class="hljs-type">dispatch_continuation_t</span> dc;<br><br><span class="hljs-comment">// No fastpath/slowpath hint because we simply don&#x27;t know</span><br><span class="hljs-comment">// 串行队列，执行dispatch_barrier_async_f，其实最后还是执行任务入队的操作</span><br><span class="hljs-keyword">if</span> (dq-&gt;dq_width == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">dispatch_barrier_async_f</span>(dq, ctxt, func);<br>&#125;<br><br><span class="hljs-comment">// 从线程私有数据中获取一个dispatch_continuation_t的结构体</span><br>dc = <span class="hljs-built_in">fastpath</span>(_dispatch_continuation_alloc_cacheonly());<br><span class="hljs-keyword">if</span> (!dc) &#123;<br><span class="hljs-keyword">return</span> _dispatch_async_f_slow(dq, ctxt, func);<br>&#125;<br><br>dc-&gt;do_vtable = (<span class="hljs-type">void</span> *)DISPATCH_OBJ_ASYNC_BIT;<br>dc-&gt;dc_func = func;<br>dc-&gt;dc_ctxt = ctxt;<br><br><span class="hljs-comment">// No fastpath/slowpath hint because we simply don&#x27;t know</span><br><span class="hljs-comment">// 有目标队列，调用_dispatch_async_f2函数进行转发。</span><br><span class="hljs-keyword">if</span> (dq-&gt;do_targetq) &#123;<br><span class="hljs-keyword">return</span> _dispatch_async_f2(dq, dc);<br>&#125;<br><br><span class="hljs-comment">// 全局队列直接进行入队操作</span><br>_dispatch_queue_push(dq, dc);<br>&#125;<br></code></pre></td></tr></table></figure><p>从源码可以看出，该函数主要分为三种case：</p><ul><li>串行queue：调用dispatch_barrier_async_f</li><li>并发queue：<ul><li>若有目标queue：调用_dispatch_async_f2进行转发</li><li>若是global queue：直接调用_dispatch_queue_push入queue</li></ul></li></ul><p>由于queue的异步执行策略较为复杂，下面是图示：<br><img src="/../images/image-45.png" alt="Alt text"><br>从途中可以看出，虽然分了三种情况，但是最终都要走到_dispatch_queue_push或者_dispatch_async_f2，而后者其实也是执行入队操作，所以本质就是执行_dispatch_queue_push</p><h3 id="dispatch-continuation-t结构体"><a href="#dispatch-continuation-t结构体" class="headerlink" title="dispatch_continuation_t结构体"></a>dispatch_continuation_t结构体</h3><p>这个结构体实际就是用力啊封装我们传入的block，以串行queue的case，dispatch_barrier_async_f的源码为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dispatch_barrier_async_f</span><span class="hljs-params">(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">void</span> *ctxt, <span class="hljs-type">dispatch_function_t</span> func)</span> </span>&#123;<br><span class="hljs-type">dispatch_continuation_t</span> dc;<br><span class="hljs-comment">// 从线程私有数据中获取一个dispatch_continuation_t的结构体。</span><br>dc = <span class="hljs-built_in">fastpath</span>(_dispatch_continuation_alloc_cacheonly());<br><span class="hljs-keyword">if</span> (!dc) &#123;<br><span class="hljs-comment">// _dispatch_barrier_async_f_slow内部也是在进行入队操作</span><br><span class="hljs-keyword">return</span> _dispatch_barrier_async_f_slow(dq, ctxt, func);<br>&#125;<br><br><span class="hljs-comment">// DISPATCH_OBJ_BARRIER_BIT，用于阻塞标识</span><br>dc-&gt;do_vtable = (<span class="hljs-type">void</span> *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT);<br><span class="hljs-comment">// 将_dispatch_call_block_and_release作为func方法</span><br>dc-&gt;dc_func = func;<br><span class="hljs-comment">// 将传入的block作为上下文</span><br>dc-&gt;dc_ctxt = ctxt;<br><span class="hljs-comment">// 入队操作</span><br>_dispatch_queue_push(dq, dc);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，我们的block被作为dc的context成员了。<br>注意dc的do_vtable：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 串行队列异步或者使用dispatch_barrier_async函数会有一个DISPATCH_OBJ_BARRIER_BIT的barrier标记</span><br>dc-&gt;do_vtable = (<span class="hljs-type">void</span> *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT);<br><br><span class="hljs-comment">// not barrier</span><br>dc-&gt;do_vtable = (<span class="hljs-type">void</span> *)DISPATCH_OBJ_ASYNC_BIT;<br></code></pre></td></tr></table></figure><p>可以看出，对于不同情况，dc的do_vtable的标记也不相同，在GCD内部，存在4种标记：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISPATCH_OBJ_ASYNC_BIT0x1<span class="hljs-comment">//异步</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISPATCH_OBJ_BARRIER_BIT0x2<span class="hljs-comment">//阻塞</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISPATCH_OBJ_GROUP_BIT0x4<span class="hljs-comment">//组</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DISPATCH_OBJ_SYNC_SLOW_BIT0x8<span class="hljs-comment">//同步慢</span></span><br></code></pre></td></tr></table></figure><p>通过DISPATCH_OBJ_BARRIER_BIT标记，GCD知道需要使用阻塞特性。</p><h3 id="任务入queue：-dispatch-queue-push"><a href="#任务入queue：-dispatch-queue-push" class="headerlink" title="任务入queue：_dispatch_queue_push"></a>任务入queue：_dispatch_queue_push</h3><p>它实际是个宏定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _dispatch_queue_push(x, y) _dispatch_queue_push_list((x), (y), (y))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _dispatch_queue_push_list _dispatch_trace_queue_push_list</span><br></code></pre></td></tr></table></figure><p>_dispatch_trace_queue_push_list源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">void</span> _dispatch_trace_queue_push_list(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">dispatch_object_t</span> _head, <span class="hljs-type">dispatch_object_t</span> _tail) &#123;<br><span class="hljs-comment">// 是否可以入队</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">DISPATCH_QUEUE_PUSH_ENABLED</span>())) &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_object_s</span> *dou = _head._do;<br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-comment">// 主要是对dispatch_continuation_s结构体的处理，确保后面的使用。</span><br>_dispatch_trace_continuation(dq, dou, DISPATCH_QUEUE_PUSH);<br>&#125; <span class="hljs-keyword">while</span> (dou != _tail._do &amp;&amp; (dou = dou-&gt;do_next));<br>&#125;<br><br>_dispatch_queue_push_list(dq, _head, _tail);<br>&#125;<br></code></pre></td></tr></table></figure><p>_dispatch_queue_push_list的源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">void</span> _dispatch_queue_push_list(<span class="hljs-type">dispatch_queue_t</span> dq, <span class="hljs-type">dispatch_object_t</span> _head, <span class="hljs-type">dispatch_object_t</span> _tail) &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_object_s</span> *prev, *head = _head._do, *tail = _tail._do;<br><br>tail-&gt;do_next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">dispatch_atomic_store_barrier</span>();<br><span class="hljs-comment">// dispatch_atomic_xchg2o实质是调用((typeof(*(p)))__sync_swap((p), (n)))，它的定义是将p设为n并返回p操作之前的值。</span><br><span class="hljs-comment">// dispatch_atomic_xchg2o(dq, dq_items_tail, tail)相当于dq-&gt;dq_items_tail = tail，重新设置了队列的尾指针</span><br>prev = <span class="hljs-built_in">fastpath</span>(<span class="hljs-built_in">dispatch_atomic_xchg2o</span>(dq, dq_items_tail, tail));<br><span class="hljs-keyword">if</span> (prev) &#123;<br><span class="hljs-comment">// if we crash here with a value less than 0x1000, then we are at a</span><br><span class="hljs-comment">// known bug in client code for example, see _dispatch_queue_dispose</span><br><span class="hljs-comment">// or _dispatch_atfork_child</span><br><span class="hljs-comment">// prev是原先的队尾，如果队列中有其他的元素，就将压入的对象加在队列的尾部。</span><br>prev-&gt;do_next = head;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 如果队列为空</span><br>_dispatch_queue_push_list_slow(dq, head);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>_dispatch_queue_push_list_slow的源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">_dispatch_queue_push_list_slow(<span class="hljs-type">dispatch_queue_t</span> dq,<br><span class="hljs-keyword">struct</span> dispatch_object_s *obj)<br>&#123;<br><span class="hljs-comment">//dq-&gt;dq_items_head设置为dc，然后唤醒这个队列。因为此时队列为空，没有任务在执行，处于休眠状态，所以需要唤醒</span><br>_dispatch_retain(dq);<br>dq-&gt;dq_items_head = obj;<br>_dispatch_wakeup(dq);<br>_dispatch_release(dq);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="唤醒queue：-dispatch-wakeup"><a href="#唤醒queue：-dispatch-wakeup" class="headerlink" title="唤醒queue：_dispatch_wakeup"></a>唤醒queue：_dispatch_wakeup</h3><p>无论是同步执行还是异步执行，都使用该函数，用于唤醒当前queue，其源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">dispatch_queue_t</span> _dispatch_wakeup(<span class="hljs-type">dispatch_object_t</span> dou) &#123;<br><span class="hljs-type">dispatch_queue_t</span> tq;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">DISPATCH_OBJECT_SUSPENDED</span>(dou._do))) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dx_probe</span>(dou._do) &amp;&amp; !dou._dq-&gt;dq_items_tail) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// 如果dou._do-&gt;do_suspend_cnt == 0，返回YES,否则返回NO；</span><br><span class="hljs-comment">// 同时将DISPATCH_OBJECT_SUSPEND_LOCK赋值给dou._do-&gt;do_suspend_cnt</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dispatch_atomic_cmpxchg2o</span>(dou._do, do_suspend_cnt, <span class="hljs-number">0</span>, DISPATCH_OBJECT_SUSPEND_LOCK)) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_COCOA_COMPAT</span><br><span class="hljs-comment">// 主队列的任务调用_dispatch_queue_wakeup_main唤醒主队列</span><br><span class="hljs-keyword">if</span> (dou._dq == &amp;_dispatch_main_q) &#123;<br>_dispatch_queue_wakeup_main();<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// 放到目标队列中，重新走_dispatch_queue_push方法</span><br>_dispatch_retain(dou._do);<br>tq = dou._do-&gt;do_targetq;<br>_dispatch_queue_push(tq, dou._do);<br><br><span class="hljs-keyword">return</span> tq;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面我们看到了main queue和自定义queue的情况，但是没有global queue，因为global queue的唤醒比较隐晦，针对global queue的dx_probe(dou._do)调用如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> dx_probe(x) (x)-&gt;do_vtable-&gt;do_probe(x)</span><br><br><span class="hljs-comment">// dx_probe(dou._do) 相当于 (dou.do)-&gt;do_vtable-&gt;do_probe(dou.do)</span><br><br><span class="hljs-comment">// 全局队列的do_vtable：_dispatch_queue_root_vtable</span><br><br><span class="hljs-comment">// _dispatch_queue_root_vtable的定义</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_queue_vtable_s</span> _dispatch_queue_root_vtable = &#123;<br>.do_type = DISPATCH_QUEUE_GLOBAL_TYPE,<br>.do_kind = <span class="hljs-string">&quot;global-queue&quot;</span>,<br>.do_debug = dispatch_queue_debug,<br>.do_probe = _dispatch_queue_wakeup_global,<br>&#125;;<br><br><span class="hljs-comment">// 全局队列：</span><br><span class="hljs-comment">// globalQueue -&gt; _dispatch_queue_root_vtable -&gt; _dispatch_queue_wakeup_global</span><br></code></pre></td></tr></table></figure><p>从上面可以看出，唤醒分为4种case：</p><ul><li>main queue：使用_dispatch_queue_wakeup_main</li><li>global queue：使用_dispatch_queue_wakeup_global</li><li>manager queue：调用_dispatch_mgr_wakeup，主要为dispatch_source服务</li><li>其他queue：向target queue压入该queue，继续做入queue操作</li></ul><h3 id="dispatch-queue-wakeup-main"><a href="#dispatch-queue-wakeup-main" class="headerlink" title="_dispatch_queue_wakeup_main"></a>_dispatch_queue_wakeup_main</h3><p>用于唤醒主线程的runloop，源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">void</span> _dispatch_queue_wakeup_main(<span class="hljs-type">void</span>) &#123;<br><span class="hljs-type">kern_return_t</span> kr;<br><span class="hljs-comment">// 主要看_dispatch_main_q_port_init的实现</span><br><span class="hljs-built_in">dispatch_once_f</span>(&amp;_dispatch_main_q_port_pred, <span class="hljs-literal">NULL</span>,<br>_dispatch_main_q_port_init);<br><span class="hljs-comment">// 关于主线程的唤醒主要靠mach_port和在runloop中注册相对应的source1</span><br>    <span class="hljs-comment">// 但是该函数的实现没有公开</span><br>kr = _dispatch_send_wakeup_main_thread(main_q_port, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">switch</span> (kr) &#123;<br><span class="hljs-keyword">case</span> MACH_SEND_TIMEOUT:<br><span class="hljs-keyword">case</span> MACH_SEND_TIMED_OUT:<br><span class="hljs-keyword">case</span> MACH_SEND_INVALID_DEST:<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_assume_zero</span>(kr);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>_dispatch_safe_fork = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// _dispatch_main_q_port_init的实现，RunLoop的唤醒需要依赖于mach port</span><br><span class="hljs-type">void</span> _dispatch_main_q_port_init(<span class="hljs-type">void</span> *ctxt DISPATCH_UNUSED) &#123;<br><span class="hljs-type">kern_return_t</span> kr;<br><br>kr = <span class="hljs-built_in">mach_port_allocate</span>(<span class="hljs-built_in">mach_task_self</span>(), MACH_PORT_RIGHT_RECEIVE,<br>&amp;main_q_port);<br><span class="hljs-built_in">DISPATCH_VERIFY_MIG</span>(kr);<br>(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_assume_zero</span>(kr);<br>kr = <span class="hljs-built_in">mach_port_insert_right</span>(<span class="hljs-built_in">mach_task_self</span>(), main_q_port, main_q_port,<br>MACH_MSG_TYPE_MAKE_SEND);<br><span class="hljs-built_in">DISPATCH_VERIFY_MIG</span>(kr);<br>(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_assume_zero</span>(kr);<br><br>_dispatch_program_is_probably_callback_driven = <span class="hljs-literal">true</span>;<br>_dispatch_safe_fork = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，唤醒主线程就是通过mach port向主线程发送消息，从而进一步唤醒RunLoop。所以我们说RunLoop RunLoop可以看做是使用GCD的API的，但是对于main queue，GCD和RunLoop紧密合作。</p><h3 id="dispatch-queue-wakeup-global"><a href="#dispatch-queue-wakeup-global" class="headerlink" title="_dispatch_queue_wakeup_global"></a>_dispatch_queue_wakeup_global</h3><p>源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-type">bool</span><br>_dispatch_queue_wakeup_global(<span class="hljs-type">dispatch_queue_t</span> dq) &#123;<br><span class="hljs-type">static</span> <span class="hljs-type">dispatch_once_t</span> pred;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_root_queue_context_s</span> *qc = dq-&gt;do_ctxt;<br><span class="hljs-type">int</span> r;<br><br><span class="hljs-keyword">if</span> (!dq-&gt;dq_items_tail) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>_dispatch_safe_fork = <span class="hljs-literal">false</span>;<br><br><span class="hljs-built_in">dispatch_debug_queue</span>(dq, __PRETTY_FUNCTION__);<br><br><span class="hljs-comment">// 上下文以及根队列的初始化，根队列内部会初始化线程池</span><br><span class="hljs-built_in">dispatch_once_f</span>(&amp;pred, <span class="hljs-literal">NULL</span>, _dispatch_root_queues_init);<br><br><span class="hljs-comment">// _dispatch_queue_wakeup_global支持两种实现的任务唤醒pthread_workqueue和thread pool</span><br><span class="hljs-comment">//  1.支持pthread_workqueue</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> HAVE_PTHREAD_WORKQUEUES</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br><span class="hljs-comment">// 如果队列的dgq_kworkqueue存在，则调用pthread_workqueue_additem_np函数</span><br><span class="hljs-comment">// dgq_kworkqueue是一个用于创建内核线程的接口，通过它创建的内核线程来执行内核其他模块排列到队列里的工作。</span><br><span class="hljs-comment">// 不同优先级的dispatch queue对应着对应优先级的workqueue。</span><br><span class="hljs-comment">// _dispatch_root_queues_init初始化的时候，使用pthread_workqueue_create_np创建pthread_workqueue</span><br><span class="hljs-keyword">if</span> (qc-&gt;dgq_kworkqueue)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">dispatch_atomic_cmpxchg2o</span>(qc, dgq_pending, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br><span class="hljs-type">pthread_workitem_handle_t</span> wh;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> gen_cnt;<br>_dispatch_debug(<span class="hljs-string">&quot;requesting new worker thread&quot;</span>);<br><span class="hljs-comment">// 该函数使用workq_kernreturn系统调用，通知workqueue增加应当执行的项目。</span><br><span class="hljs-comment">// 根据该通知，XNU内核基于系统状态判断是否要生成线程，如果是overcommit优先级的队列，workqueue则始终生成线程。</span><br>r = <span class="hljs-built_in">pthread_workqueue_additem_np</span>(qc-&gt;dgq_kworkqueue, _dispatch_worker_thread2, dq, &amp;wh, &amp;gen_cnt);<br>(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_assume_zero</span>(r);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>_dispatch_debug(<span class="hljs-string">&quot;work thread request still pending on global &quot;</span><br><span class="hljs-string">&quot;queue: %p&quot;</span>, dq);<br>&#125;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// HAVE_PTHREAD_WORKQUEUES</span></span><br><span class="hljs-comment">// 2. 支持thread pool</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_ENABLE_THREAD_POOL</span><br><span class="hljs-comment">// 通过发送一个信号量使线程保活</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">dispatch_semaphore_signal</span>(qc-&gt;dgq_thread_mediator)) &#123;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><br><span class="hljs-comment">// 计算线程池可用长度，如果线程池已满则跳转到out即return false，否则执行线程池-1操作</span><br><span class="hljs-type">pthread_t</span> pthr;<br><span class="hljs-type">int</span> t_count;<br><span class="hljs-keyword">do</span> &#123;<br>t_count = qc-&gt;dgq_thread_pool_size;<br><span class="hljs-keyword">if</span> (!t_count) &#123;<br>_dispatch_debug(<span class="hljs-string">&quot;The thread pool is full: %p&quot;</span>, dq);<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">dispatch_atomic_cmpxchg2o</span>(qc, dgq_thread_pool_size, t_count, t_count - <span class="hljs-number">1</span>));<br><span class="hljs-comment">// qc-&gt;dgq_thread_pool_size的值与t_counts是否相等，是就减1，并返回ture</span><br><br><span class="hljs-comment">// 这里说明线程池不够用了，使用pthread创建一个线程，</span><br><span class="hljs-comment">// 并执行_dispatch_worker_thread,_dispatch_worker_thread最终会调用到_dispatch_worker_thread2</span><br><span class="hljs-keyword">while</span> ((r = <span class="hljs-built_in">pthread_create</span>(&amp;pthr, <span class="hljs-literal">NULL</span>, _dispatch_worker_thread, dq))) &#123;<br><span class="hljs-keyword">if</span> (r != EAGAIN) &#123;<br>(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_assume_zero</span>(r);<br>&#125;<br><span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// 保证pthr能够被回收</span><br>r = <span class="hljs-built_in">pthread_detach</span>(pthr);<br>(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_assume_zero</span>(r);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// DISPATCH_ENABLE_THREAD_POOL</span></span><br><br>out:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="queue的任务调度"><a href="#queue的任务调度" class="headerlink" title="queue的任务调度"></a>queue的任务调度</h2><h3 id="main-queue的任务调度"><a href="#main-queue的任务调度" class="headerlink" title="main queue的任务调度"></a>main queue的任务调度</h3><p>在上面的分析中我们知道，唤醒main queue会调用_dispatch_send_wakeup_main_thread，但是该函数没有公开实现。通过函数调用栈我们知道，main queue的任务调度最终又回到了GCD之中的_dispatch_main_queue_callback_4CF。唤醒主线程，RunLoop执行__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__，接着调用了GCD执行_dispatch_main_queue_callback_4CF，其源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 处理主队列任务</span><br><span class="hljs-type">void</span> _dispatch_main_queue_callback_4CF(<span class="hljs-type">mach_msg_header_t</span> *msg DISPATCH_UNUSED) &#123;<br><span class="hljs-keyword">if</span> (main_q_is_draining) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 正在处理任务，设置状态为true</span><br>_dispatch_queue_set_mainq_drain_state(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 调度处理任务</span><br>_dispatch_main_queue_drain();<br><span class="hljs-comment">// 处理任务完成任务，恢复状态为false</span><br>_dispatch_queue_set_mainq_drain_state(<span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>main queue是串行queue，拿到本次要执行的dc，执行任务。对于之后入队的block，则放在下一轮的main queue唤醒中执行</p><p>如果RunLoop还未休眠，并且main queue中存在等待执行的任务，则RunLoop会在处理完这些任务之后再进入休眠。否则，GCD唤醒主线程，进而唤醒RunLoop，再通过GCD中的函数取出来执行，直到执行完毕再进入休眠。</p><p>ps，再看下gcd唤醒追线程后的调用栈：<br>主线程唤醒-&gt;执行runloop的__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__-&gt;调用GCD的_dispatch_main_queue_callback_4CF-&gt;调用之前封装dc的_dispatch_call_block_and_release的函数-&gt;执行block，注意这里_dispatch_call_block_and_release函数，他是之前封装dc时传进来的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++">thread #<span class="hljs-number">1</span>, queue = <span class="hljs-string">&#x27;com.apple.main-thread&#x27;</span>, stop reason = breakpoint <span class="hljs-number">2.1</span><br>    frame #<span class="hljs-number">0</span>: <span class="hljs-number">0x000000010740f897</span> TestXX`__29-[ViewController viewDidLoad]_block_invoke(.block_descriptor=<span class="hljs-number">0x00006000035faca0</span>) at ViewController.m:<span class="hljs-number">81</span>:<span class="hljs-number">13</span><br>    frame #<span class="hljs-number">1</span>: <span class="hljs-number">0x00000001076847ec</span> libdispatch.dylib`_dispatch_call_block_and_release + <span class="hljs-number">12</span><br>    frame #<span class="hljs-number">2</span>: <span class="hljs-number">0x00000001076859c8</span> libdispatch.dylib`_dispatch_client_callout + <span class="hljs-number">8</span><br>  * frame #<span class="hljs-number">3</span>: <span class="hljs-number">0x0000000107693e75</span> libdispatch.dylib`_dispatch_main_queue_callback_4CF + <span class="hljs-number">1152</span><br>    frame #<span class="hljs-number">4</span>: <span class="hljs-number">0x00007fff2038fdbb</span> CoreFoundation`__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + <span class="hljs-number">9</span><br>    frame #<span class="hljs-number">5</span>: <span class="hljs-number">0x00007fff2038a63e</span> CoreFoundation`__CFRunLoopRun + <span class="hljs-number">2685</span><br>    frame #<span class="hljs-number">6</span>: <span class="hljs-number">0x00007fff203896d6</span> CoreFoundation`CFRunLoopRunSpecific + <span class="hljs-number">567</span><br>    frame #<span class="hljs-number">7</span>: <span class="hljs-number">0x00007fff2c257db3</span> GraphicsServices`GSEventRunModal + <span class="hljs-number">139</span><br>    frame #<span class="hljs-number">8</span>: <span class="hljs-number">0x00007fff24696cf7</span> UIKitCore`-[UIApplication _run] + <span class="hljs-number">912</span><br>    frame #<span class="hljs-number">9</span>: <span class="hljs-number">0x00007fff2469bba8</span> UIKitCore`UIApplicationMain + <span class="hljs-number">101</span><br>    frame #<span class="hljs-number">10</span>: <span class="hljs-number">0x000000010740feb2</span> TestXX`<span class="hljs-built_in">main</span>(argc=<span class="hljs-number">1</span>, argv=<span class="hljs-number">0x00007ffee87efea8</span>) at main.m:<span class="hljs-number">17</span>:<span class="hljs-number">12</span><br>    frame #<span class="hljs-number">11</span>: <span class="hljs-number">0x00007fff2025a3e9</span> libdyld.dylib`start + <span class="hljs-number">1</span><br>    frame #<span class="hljs-number">12</span>: <span class="hljs-number">0x00007fff2025a3e9</span> libdyld.dylib`start + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="global-queue的任务调度-dispatch-worker-thread2"><a href="#global-queue的任务调度-dispatch-worker-thread2" class="headerlink" title="global queue的任务调度_dispatch_worker_thread2"></a>global queue的任务调度_dispatch_worker_thread2</h3><p>global queue通过_dispatch_queue_wakeup_global函数，将任务入queue，让后调用_dispatch_worker_thread2进行处理任务</p><p>在_dispatch_worker_thread2中有两个函数比较重要：</p><ul><li>_dispatch_queue_concurrent_drain_one</li><li>_dispatch_continuation_pop</li></ul><h4 id="dispatch-queue-concurrent-drain-one"><a href="#dispatch-queue-concurrent-drain-one" class="headerlink" title="_dispatch_queue_concurrent_drain_one"></a>_dispatch_queue_concurrent_drain_one</h4><p>该函数的重要作用：</p><ul><li>多线程下的边界处理</li><li>获取出队的dc</li><li>再次唤醒global queue<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_object_s</span> *<br>_dispatch_queue_concurrent_drain_one(<span class="hljs-type">dispatch_queue_t</span> dq) &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dispatch_object_s</span> *head, *next, *<span class="hljs-type">const</span> mediator = (<span class="hljs-type">void</span> *)~<span class="hljs-number">0ul</span>;<br><br><span class="hljs-comment">// The mediator value acts both as a &quot;lock&quot; and a signal</span><br>head = <span class="hljs-built_in">dispatch_atomic_xchg2o</span>(dq, dq_items_head, mediator);<br><br><span class="hljs-comment">// 1. 检查队列是否为空，是返回NULL</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(head == <span class="hljs-literal">NULL</span>)) &#123;<br>(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_atomic_cmpxchg2o</span>(dq, dq_items_head, mediator, <span class="hljs-literal">NULL</span>);<br>_dispatch_debug(<span class="hljs-string">&quot;no work on global work queue&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(head == mediator)) &#123;<br><span class="hljs-comment">// 该线程在现线程竞争中失去了对队列的拥有权，这意味着libdispatch的效率很糟糕，</span><br><span class="hljs-comment">// 这种情况意味着在线程池中有太多的线程，这个时候应该创建一个pengding线程，</span><br><span class="hljs-comment">// 然后退出该线程，内核会在负载减弱的时候创建一个新的线程</span><br>_dispatch_debug(<span class="hljs-string">&quot;Contention on queue: %p&quot;</span>, dq);<br>_dispatch_queue_wakeup_global(dq);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DISPATCH_PERF_MON</span><br><span class="hljs-built_in">dispatch_atomic_inc</span>(&amp;_dispatch_bad_ratio);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// 在返回之前将head指针的do_next保存下来，如果next为NULL，这意味着item是最后一个</span><br>next = <span class="hljs-built_in">fastpath</span>(head-&gt;do_next);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(!next)) &#123;<br>dq-&gt;dq_items_head = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">dispatch_atomic_cmpxchg2o</span>(dq, dq_items_tail, head, <span class="hljs-literal">NULL</span>)) &#123;<br><span class="hljs-comment">// head和tail头尾指针均为空</span><br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><br><span class="hljs-comment">// 此时一定有item，该线程不会等待太久。</span><br><span class="hljs-keyword">while</span> (!(next = head-&gt;do_next)) &#123;<br>_dispatch_hardware_pause();<br>&#125;<br>&#125;<br><br>dq-&gt;dq_items_head = next;<br><span class="hljs-comment">// 再次唤醒全局队列</span><br>_dispatch_queue_wakeup_global(dq);<br>out:<br><span class="hljs-comment">// 返回需要处理的dc</span><br><span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>这里再次调用_dispatch_queue_wakeup_global,我们知道，并发queue中的dc执行是并发的，所以每次出队dc后检查下global queue，是否还有dc在queue中。如果有，在再次通知需要再创建一个work queue处理queue中剩余的dc，然后重复上面的步骤，类似递归。当多个work queue同时处理多个dc的时候，就是异步效果。</li></ul><h4 id="dispatch-continuation-pop"><a href="#dispatch-continuation-pop" class="headerlink" title="_dispatch_continuation_pop"></a>_dispatch_continuation_pop</h4><p>该函数实现了对任务处理，这些任务可能是异步任务、group任务、barrier任务甚至queue。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span><br>_dispatch_continuation_pop(<span class="hljs-type">dispatch_object_t</span> dou) &#123;<br><span class="hljs-type">dispatch_continuation_t</span> dc = dou._dc;<br><span class="hljs-type">dispatch_group_t</span> dg;<br><br>_dispatch_trace_continuation_pop(_dispatch_queue_get_current(), dou);<br><span class="hljs-comment">// 检测是不是队列，如果是，就进入_dispatch_queue_invoke处理队列</span><br><span class="hljs-comment">// dispatch_barrier_async的任务会进入以下分支，以保证barrier任务和其他任务隔离，</span><br><span class="hljs-comment">// 并通过dispath_semaphore_t实现通知barrier任务执行</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DISPATCH_OBJ_IS_VTABLE</span>(dou._do)) &#123;<br><span class="hljs-keyword">return</span> _dispatch_queue_invoke(dou._dq);<br>&#125;<br><br><span class="hljs-comment">// Add the item back to the cache before calling the function. This</span><br><span class="hljs-comment">// allows the &#x27;hot&#x27; continuation to be used for a quick callback.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The ccache version is per-thread.</span><br><span class="hljs-comment">// Therefore, the object has not been reused yet.</span><br><span class="hljs-comment">// This generates better assembly.</span><br><span class="hljs-comment">// 是否是异步任务</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>)dc-&gt;do_vtable &amp; DISPATCH_OBJ_ASYNC_BIT) &#123;<br>_dispatch_continuation_free(dc);<br>&#125;<br><br><span class="hljs-comment">// 判断是否是group任务</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>)dc-&gt;do_vtable &amp; DISPATCH_OBJ_GROUP_BIT) &#123;<br>dg = dc-&gt;dc_group;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>dg = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// 是任务封装的dispatch_continuation_t结构体（dc），直接执行任务。</span><br><span class="hljs-comment">// 这也是异步的block被调用的时机</span><br>_dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);<br><span class="hljs-keyword">if</span> (dg) &#123;<br><span class="hljs-comment">// 如果是group执行dispatch_group_leave</span><br><span class="hljs-built_in">dispatch_group_leave</span>(dg);<br>_dispatch_release(dg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="dispatch-queue-invoke"><a href="#dispatch-queue-invoke" class="headerlink" title="_dispatch_queue_invoke"></a>_dispatch_queue_invoke</h4><p>该函数用于异步处理任务，并且任务本身是queue时调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">void</span><br>_dispatch_queue_invoke(<span class="hljs-type">dispatch_queue_t</span> dq) &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">slowpath</span>(<span class="hljs-built_in">DISPATCH_OBJECT_SUSPENDED</span>(dq)) &amp;&amp;<br><span class="hljs-built_in">fastpath</span>(<span class="hljs-built_in">dispatch_atomic_cmpxchg2o</span>(dq, dq_running, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>))) &#123;<br><span class="hljs-built_in">dispatch_atomic_acquire_barrier</span>();<br><span class="hljs-type">dispatch_queue_t</span> otq = dq-&gt;do_targetq, tq = <span class="hljs-literal">NULL</span>;<br>_dispatch_queue_drain(dq);<br><span class="hljs-keyword">if</span> (dq-&gt;do_vtable-&gt;do_invoke) &#123;<br><span class="hljs-comment">// Assume that object invoke checks it is executing on correct queue</span><br>tq = <span class="hljs-built_in">dx_invoke</span>(dq);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">slowpath</span>(otq != dq-&gt;do_targetq)) &#123;<br><span class="hljs-comment">// An item on the queue changed the target queue</span><br>tq = dq-&gt;do_targetq;<br>&#125;<br><span class="hljs-comment">// We do not need to check the result.</span><br><span class="hljs-comment">// When the suspend-count lock is dropped, then the check will happen.</span><br><span class="hljs-built_in">dispatch_atomic_release_barrier</span>();<br><span class="hljs-comment">//dq_running减1，因为任务要么被直接执行了，要么被压到target队列了</span><br>(<span class="hljs-type">void</span>)<span class="hljs-built_in">dispatch_atomic_dec2o</span>(dq, dq_running);<br><span class="hljs-keyword">if</span> (tq) &#123;<br><span class="hljs-keyword">return</span> _dispatch_queue_push(tq, dq);<br>&#125;<br>&#125;<br><br>dq-&gt;do_next = DISPATCH_OBJECT_LISTLESS;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dispatch_atomic_sub2o</span>(dq, do_suspend_cnt,<br>DISPATCH_OBJECT_SUSPEND_LOCK)) &#123;<br><span class="hljs-comment">// 队列处于空闲状态，需要唤醒</span><br><span class="hljs-keyword">if</span> (dq-&gt;dq_running == <span class="hljs-number">0</span>) &#123;<br>_dispatch_wakeup(dq); <span class="hljs-comment">// verify that the queue is idle</span><br>&#125;<br>&#125;<br><span class="hljs-comment">// 释放队列</span><br>_dispatch_release(dq); <span class="hljs-comment">// added when the queue is put on the list</span><br>&#125;<br></code></pre></td></tr></table></figure><p>整理下上述流程<br><img src="/../images/image-46.png" alt="Alt text"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>queue和线程是多对1关系，一个线程上可以执行不同queue的任务，即使是主线程也如此，即主线程不仅能执行main queue的任务，也能执行其他queue的任务</li><li>queue操作与开启线程的关系<ul><li>串行queue+sync：任务在当前线程执行，并且等待之前任务执行，并且阻塞当前线程</li><li>串行queue+async：任务在新线程执行，不阻塞当前线程，任务在新线程上串行执行</li><li>并发queue+sync：任务在当前线程执行，阻塞当前线程</li><li>并发queue+async：开启多个线程，任务在新线程上执行，数量由系统决定，任务无序执行</li><li>主线程+main queue+sync：死锁，因为sync阻塞当前线程，主线程进入wait，此时调用sync的操作永远无法执行完毕，因为主线程永远不会被唤醒，从而死锁</li><li>main queue+async：任务在主线程串行执行</li></ul></li><li>queue的sync不具备开启线程能力，async才能开启新线程，串行&amp;并发决定了处理线程是否有多个</li><li>dispatch_queue通过struct和链表，实现为fifo的队列，无论串行queue还是并发queue，在调度时都是按顺序获取，主要区别在于：执行的顺序&amp;开启线程的数量</li><li>dispatch_sync:在当前线程执行，利用信号量实现串行</li><li>dispatch_async:<ul><li>若是main queue，则唤醒后执行runloop，然后调用gcd处理</li><li>若是其他queue：由线程池处理</li></ul></li><li>传递的block不是直接添加到queue上，而是封装为dispatch_continuation。dc包含了block还有上下文信息。queue会将dc添加链表中。无论queue是什么类型，最终的target都是global queue。在global queue执行block时，gcd从global queue取出dc，调用pthread_workqueue_additem_np，将该global queue自身，符合其优先级的workqueue和dc的回调函数进行传递。pthread_workqueue_additem_np函数使用workq_kernreturn系统调用，通知workqueue增加执行项目。而根据该通知，XNU kernel基于系统状态判断是否要生成线程，如果是overcommit的global queue，则始终生成线程。workqueue的新城执行pthread_workqueue函数，该函数调用gcd传递的回到函数，该函数中最终执行封装到dc中的block</li><li>gcd死锁是queue导致而不是线程导致，是因为_dispatch_barrier_sync_f_slow使用了线程对应的信号量，并进行wait，从而让线程等待，而又没有时机唤醒</li><li>关于barrier函数：<ul><li>dispatch_barrier_async的queue必须是由DISPATCH_QUEUE_CONCURRENT创建的queue</li><li>如果使用global queue，则表现的和dispatch_async一样</li><li>原因：<ul><li>若是global queue，则唤醒queue时执行_dispatch_queue_wakeup_global，则和dispatch_async一样</li><li>若是自定义queue：_dispatch_continuation_pop会执行dispatch_queue_invoke，在while循环中依次取出任务并调用_dispatch_continuation_redirect，使得任务并发执行；遇到DISPATCH_OBJ_BARRIER_BIT标记时，修改do_suspend_cnt保证后续while循环时直接go out。当barrier block的任务执行完，_dispatch_queue_class_invoke将do_suspend_cnt重置，允许barrier之后的任务执行</li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>GCD</tag>
      
      <tag>Dispatch Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再谈OC Block原理</title>
    <link href="/2024/02/20/think-about-oc-block-again/"/>
    <url>/2024/02/20/think-about-oc-block-again/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前已经学习过OC Block的底层原理，这里再次巩固下</p><h2 id="Block的实质"><a href="#Block的实质" class="headerlink" title="Block的实质"></a>Block的实质</h2><p>如下是一个基础的Block使用</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * argv[]) &#123;<br>    <span class="hljs-type">void</span> (^testBlock)(<span class="hljs-type">void</span>) = ^&#123;<br>        printf(<span class="hljs-string">&quot;asddasd&quot;</span>);<br>    &#125;;<br>    testBlock();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过如下xcrun指令，可以将其翻译为C++代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">xcrun -sdk iphoneos clang -<span class="hljs-built_in">arch</span> arm64 -rewrite-objc main.m<br></code></pre></td></tr></table></figure><p>翻译后代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span> </span>&#123;<br>    <span class="hljs-built_in">void</span> (*testBlock)(<span class="hljs-type">void</span>) = ((<span class="hljs-built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));<br><br>    ((<span class="hljs-built_in">void</span> (*)(__block_impl *))((__block_impl *)testBlock)-&gt;FuncPtr)((__block_impl *)testBlock);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，最后转换成了对于函数指针的调用。可以看到，我们定义的testBlock转换为了<code>&amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA)</code>,调用时，转换了testBlock-&gt;FuncPtr(testBlock)。<br><code>__main_block_impl_0</code>是个struct，相关定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__block_impl</span> &#123;<br>    <span class="hljs-type">void</span> *isa; <span class="hljs-comment">// isa是OC对象特有的标志</span><br>    <span class="hljs-type">int</span> Flags;<br>    <span class="hljs-type">int</span> Reserved;<br>    <span class="hljs-type">void</span> *FuncPtr; <span class="hljs-comment">// 该指针指向block执行函数的地址</span><br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_desc_0</span> &#123;<br>    <span class="hljs-type">size_t</span> reserved;   <span class="hljs-comment">// 预留的字段</span><br>    <span class="hljs-type">size_t</span> Block_size; <span class="hljs-comment">// block所占内存大小</span><br>&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> __main_block_impl_0)&#125;;<br><br><span class="hljs-comment">// __main_block_impl_0是一个C++结构体可以声明函数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_impl_0</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__block_impl</span> impl;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_desc_0</span>* Desc;<br>    <span class="hljs-comment">// 没有返回类型，与结构体同名的函数，这样的函数称为构造函数</span><br>    __main_block_impl_0(<span class="hljs-type">void</span> *fp, <span class="hljs-keyword">struct</span> __main_block_desc_0 *desc, <span class="hljs-type">int</span> flags=<span class="hljs-number">0</span>) &#123;<br>        impl.isa = &amp;_NSConcreteStackBlock; <span class="hljs-comment">// 初始化__block_impl结构体的isa成员变量</span><br>        impl.Flags = flags;<br>        impl.FuncPtr = fp; <span class="hljs-comment">// fp就是__main_block_func_0函数</span><br>        Desc = desc;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 该函数封装了block的执行代码</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __main_block_func_0(<span class="hljs-keyword">struct</span> __main_block_impl_0 *__cself) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;asddasd&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>__main_block_impl_0</code>有两个成员，分别是<code>__block_impl impl</code>和<code>__main_block_desc_0* Desc</code>。还有一个构造函数。当然__block_impl和__main_block_desc_0也是两个struct，上面已经有注释了，这里不再赘述。看下该struct的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">__main_block_impl_0(<span class="hljs-type">void</span> *fp, <span class="hljs-keyword">struct</span> __main_block_desc_0 *desc, <span class="hljs-type">int</span> flags=<span class="hljs-number">0</span>) &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，该struct需要传入函数指针fp和desc。而fp就是<code>__main_block_func_0</code>。isa的初始值_NSConcreteStackBlock，所以既然存在isa，Block也可以看做是OC对象，只不过其class_t是_NSConcreteStackBlock。</p><p>然后看函数调用，block的调用会被转换为对函数指针的调用，即<code>__main_block_func_0</code>的调用。</p><p>总结：<code>Block的本质可以看做是OC对象（有isa），Block的调用就是函数指针的调用</code>。</p><h2 id="Block对自动变量值的捕获"><a href="#Block对自动变量值的捕获" class="headerlink" title="Block对自动变量值的捕获"></a>Block对自动变量值的捕获</h2><p>在之前，我们知道所谓捕获自动变量，实际上变量将会被转换为struct，并保存到Block对应的struct中。不同类型的变量的捕获过程会略有区别，如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 静态全局变量</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> globalStaticValue = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 全局变量</span><br><span class="hljs-type">int</span> globalValue = <span class="hljs-number">2</span>;<br><br><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[]) &#123;<br>    <span class="hljs-comment">// 局部变量</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;<br>    <br>    <span class="hljs-comment">// 静态局部变量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> b = <span class="hljs-number">4</span>;<br>    <br>    <span class="hljs-type">void</span> (^testBlock)(<span class="hljs-type">void</span>) = ^&#123;<br>        printf(<span class="hljs-string">&quot;%d&quot;</span>, globalStaticValue);<br>        printf(<span class="hljs-string">&quot;%d&quot;</span>, globalValue);<br>        printf(<span class="hljs-string">&quot;%d&quot;</span>, a);<br>        printf(<span class="hljs-string">&quot;%d&quot;</span>, b);<br>    &#125;;<br>    <br>    testBlock();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们仍然将其转换为C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 静态全局变量</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> globalStaticValue = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 全局变量</span><br><span class="hljs-type">int</span> globalValue = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_impl_0</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__block_impl</span> impl;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_desc_0</span>* Desc;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> *b;<br>    __main_block_impl_0(<span class="hljs-type">void</span> *fp, <span class="hljs-keyword">struct</span> __main_block_desc_0 *desc, <span class="hljs-type">int</span> _a, <span class="hljs-type">int</span> *_b, <span class="hljs-type">int</span> flags=<span class="hljs-number">0</span>) : <span class="hljs-built_in">a</span>(_a), <span class="hljs-built_in">b</span>(_b) &#123;<br>        impl.isa = &amp;_NSConcreteStackBlock;<br>        impl.Flags = flags;<br>        impl.FuncPtr = fp;<br>        Desc = desc;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __main_block_func_0(<span class="hljs-keyword">struct</span> __main_block_impl_0 *__cself) &#123;<br>    <span class="hljs-comment">// 局部变量，直接被copy封装到了Block中</span><br>    <span class="hljs-type">int</span> a = __cself-&gt;a; <span class="hljs-comment">// bound by copy</span><br><br>    <span class="hljs-comment">// 静态局部变量，copy其指针放到了Block中</span><br>    <span class="hljs-type">int</span> *b = __cself-&gt;b; <span class="hljs-comment">// bound by copy</span><br>    <br>    <span class="hljs-comment">// 全局变量（包括静态全局变量）直接使用，不做封装</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, globalStaticValue);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, globalValue);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, (*b));<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_desc_0</span> &#123;<br>    <span class="hljs-type">size_t</span> reserved;<br>    <span class="hljs-type">size_t</span> Block_size;<br>&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> __main_block_impl_0)&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span> </span>&#123;<br>    <span class="hljs-comment">// 局部变量</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;<br>    <br>    <span class="hljs-comment">// 静态局部变量</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> b = <span class="hljs-number">4</span>;<br>    <br>    <span class="hljs-built_in">void</span> (*testBlock)(<span class="hljs-type">void</span>) = ((<span class="hljs-built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a, &amp;b));<br>    <br>    ((<span class="hljs-built_in">void</span> (*)(__block_impl *))((__block_impl *)testBlock)-&gt;FuncPtr)((__block_impl *)testBlock);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的代码可以看出：<br>    - 局部普通变量会被block copy封装<br>    - 局部静态变量会被block copy其指针，通过指针访问<br>    - 全局普通变量和全局静态变量不会被封装，而是直接使用（实际上也没必要封装，在哪都能访问）</p><h2 id="Block对OC对象指针变量的捕获"><a href="#Block对OC对象指针变量的捕获" class="headerlink" title="Block对OC对象指针变量的捕获"></a>Block对OC对象指针变量的捕获</h2><p>仍然上代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-comment">// 静态全局对象</span><br><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSObject</span> *globalObjc;<br><br><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[]) &#123; <br>    <span class="hljs-comment">// 局部对象，且strong   </span><br>    <span class="hljs-built_in">NSObject</span> *object = [[<span class="hljs-built_in">NSObject</span> alloc] init];<br><br>    <span class="hljs-comment">// 局部对象，且weak</span><br>    __<span class="hljs-keyword">weak</span> <span class="hljs-built_in">NSObject</span> *weakObject = object;<br>    <br>    <span class="hljs-type">void</span> (^testBlock)(<span class="hljs-type">void</span>) = ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, object);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, weakObject);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, globalObjc);<br>    &#125;;<br>    <br>    testBlock();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用命令行转化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">xcrun -sdk iphoneos clang -<span class="hljs-built_in">arch</span> arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m<br></code></pre></td></tr></table></figure><p>转化后的C++代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> NSObject *globalObjc;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_impl_0</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__block_impl</span> impl;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_desc_0</span>* Desc;<br>    <span class="hljs-comment">// 捕获了对象指针及其所有权修饰符</span><br>    NSObject *__strong object;<br>    NSObject *__weak weakObject;<br>    __main_block_impl_0(<span class="hljs-type">void</span> *fp, <span class="hljs-keyword">struct</span> __main_block_desc_0 *desc, NSObject *__strong _object, NSObject *__weak _weakObject, <span class="hljs-type">int</span> flags=<span class="hljs-number">0</span>) : <span class="hljs-built_in">object</span>(_object), <span class="hljs-built_in">weakObject</span>(_weakObject) &#123;<br>        impl.isa = &amp;_NSConcreteStackBlock;<br>        impl.Flags = flags;<br>        impl.FuncPtr = fp;<br>        Desc = desc;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __main_block_func_0(<span class="hljs-keyword">struct</span> __main_block_impl_0 *__cself) &#123;<br>    <span class="hljs-comment">// 局部对象，且strong，通过捕获的指针访问</span><br>    NSObject *__strong object = __cself-&gt;object; <span class="hljs-comment">// bound by copy</span><br><br>    <span class="hljs-comment">// 局部对象，且weak，通过捕获的指针访问</span><br>    NSObject *__weak weakObject = __cself-&gt;weakObject; <span class="hljs-comment">// bound by copy</span><br>    <br>    <span class="hljs-built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_2p_n_j9tbqx6lqb2bqv110q6d300000gn_T_main_a7d9fa_mi_0, object);<br>    <span class="hljs-built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_2p_n_j9tbqx6lqb2bqv110q6d300000gn_T_main_a7d9fa_mi_1, weakObject);<br>    <span class="hljs-comment">// 全局对象，直接使用</span><br>    <span class="hljs-built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_2p_n_j9tbqx6lqb2bqv110q6d300000gn_T_main_a7d9fa_mi_2, globalObjc);<br>&#125;<br><br><span class="hljs-comment">// 对block进行copy时调用</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __main_block_copy_0(<span class="hljs-keyword">struct</span> __main_block_impl_0*dst, <span class="hljs-keyword">struct</span> __main_block_impl_0*src) &#123;<br>    <span class="hljs-comment">// 该函数根据所有权类型产生强引用或者弱引用</span><br>    _Block_object_assign((<span class="hljs-type">void</span>*)&amp;dst-&gt;object, (<span class="hljs-type">void</span>*)src-&gt;object, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);<br>    _Block_object_assign((<span class="hljs-type">void</span>*)&amp;dst-&gt;weakObject, (<span class="hljs-type">void</span>*)src-&gt;weakObject, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);<br>&#125;<br><br><span class="hljs-comment">// block从对中移除时调用</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __main_block_dispose_0(<span class="hljs-keyword">struct</span> __main_block_impl_0*src) &#123;<br>    <span class="hljs-comment">// 该函数释放引用</span><br>    _Block_object_dispose((<span class="hljs-type">void</span>*)src-&gt;object, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);<br>    _Block_object_dispose((<span class="hljs-type">void</span>*)src-&gt;weakObject, <span class="hljs-number">3</span><span class="hljs-comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_desc_0</span> &#123;<br>    <span class="hljs-type">size_t</span> reserved;<br>    <span class="hljs-type">size_t</span> Block_size;<br>    <span class="hljs-built_in">void</span> (*copy)(<span class="hljs-keyword">struct</span> __main_block_impl_0*, <span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>    <span class="hljs-built_in">void</span> (*dispose)(<span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span> </span>&#123;<br>    NSObject *object = ((NSObject *(*)(id, SEL))(<span class="hljs-type">void</span> *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(<span class="hljs-type">void</span> *)objc_msgSend)((id)<span class="hljs-built_in">objc_getClass</span>(<span class="hljs-string">&quot;NSObject&quot;</span>), <span class="hljs-built_in">sel_registerName</span>(<span class="hljs-string">&quot;alloc&quot;</span>)), <span class="hljs-built_in">sel_registerName</span>(<span class="hljs-string">&quot;init&quot;</span>));<br>    __attribute__((<span class="hljs-built_in">objc_ownership</span>(weak))) NSObject *weakObject = object;<br><br>    <span class="hljs-built_in">void</span> (*testBlock)(<span class="hljs-type">void</span>) = ((<span class="hljs-built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, object, weakObject, <span class="hljs-number">570425344</span>));<br><br>    ((<span class="hljs-built_in">void</span> (*)(__block_impl *))((__block_impl *)testBlock)-&gt;FuncPtr)((__block_impl *)testBlock);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果捕获的变量是OC对象，则将对象和所有权修饰符一并捕获。对捕获对象的增加或减少引用，通过内置函数实现。<br>注意，上面的代码只是改写成C++的表示，但是具体执行，比如对于weak、strong的使用，仍然需要利用到OC Runtime的支持（引用计数、weak表以及对应ARC管理机制）。比如在使用weak对象时，仍然需要通过<code>objc_loadWeakRetained</code>来使用，这和不使用Block时是一样的。</p><h2 id="block修饰符"><a href="#block修饰符" class="headerlink" title="__block修饰符"></a>__block修饰符</h2><p>我们知道，当我们需要通过修改Block捕获的局部变量进行赋值时，就需要使用该修饰符，上代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[]) &#123;<br>    __block <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">void</span> (^testBlock)(<span class="hljs-type">void</span>) = ^&#123;<br>        a = <span class="hljs-number">100</span>;<br>        printf(<span class="hljs-string">&quot;%d&quot;</span>, a);<br>    &#125;;<br>    testBlock();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换为C++代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 可见，一个简单的局部变量，因为通过__block修饰，被改写为了一个struct</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__Block_byref_a_0</span> &#123;<br>    <span class="hljs-type">void</span> *__isa;<br>    __Block_byref_a_0 *__forwarding;<br>    <span class="hljs-type">int</span> __flags;<br>    <span class="hljs-type">int</span> __size;<br>    <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_impl_0</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__block_impl</span> impl;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_desc_0</span>* Desc;<br>    __Block_byref_a_0 *a; <span class="hljs-comment">// by ref</span><br>    __main_block_impl_0(<span class="hljs-type">void</span> *fp, <span class="hljs-keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_a_0 *_a, <span class="hljs-type">int</span> flags=<span class="hljs-number">0</span>) : <span class="hljs-built_in">a</span>(_a-&gt;__forwarding) &#123;<br>        impl.isa = &amp;_NSConcreteStackBlock;<br>        impl.Flags = flags;<br>        impl.FuncPtr = fp;<br>        Desc = desc;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在block的struct中，多了一个<code>__Block_byref_a_0 *a</code>，该struct也有一个isa，所以也可以被当做是OC对象，另外还有一个forwarding指针，在之前，我们知道，该指针是为了方便Block从栈copy到堆时能够指向堆上的ref。</p><p>主要函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __main_block_copy_0(<span class="hljs-keyword">struct</span> __main_block_impl_0*dst, <span class="hljs-keyword">struct</span> __main_block_impl_0*src) &#123;<br>    _Block_object_assign((<span class="hljs-type">void</span>*)&amp;dst-&gt;a, (<span class="hljs-type">void</span>*)src-&gt;a, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __main_block_dispose_0(<span class="hljs-keyword">struct</span> __main_block_impl_0*src) &#123;<br>    _Block_object_dispose((<span class="hljs-type">void</span>*)src-&gt;a, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_desc_0</span> &#123;<br>    <span class="hljs-type">size_t</span> reserved;<br>    <span class="hljs-type">size_t</span> Block_size;<br>    <span class="hljs-built_in">void</span> (*copy)(<span class="hljs-keyword">struct</span> __main_block_impl_0*, <span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>    <span class="hljs-built_in">void</span> (*dispose)(<span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span> </span>&#123;<br>    <span class="hljs-comment">// 可以看出，转换后的ref的fowarding指针初始时就是ref本身</span><br>    __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>,(__Block_byref_a_0 *)&amp;a, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(__Block_byref_a_0), <span class="hljs-number">1</span>&#125;;<br>    <br>    <span class="hljs-built_in">void</span> (*testBlock)(<span class="hljs-type">void</span>) = ((<span class="hljs-built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, <span class="hljs-number">570425344</span>));<br>    <br>    ((<span class="hljs-built_in">void</span> (*)(__block_impl *))((__block_impl *)testBlock)-&gt;FuncPtr)((__block_impl *)testBlock);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，__block变量转换为了ref结构体，该结构体的forward指针初始时指向自身，如图所示：<br><img src="/../images/image-40.png" alt="Alt text"></p><p>最后，block在访问__block变量时，是通过forwarding指针获取到的。</p><p>__block的本质：<code>将变量改写封装到struct中，通过修改struct中的成员实现修改值</code>。</p><h2 id="Block存储域"><a href="#Block存储域" class="headerlink" title="Block存储域"></a>Block存储域</h2><p>前面也了解过，Block会存在于栈或者堆，有三种类型：<br><img src="/../images/image-41.png" alt="Alt text"><br>如何确定block的类型？可以在MRC环境下进行测试（因为ARC下可能会对Block自动copy），代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[]) &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">// block1，访问了局部变量，在stack</span><br>    <span class="hljs-type">void</span> (^block1)(<span class="hljs-type">void</span>) = ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s - %d&quot;</span>, __func__, a);<br>    &#125;;<br>    <br>    <span class="hljs-comment">// block2，没有访问局部变量，是global</span><br>    <span class="hljs-type">void</span> (^block2)(<span class="hljs-type">void</span>) = ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br>    &#125;;<br>    <br>    <span class="hljs-comment">// block3，对block1进行copy，是malloc</span><br>    <span class="hljs-type">void</span> (^block3)(<span class="hljs-type">void</span>) = [block1 <span class="hljs-keyword">copy</span>];<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@ %@ %@&quot;</span>, [block1 <span class="hljs-keyword">class</span>], [block2 <span class="hljs-keyword">class</span>], [block3 <span class="hljs-keyword">class</span>]);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>copy操作对不同类型block的影响：</p><ul><li>stack -&gt; malloc</li><li>global -&gt; do nothing</li><li>malloc -&gt; 增加引用计数</li></ul><p>在ARC情况下，编译器会自动copy，比如：</p><ul><li>block作为返回值</li><li>block是strong的</li><li>block作为cocoa的usingBlock的参数时</li><li>block作为gcd的参数时</li></ul><h2 id="block变量的存储区域"><a href="#block变量的存储区域" class="headerlink" title="__block变量的存储区域"></a>__block变量的存储区域</h2><p><img src="/../images/image-42.png" alt="Alt text"><br>既然__block对应的struct是Block内部使用，那么Block需要维护__block的生命周期，可以看转换后的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 对block进行copy时调用</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __main_block_copy_0(<span class="hljs-keyword">struct</span> __main_block_impl_0*dst, <span class="hljs-keyword">struct</span> __main_block_impl_0*src) &#123;<br>    <span class="hljs-comment">// assign函数对__block变量生成强引用</span><br>    _Block_object_assign((<span class="hljs-type">void</span>*)&amp;dst-&gt;a, (<span class="hljs-type">void</span>*)src-&gt;a, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);<br>&#125;<br><br><span class="hljs-comment">// block从堆移除时</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __main_block_dispose_0(<span class="hljs-keyword">struct</span> __main_block_impl_0*src) &#123;<br>    <span class="hljs-comment">// dispose函数释放对__block变量的引用</span><br>    _Block_object_dispose((<span class="hljs-type">void</span>*)src-&gt;a, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_desc_0</span> &#123;<br>    <span class="hljs-type">size_t</span> reserved;<br>    <span class="hljs-type">size_t</span> Block_size;<br>    <span class="hljs-built_in">void</span> (*copy)(<span class="hljs-keyword">struct</span> __main_block_impl_0*, <span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>    <span class="hljs-built_in">void</span> (*dispose)(<span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span> </span>&#123;<br>    __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>,(__Block_byref_a_0 *)&amp;a, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(__Block_byref_a_0), <span class="hljs-number">1</span>&#125;;<br>    <br>    <span class="hljs-built_in">void</span> (*testBlock)(<span class="hljs-type">void</span>) = ((<span class="hljs-built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, <span class="hljs-number">570425344</span>));<br>    <br>    ((<span class="hljs-built_in">void</span> (*)(__block_impl *))((__block_impl *)testBlock)-&gt;FuncPtr)((__block_impl *)testBlock);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在copy和从堆上销毁block时，block内部会调用函数来维护对__block变量的引用计数。但是，<strong>如果block在栈上，并不会对__block变量产生引用</strong>（个人理解：因为栈上的block在作用域结束之后自动销毁，所以没必要进行引用）</p><p>在回忆下forwarding指针的作用，这是为了保证，无论block位于栈还是被copy到了堆，这些block都能够正确访问同一个ref结构体</p><h2 id="Block的循环引用"><a href="#Block的循环引用" class="headerlink" title="Block的循环引用"></a>Block的循环引用</h2><p>略</p><h2 id="面试题，如何Hook-Block的执行"><a href="#面试题，如何Hook-Block的执行" class="headerlink" title="面试题，如何Hook Block的执行"></a>面试题，如何Hook Block的执行</h2><p>通过参考官方源码，将block参数转换为struct，并修改其funcPtr</p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>OC</tag>
      
      <tag>Block</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mach内核</title>
    <link href="/2024/02/19/learn-about-mach-kernel/"/>
    <url>/2024/02/19/learn-about-mach-kernel/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>年过完啦，继续总结，先过渡下，回忆下Mach内核吧~Mach内核是OS X是iOS的核心中的核心，提供了线程调度、内存管理、硬件管理、IPC等重要功能</p><h2 id="OS-X系统"><a href="#OS-X系统" class="headerlink" title="OS X系统"></a>OS X系统</h2><ul><li>初代Apple使用的Mac OS和现在的OS X是不同的，初代Mac OS最后一代是Mac OS 9，终结于2001年</li><li>现在的OS X基于NeXTSTEP OS，于2001年正式接任</li><li>app bundle额interface builder的概念来自于NeXTSTEP，并且提供了Drive Kit用于驱动开发，后来被放到了IO Kit中</li><li>iOS派生自OS X，于2007年发布</li><li>NeXTSTEP是乔布斯在离开Apple之后创办了NeXT公司开发的</li><li>OS X和iOS的核心部分被称为Darwin，包含了XNU kernel和Unix基础</li><li>Darwin是开源的，但不含图形界面，并且没有官方ARM架构支持</li><li>XNU kernel是个混合kernel，包含Mach kernel和部分BSD</li><li>Carbon和Java都被OS X废弃，Carbon在Cocoa在功能上有重叠，在iOS上已经移除</li><li>graphic框架的核心是Quartz，其整合了Quartz Compositor（窗口组合）和Quartz 2D，其基于PDF模型，提供设备无关的分辨率，并可以使用OpenGL进行加速</li><li>OS X10.5首次支持64位Cocoa，10.6版本支持kernel以64位运行</li><li>OS X架构如下<br><img src="/../images/image-33.png" alt="Alt text"></li></ul><h2 id="XNU-kernel"><a href="#XNU-kernel" class="headerlink" title="XNU kernel"></a>XNU kernel</h2><ul><li>XNU是个混合kernel，包含BSD、Mach、IO Kit，实际上，有时这些layer的边界是模糊的，其架构如下：<br><img src="/../images/image-36.png" alt="Alt text"></li><li>KEXTs即kernel扩展，kernel扩展用于动态加载代码到kernel空间，从而可以编写驱动或者实现其他kernel功能，例如实现新的文件系统</li><li>KEXTs一般有两类：<ul><li>基于IO Kit，使用c++编写</li><li>基于通用kernel扩展，使用c编写</li></ul></li><li>XNU的最核心的部分是Mach，Mach为IOKit和BSD提供了硬件抽象、内存管理、线程调度、IPC</li><li>在Mach中，所谓Task，可以对应到Unix中的进程，Thread就是线程。Mach层面，Thread调度是独立，但是BSD层可以感知Thread属于哪个Task，以及进程之间的父子关系</li><li>XNU调度线程支持优先级，优先级如下：<br><img src="/../images/image-35.png" alt="Alt text"></li><li>XNU以双向链表的方式组织thread，每个优先级都有自己的链表，链表的集合被称为run queue，每个cpu的core都维护自己的run queue<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run_queue</span> &#123;</span><br><span class="hljs-type">int</span> highq; <span class="hljs-comment">/* highest runnable queue */</span><br><span class="hljs-type">int</span> bitmap[NRQBM]; <span class="hljs-comment">/* run queue bitmap array */</span><br><span class="hljs-type">int</span> count; <span class="hljs-comment">/* # of threads total */</span><br><span class="hljs-type">int</span> urgency; <span class="hljs-comment">/* level of preemption urgency */</span><br><span class="hljs-type">queue_head_t</span> queues[NRQS]; <span class="hljs-comment">/* one for each priority */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>Mach中的IPC，通过Port和Message<ul><li>Port类似于UDP协议，但是不局限于数据传输，而是可以提供同步、发送通知</li><li>Port使用message queue实现，一个port只能有一个sender，但是可以有多个receiver</li><li>每个Port需要有对应的right才能访问，同一个task中的thread共享Port的right，但是父子task的right不会继承</li><li>Port的right类型如下：<br>  <img src="/../images/image-37.png" alt="Alt text"></li><li>一组Port被称为Port Set，他们共享message queue，Port使用32位整数表示，并且没有全局注册表</li><li>在用户空间也是可以使用Mach IPC的，在一定程度上能代替system call，虽然最后也是通过system call调用</li></ul></li><li>Mach的Exception分为错误和正常，征程包含缺页、断点、系统调用（这在linux上被称为中断）<ul><li>Exception类型如下<br>  <img src="/../images/image-38.png" alt="Alt text"></li><li>当Exeption发生时，Mach会首先通过IPC Port将其发给引发Exception的thread，thread若无法处理交给Task，Task无法处理交给OS</li><li>Thread、Task和OS都维护了一组action，每个action用于处理一个 Exception type，如下  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">exception_action</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipc_port</span>* <span class="hljs-title">port</span>;</span> <span class="hljs-comment">/* exception port */</span><br>    <span class="hljs-type">thread_state_flavor_t</span> flavor; <span class="hljs-comment">/* state flavor to send */</span><br>    <span class="hljs-type">exception_behavior_t</span> behavior; <span class="hljs-comment">/* exception type to raise */</span><br>    <span class="hljs-type">boolean_t</span> privileged; <span class="hljs-comment">/* survives ipc_task_reset */</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li>其中flavor和behavior可以确定expcetion message和handler，handler即处理函数，可以是catch_mach_exception_raise()等。当Exception被分发后，kernel会等待replay，若返回KERN_SUCCESS意味着Thread可以继续执行</li><li>默认Thread的Exception Port是Null，默认由Task来处理。当进程使用Fork生成子进程时，子进程会继承父进程的Exception Port。XNU中的Unix的signal机制就是基于Mach的Exception机制来试下的</li></ul></li><li>XNU的Kernel地址空间和用户的Task的地址空间是独立的，而Linux的kernel地址空间和用户进程地址空间是共享的（kernel占用1GB、用户进程占用3GB，优点是无需TLB寻址，缺点是kernel地址受限），XNU和Task都各自占用4GB</li><li>XNU的虚拟内存数据结构使用了VM Map表示，VM Map代表进程的地址空间，以链表的方式串起来entry，entry在逻辑上是连续的，代表了一个region，而region则是可以合并和分割的，如下图所示<br><img src="/../images/image-39.png" alt="Alt text"></li><li>XNU源码：<br><a href="https://opensource.apple.com/">https://opensource.apple.com/</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Mach</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS KVO和KVC实现原理</title>
    <link href="/2024/01/18/think-deep-in-ios-kvc-kvo/"/>
    <url>/2024/01/18/think-deep-in-ios-kvc-kvo/</url>
    
    <content type="html"><![CDATA[<h1 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h1><p>在OC中，我们可以使用KVO机制来监听某个对象的属性值变化；swift中，一般使用属性的willSet和didSet达到类似效果，这里我们主要讨论OC的实现</p><h2 id="KVO的使用"><a href="#KVO的使用" class="headerlink" title="KVO的使用"></a>KVO的使用</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-comment">// 为receiver增加一个observer，从而监听receiver的属性变化</span><br>- (<span class="hljs-type">void</span>)addObserver:(<span class="hljs-built_in">NSObject</span> *)observer <br>         forKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath <br>            options:(<span class="hljs-built_in">NSKeyValueObservingOptions</span>)options <br>            context:(<span class="hljs-type">void</span> *)context;<br><br><span class="hljs-comment">// 在observer中实现该函数，当监听的属性发生变化时，回调该函数</span><br>- (<span class="hljs-type">void</span>)observeValueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath ofObject:(<span class="hljs-type">id</span>)object change:(<span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSKeyValueChangeKey</span>,<span class="hljs-type">id</span>&gt; *)change context:(<span class="hljs-type">void</span> *)context;<br><br><span class="hljs-comment">// 移除receiver的observer</span><br>- (<span class="hljs-type">void</span>)removeObserver:(<span class="hljs-built_in">NSObject</span> *)observer <br>            forKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath <br>               context:(<span class="hljs-type">void</span> *)context;<br></code></pre></td></tr></table></figure><h2 id="KVO实现机制"><a href="#KVO实现机制" class="headerlink" title="KVO实现机制"></a>KVO实现机制</h2><ul><li>KVO实现依赖于runtime，其基本原理是在addObserver时，runtime会动态创建一个原对象Class的子Class，然后让被监听对象的isa指向该创建的子Class，从而达到替换调用setXXX的方法效果</li><li>动态生成的Class一般叫做NSKVONotifying_KVOTestModel，并且其superClass指向被监听对象的原Class，这样，既可以替换指定的setXXX方法，又不影响调用其他方法</li><li>动态生成的Class除了替换了setXXX方法，还重写了class、dealloc等方法，这是因为系统要屏蔽内部实现细节。当然，如果我们直接用object_getClass来获取，获取到的还是派生的子Class</li><li>由于KVO是通过重写setter方法触发的，如果我们直接修改实例变量是不会触发KVO的，必须调用setXXX方法</li><li>重写的setter方法：先调用willChangeValue，然后调用原setter，最后调用didChangeValueForKey</li><li>监听属性使用的是keyPath，runtime会通过keyPath找到对应的setter并进行替换</li><li>KVO无论监听子类属性还是父类属性，都是可以的，即使子类中重写父类属性也是OK的，runtime只要找到setter方法就可以</li><li>使用block简化KVO调用：原理就是通过增加NSObject分类，添加便捷方法，将自身作为Observer去监听特定对象，当触发时，调用所有注册的block</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.neroxie.com/2019/07/12/KVO%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">https://www.neroxie.com/2019/07/12/KVO%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</a></p><h1 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h1><p>KVC允许我们通过keyPath来访问属性方法和成员变量，其工作原理依赖于搜索规则</p><h2 id="搜索规则"><a href="#搜索规则" class="headerlink" title="搜索规则"></a>搜索规则</h2><ul><li>依赖setter和getter以及accessInstanceVariablesDirectly（是否允许读取实例变量的值，默认为YES）</li><li>赋值原理：<ul><li>查找setXX，_setXX方法，找不到next</li><li>若accessInstanceVariablesDirectly为YES，则按照_XX,_isXX,XX,isXX去找实例变量，找不到next</li><li>调用setValue:forUndefinedKey<br><img src="/../images/image-32.png" alt="Alt text"></li></ul></li><li>取值原理：和赋值原理类似，但是注意<ul><li>若返回值是对象指针，则直接返回，若是基础类型且被NSNumber支持，则返回NSNumber，若不是则返回NSValue</li></ul></li><li>对于没有setXX的实例变量，KVC是否能触发KVO？讲道理是不行的，但实测可以，可能是apple自己再内部检测到了如果有KVO，则手动触发</li></ul><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.neroxie.com/2019/07/12/KVC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">https://www.neroxie.com/2019/07/12/KVC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>KVC</tag>
      
      <tag>KVO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解iOS Runtime</title>
    <link href="/2024/01/17/think-deep-in-ios-runtime/"/>
    <url>/2024/01/17/think-deep-in-ios-runtime/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>什么是Runtime，个人理解，就是代码run起来所需的环境，比如Java的Runtime就是Java虚拟机。这部分主要回忆下iOS的runtime，确切的说是OC的Runtime，即OC代码运行的依赖的环境及其内部机制。</p><h2 id="OC代码运行依赖于Runtime"><a href="#OC代码运行依赖于Runtime" class="headerlink" title="OC代码运行依赖于Runtime"></a>OC代码运行依赖于Runtime</h2><ul><li>C++&#x2F;C编译器编译时，对于函数的调用地址在编译时已经确定了</li><li>对于OC来说，函数调用是通过发消息的方式，基于Runtime的消息机制动态的找到调用函数的地址</li></ul><h2 id="OC元素认知"><a href="#OC元素认知" class="headerlink" title="OC元素认知"></a>OC元素认知</h2><ul><li>oc runtime的实现时libobjc，可以在github上找到<a href="https://github.com/gnustep/libobjc2">https://github.com/gnustep/libobjc2</a></li><li>id和Class的定义：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">if</span> !OBJC_TYPES_DEFINED</span><br><span class="hljs-comment">/// An opaque type that represents an Objective-C class.</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_class</span> *<span class="hljs-title">Class</span>;</span><br><br><span class="hljs-comment">/// Represents an instance of a class.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_object</span> &#123;</span><br>    Class isa  OBJC_ISA_AVAILABILITY;<br>&#125;;<br><br><span class="hljs-comment">/// A pointer to an instance of a class.</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_object</span> *<span class="hljs-title">id</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>可以看到，id就是objc_object结构体指针，而objc_object就是一个包含了一个objc_class指针(Class)的结构体</li></ul><p>objc_class的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_class</span> *<span class="hljs-title">Class</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_class</span> &#123;</span> <br> Class isa                                 OBJC_ISA_AVAILABILITY; <span class="hljs-comment">// metaclass</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !__OBJC2__</span><br> Class super_class                         OBJC2_UNAVAILABLE; <span class="hljs-comment">// 父类</span><br> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name                          OBJC2_UNAVAILABLE; <span class="hljs-comment">// 类名</span><br> <span class="hljs-type">long</span> version                              OBJC2_UNAVAILABLE; <span class="hljs-comment">// 类的版本信息，默认为0，可以通过runtime函数class_setVersion或者class_getVersion进行修改、读取</span><br> <span class="hljs-type">long</span> info                                 OBJC2_UNAVAILABLE; <span class="hljs-comment">// 类信息，供运行时期使用的一些位标识，如CLS_CLASS (0x1L) 表示该类为普通 class，其中包含实例方法和变量;CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法;</span><br> <span class="hljs-type">long</span> instance_size                        OBJC2_UNAVAILABLE; <span class="hljs-comment">// 该类的实例变量大小（包括从父类继承下来的实例变量）</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_ivar_list</span> *<span class="hljs-title">ivars</span>              <span class="hljs-title">OBJC2_UNAVAILABLE</span>;</span> <span class="hljs-comment">// 该类的成员变量地址列表</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_method_list</span> **<span class="hljs-title">methodLists</span>     <span class="hljs-title">OBJC2_UNAVAILABLE</span>;</span> <span class="hljs-comment">// 方法地址列表，与 info 的一些标志位有关，如CLS_CLASS (0x1L)，则存储实例方法，如CLS_META (0x2L)，则存储类方法;</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_cache</span> *<span class="hljs-title">cache</span>                  <span class="hljs-title">OBJC2_UNAVAILABLE</span>;</span> <span class="hljs-comment">// 缓存最近使用的方法地址，用于提升效率；</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_protocol_list</span> *<span class="hljs-title">protocols</span>      <span class="hljs-title">OBJC2_UNAVAILABLE</span>;</span> <span class="hljs-comment">// 存储该类声明遵守的协议的列表</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，objc_class里面也包含了isa指针，那是不是递归了？其实不是哈，这实际上是用于实现链表，等会就会看到它的作用了。实际上，由于任何包含isa指针的结构体都可以被看做是objc_object，所以Class也可以当成objc_object来使用。所以Class和Object并没有什么本质不同，只不过Class里面包含了额外的一些成员。</p><ul><li>重点：<ul><li>objc_object:<ul><li>isa：指向其Class，该Class中存放普通成员变量指针和方法指针</li></ul></li><li>objc_class:<ul><li>isa：指向其metaClass，即类的类，称为元类，元类中存放这静态变量指针和静态方法指针</li><li>super：指向该类的父Class，从而形成链式结构</li></ul></li><li>metaClass：我们知道metaClass也是objc_class,那么它的isa和super代表啥含义呢？好问题！实际上所有metaClass的isa都指向rootClass的metaClass，metaClass的super执向父Class的metaClass</li><li>那么rootClass的metaClass的isa和super指向哪？问得好！万物总归是由源头的嘛，它的isa指向自己，super指向nil</li><li>rootClass是啥？就是NSObject&#x2F;NSProxy的Class</li></ul></li></ul><p>一图胜千言，君请看：<br><img src="/../images/image-30.png" alt="Alt text"></p><ul><li>SEL：在oc中，我们对于方法的调用其实是间接的通过SEL消息传递的方式，SEL的本质是就是个结构体，一个标识符：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_selector</span> *<span class="hljs-title">SEL</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_selector</span> &#123;</span><br>    <span class="hljs-type">char</span> *name;                       OBJC2_UNAVAILABLE;<span class="hljs-comment">// 名称</span><br>    <span class="hljs-type">char</span> *types;                      OBJC2_UNAVAILABLE;<span class="hljs-comment">// 类型</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li>IMP:imp，实际是个函数指针，是函数的具体实现<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">id</span> <span class="hljs-params">(*IMP)</span><span class="hljs-params">(id, SEL, ...)</span>;<br></code></pre></td></tr></table></figure></li><li>Method：实际是类中方法的抽象类型，封装了IMP<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_method</span> *<span class="hljs-title">Method</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_method</span> &#123;</span><br>    SEL method_name                   OBJC2_UNAVAILABLE; <span class="hljs-comment">// 方法名</span><br>    <span class="hljs-type">char</span> *method_types                OBJC2_UNAVAILABLE; <span class="hljs-comment">// 方法类型</span><br>    IMP method_imp                    OBJC2_UNAVAILABLE; <span class="hljs-comment">// 方法实现</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>Ivar：代表实例变量地址<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_ivar</span> *<span class="hljs-title">Ivar</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_ivar</span> &#123;</span><br>    <span class="hljs-type">char</span> *ivar_name                   OBJC2_UNAVAILABLE; <span class="hljs-comment">// 变量名</span><br>    <span class="hljs-type">char</span> *ivar_type                   OBJC2_UNAVAILABLE; <span class="hljs-comment">// 变量类型</span><br>    <span class="hljs-type">int</span> ivar_offset                   OBJC2_UNAVAILABLE; <span class="hljs-comment">// 基地址偏移字节</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __LP64__</span><br>    <span class="hljs-type">int</span> space                         OBJC2_UNAVAILABLE; <span class="hljs-comment">// 占用空间</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>objc_property_t:是属性的抽象<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_property</span> *<span class="hljs-title">objc_property_t</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name; <span class="hljs-comment">// 名称</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *value;  <span class="hljs-comment">// 值（通常是空的）</span><br>&#125; <span class="hljs-type">objc_property_attribute_t</span>;<br></code></pre></td></tr></table></figure></li><li>Cache:用来缓存imp，因为OC通过SEL寻找Imp如果每次都是动态查找必然效率很低，所以其内部通过Cache来缓存找到的imp结果，加快执行效率<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_cache</span> *<span class="hljs-title">Cache</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_cache</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mask                   OBJC2_UNAVAILABLE;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> occupied               OBJC2_UNAVAILABLE;<br>    Method buckets[<span class="hljs-number">1</span>]                   OBJC2_UNAVAILABLE;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li>Category:即常用的分类，通过分类，我们可以动态给已经存在的类增加方法，顺便回忆下，Category的+load的覆盖，实际上取决于编译顺序<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_category</span> *<span class="hljs-title">Category</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_category</span> &#123;</span><br>    <span class="hljs-type">char</span> *category_name                           OBJC2_UNAVAILABLE; <span class="hljs-comment">// 类别名称</span><br>    <span class="hljs-type">char</span> *class_name                              OBJC2_UNAVAILABLE; <span class="hljs-comment">// 类名</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_method_list</span> *<span class="hljs-title">instance_methods</span>     <span class="hljs-title">OBJC2_UNAVAILABLE</span>;</span> <span class="hljs-comment">// 实例方法列表</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_method_list</span> *<span class="hljs-title">class_methods</span>        <span class="hljs-title">OBJC2_UNAVAILABLE</span>;</span> <span class="hljs-comment">// 类方法列表</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_protocol_list</span> *<span class="hljs-title">protocols</span>          <span class="hljs-title">OBJC2_UNAVAILABLE</span>;</span> <span class="hljs-comment">// 协议列表</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>oc runtime库提供了许多api，可以让我们动态修改类实例、方法甚至是动态创建类</li></ul><h2 id="OC-Runtime消息传递机制"><a href="#OC-Runtime消息传递机制" class="headerlink" title="OC Runtime消息传递机制"></a>OC Runtime消息传递机制</h2><ul><li>oc中，方法调用会被转换为objc_msgSendXXX(receiver, sel)调用</li><li>具体过程：<ul><li>判断sel是否要丢弃</li><li>判断receiver是否为nil，发给nil的消息会被忽略</li><li>在层级关系中寻找具体的方法实现<ul><li>寻找实例方法：从Class的methodLists寻找，找不到则从superClass的methodLists中找</li><li>寻找类方法：通过Class找到metaClass，从metaClass的methodLists中寻找，找不到，则从父类的metaClass的methodLists中寻找</li></ul></li><li>若还是找不到，则进入动态方法解析环节：<ul><li>调用resolveIntanceMethod：决定是否动态添加方法，若是，则通过class_addMethod动态添加方法，得以处理，否则next</li><li>调用forwardingTargetForSelector：既然自己没有这个方法，那转发给别人处理吧，如果返回指定对象，则调用指定对象的方法，返回nil，则next</li><li>调用methodSignatureForSelector：返回nil，结束，若返回methodSignature，则next</li><li>调用forwardInvocation：通过anInvocation做修改实现方法、修改响应对象，若成功，则结束，若失败，则next</li><li>调用doesNotRecognizeSelctor:若没有实现，则crash</li></ul></li></ul></li></ul><p>还是看图吧~<br><img src="/../images/image-31.png" alt="Alt text"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ianisme.com/ios/2019.html">https://www.ianisme.com/ios/2019.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>【iOS, Runtime]</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解iOS RunLoop</title>
    <link href="/2024/01/15/think-deep-in-ios-runloop/"/>
    <url>/2024/01/15/think-deep-in-ios-runloop/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Runloop是iOS和OSX中重要的概念，这部分主要回忆下其底层原理</p><h2 id="RunLoop概念"><a href="#RunLoop概念" class="headerlink" title="RunLoop概念"></a>RunLoop概念</h2><p>其实只要是窗口应用，无论是Windows、Android、QT，都会涉及到EventLoop的概念，以保证App能够持续响应用户交互。其基本实现原理都是启动一个无限循环，然后在循环中处理各种事件。RunLoop可以看做是iOS版本的EventLoop。iOS中的具体实现时基于CFRunLoopRef的NSRunLoop</p><h2 id="RunLoop与线程的关系"><a href="#RunLoop与线程的关系" class="headerlink" title="RunLoop与线程的关系"></a>RunLoop与线程的关系</h2><ul><li>主线程默认有一个Runloop</li><li>每个线程至多有一个Runloop（当然也可以没有runloop）</li><li>可以在线程中获取当前Runloop，若不存在，则进行创建<ul><li>NSRunLoop：[[NSRunLoop currentRunLoop] run]</li><li>CFRunLoop：CFRunLoopGetCurrent</li><li>注意currentRunLoop必须要添加source，不然运行起来就会立即退出</li></ul></li><li>源码分析：<ul><li>获取源码，具体实现看CFRunloop.c  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget -c -r -np -k -L -p   https:<span class="hljs-regexp">//</span>opensource.apple.com<span class="hljs-regexp">/source/</span>CF<span class="hljs-regexp">/CF-1153.18/</span><br></code></pre></td></tr></table></figure></li><li>具体实现：  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-comment">// 获取主线程runloop</span><br><span class="hljs-built_in">CFRunLoopRef</span> <span class="hljs-built_in">CFRunLoopGetMain</span>(<span class="hljs-type">void</span>) &#123;<br>    CHECK_FOR_FORK();<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">CFRunLoopRef</span> __main = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// no retain needed</span><br>    <span class="hljs-comment">// 若还不存在，在创建，绑定到主线程</span><br>    <span class="hljs-keyword">if</span> (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); <span class="hljs-comment">// no CAS needed</span><br>    <span class="hljs-keyword">return</span> __main;<br>&#125;<br><br><span class="hljs-comment">// 获取当前线程runloop</span><br><span class="hljs-built_in">CFRunLoopRef</span> <span class="hljs-built_in">CFRunLoopGetCurrent</span>(<span class="hljs-type">void</span>) &#123;<br>    CHECK_FOR_FORK();<br>    <span class="hljs-comment">// 首先从TSD中获取</span><br>    <span class="hljs-built_in">CFRunLoopRef</span> rl = (<span class="hljs-built_in">CFRunLoopRef</span>)_CFGetTSD(__CFTSDKeyRunLoop);<br>    <span class="hljs-comment">// TSD中有就直接返回TSD中(TSD就是thread local数据，这一步相当于作了个缓存，不用每次去全局dict去获取)</span><br>    <span class="hljs-keyword">if</span> (rl) <span class="hljs-keyword">return</span> rl;<br>    <span class="hljs-comment">// 否则创建，绑定到当前线程到TSD中</span><br>    <span class="hljs-keyword">return</span> _CFRunLoopGet0(pthread_self());<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="RunLoop的创建与释放"><a href="#RunLoop的创建与释放" class="headerlink" title="RunLoop的创建与释放"></a>RunLoop的创建与释放</h2><ul><li>创建：主要创建RunLoop结构体并初始化mode</li><li>释放：发生在thread销毁时，从全局dict中移除绑定关系</li></ul><h2 id="RunLoop的相关类和作用"><a href="#RunLoop的相关类和作用" class="headerlink" title="RunLoop的相关类和作用"></a>RunLoop的相关类和作用</h2><p><img src="/../images/image-27.png" alt="Alt text"></p><ul><li><p>主要包含</p><ul><li>CFRunLoopRef、CFRunLoopModeRef、CFRunLoopSourceRef、CFRunLoopTimerRef、CFRunLoopObserverRef</li><li>关系：runloop关联了多个mode，每个mode中包含多个source、timer、observer（统称item）</li><li>特别的，有一个虚拟的mode是common mode，它实际是个标记，标记为Common的Mode总是会执行commonModeItems中的回调，也就是说，将item添加到commonModeItems中，无论runloop当前处于哪种mode，都能被执行</li><li>所以，因为timer默认是加入到defaultMode，并没有加入到commonModeItems中，所以当滑动列表时，runloop切换到了tracking mode，自然不能执行default mode中的timer回调了</li><li>source分为source0和source1，source0用于app内部的事件分发，source1用于系统向app分发事件，比如触摸屏由系统生成touch事件并通过source1唤醒runloop，进而转换为source0回调</li><li>observer：当runloop的状态发生变化时，会回调对应的observer的回调，一般用于APM（App性能监控）<ul><li>runloop的状态主要包含：即将进入runloop、处理timer、处理source、即将进入休眠、结束休眠或被唤醒、退出loop</li><li>系统框架的observer：<ul><li>即将进入loop，创建pool</li><li>进入休眠之前，将layer的修改打包发给渲染进程</li><li>进入休眠之前，释放pool</li></ul></li><li>系统框架的source：<ul><li>source1：触摸屏事件，当被mach port唤醒时，处理source1的回调，该回调用来处理触摸屏事件</li></ul></li><li>系统框架的timer：NSTimer，但是CADisplayLink内部是source，两者并不一样</li><li>runloop和dispatch的关系：runloop实际是框架，dispatch则是负责block调度，两者相互协作，比如看：  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-comment">// 注意，正常流程下，如果main queue中有block，runloop会处理完毕再休眠</span><br><span class="hljs-comment">// 但是，如果runloop已经休眠了，此时通过异步线程发送给main queue一个block</span><br><span class="hljs-comment">// 那么首先，异步线程会唤醒主线程，进而执行runloop的__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE_函数</span><br><span class="hljs-comment">// 而在该函数中并不会直接执行block，而是调用dispatch库的_dispatch_main_queue_callback_4CF去处理</span><br><span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), block) <br></code></pre></td></tr></table></figure></li><li>NSURLSession：实际上就是在线程中开启runloop，注册source0和source1，source1用于接收底层系统的socket数据通知，source0用来接收由source1转发过来的通知</li></ul></li></ul></li><li><p>整个runloop的运行流程如下：<br><img src="/../images/image-28.png" alt="Alt text"></p><ul><li>注意source0只能在app内部通过手动调用的方式触发并唤醒runloop，而source1则可以绑定mach port，可以通过ipc的方式唤醒线程进而唤醒runloop</li><li>注意在runloop运行期间，可以持续收到source1，所以如果一直有source1，则runloop不会进入休眠，直到source1全部处理完毕</li><li>注意进入runloop和退出runloop只会执行1次</li><li>runloop和gcd的关系：<ul><li>一般情况下，runloop是基于gcd的api的，毕竟runloop是要跑在线程中，由gcd管理线程，但是因为runloop的存在，gcd唤醒主线程并发了一个block到main queue，则需要调用runloop的特定函数去处理，但是最终又回到了gcd的代码中</li><li>block也可以不通过gcd执行，而是通过放在runloop的指定mode中执行，不过一般不这么干，所以看到别人画的图中有block时，一般不是指gcd派发的block，而是由特定函数加入到runloop中的block，一般很少这么用，所以可以忽略掉</li><li>异步线程的gcd中派发block一般都是直接由gcd处理调度的</li><li>注意dispatch_async_main如果main thread没有休眠，则是在当前runloop执行的，不会让runloop休眠，一般只有dispatch_after才会在下一个runloop执行</li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>RunLoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS核心动画-Part7</title>
    <link href="/2024/01/13/ios-core-animation-p7/"/>
    <url>/2024/01/13/ios-core-animation-p7/</url>
    
    <content type="html"><![CDATA[<h2 id="高效绘图"><a href="#高效绘图" class="headerlink" title="高效绘图"></a>高效绘图</h2><ul><li>cpu绘图：通常是指自己实现drawLayer:InContext或drawRect，这需要额外开辟内存和计算，代价高昂</li><li>矢量图形：<ul><li>通过path绘制矢量图形，每次draw都会重绘整个path</li><li>优化：通过CAShapeLayer绘制</li></ul></li><li>脏矩形：<ul><li>有时CAShapeLayer并不能满足我们的要求，比如我们希望绘制的线条是用粉笔样式，那么CAShapeLayer显然不能实现</li><li>可以调用setNeedsPlayInRect来设置需要重绘的rect，这样drawRect不会重绘整个layer区域，可以减少需要绘制的内存和对象</li><li>异步绘制：一般情况下，布局、绘制都是在主线程上的，但是如果我们有预测的将某些内容放到异步去做，那么可以提高性能<ul><li>CATiledLayer就允许每个小块独立线程调用drwaLayerInContext</li><li>drawsAsync属性:和CATiledLayer不同，drawLayerInContext仍让在主线程调用，只不过该方法的实际代码执行是在异步线程，该属性适用于哪些频繁重绘的layer，如UITableView的cell</li></ul></li></ul></li></ul><h2 id="图像IO"><a href="#图像IO" class="headerlink" title="图像IO"></a>图像IO</h2><ul><li>可以优化图片加载时机：<ul><li>预加载</li><li>异步线程加载，有时为了避免主线程加载图片耗时，可以使用异步线程加载，如tableview展示很多图片，注意避免复用的情况，加tag标记cell，cell没有复用的情况下再展示图片（所以实际上没啥卵用），但对本地图片来说其实作用不是很大</li><li>避免延迟解码：<ul><li>iOS通常会延迟解码</li><li>UIImage的imageNamed方法会立刻解码而不会延迟</li><li>可以将image设置为contents避免延迟解码，但这回在主线程执行，所以不利于优化耗时</li><li>可以使用ImageIO框架，强制图片立刻解码</li><li>可以使用CGContext绘制图片<ul><li>绘制一个像素，然后丢弃绘制的像素，这回强制图片解码</li><li>绘制所有像素，然后丢弃原始图片，这种方式会在特定设备上优化</li></ul></li></ul></li><li>使用CATiledLayer来实现异步加载</li><li>使用预览图</li></ul></li><li>缓存：<ul><li>UIImageNamed默认会缓存，他有自己的缓存策略</li><li>自定义缓存：需要自己实现缓存key、缓存策略、失效策略（这里的失效是指相同文件名但内容变化）、回收策略等等</li><li>NSCache，类似于字典，但是系统会在内存压力大时自动回收</li></ul></li><li>文件格式：<ul><li>png适合透明图片、jpeg适合普通图片</li></ul></li></ul><h2 id="layer性能"><a href="#layer性能" class="headerlink" title="layer性能"></a>layer性能</h2><ul><li>隐式绘制：相对的是显式绘制，比如设置contents属性，使用cgcontext绘制；隐式绘制，则是通过使用特定的layer属性、特定的视图、特定的layer子类造成的</li><li>文本：CATextLayer使用CoreText绘制寄宿图，所以尽量避免改变他的frame，因为会引起重绘</li><li>光栅化：shouldRasterize会触发渲染为图片，然后结果将被缓存起来以便后续使用；但是如果用在频繁变动的layer上，缓存的优势荡然无存甚至更糟糕</li><li>离屏渲染：<ul><li>当不能直接在当前屏幕的framebuffer上绘制时，就会触发离屏渲染然后贴到当前的buffer</li><li>圆角、图层蒙版、阴影均会触发离屏渲染</li><li>圆角矩形可以优化为<ul><li>CAShapeLayer+Path的方式</li><li>圆角背景图片</li></ul></li><li>阴影可以优化为使用shadowPath,但是只对简单的形状有效</li></ul></li><li>混合和过度绘制：<ul><li>gpu每一帧填充的像素数量有限制，即填充率</li><li>屏幕上同一个像素被填充多次</li><li>但是如果存在大量重叠的透明子layer，那么gpu就需要消耗更多资源去计算layer的混合，并且对每个透明像素都需要绘制1次，造成过度绘制，为了减少混合和过度绘制行为，优化：<ul><li>视图设置不透明的色值</li><li>设置opaque为YES</li><li>图片尽量避免透明</li><li>若有可能，使用shouldRasterize，以将结果缓存避免混合</li></ul></li></ul></li><li>减少layer数量：<ul><li>创建layer、处理layer、打包layer数据给渲染进程都是有开销的</li><li>虽然CoreAnimation会处理不可见的layer，但我们自己也要避免创建不可见的layer</li><li>建立自己的layer回收机制</li></ul></li><li>建立快照：使用renderInContext，一般日后使用，一般适合固定不变的视图</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Core Animation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS核心动画-Part6</title>
    <link href="/2024/01/13/ios-core-animation-p6/"/>
    <url>/2024/01/13/ios-core-animation-p6/</url>
    
    <content type="html"><![CDATA[<h2 id="基于定时器的动画"><a href="#基于定时器的动画" class="headerlink" title="基于定时器的动画"></a>基于定时器的动画</h2><ul><li>NSTimer：普通的计时器，但是存在不准确、受到的runloop事件处理耗时的影响，我们可以修改为使用CADisplayLink和基于真实时间流逝进行计算</li><li>CADisplayLink：基于屏幕刷新进行回调，CADisplayLink因为是基于帧的，如果发生丢帧，那么丢帧时将不会调用回调，但是NSTimer总是会执行，即使延迟</li><li>计算帧耗时：在回调时记录当前时间，和上次时间进行对比，可以计算出实际上一帧持续的时间，进而动态调整下一帧要展示的数据</li><li>runloop mode:由于runloop中的事件分为不同优先级，所在在不同情况下，runloop优先执行某些mode下的回调，比如在滑动的时候，NSTimer可能就不被执行（因为它在defaultMode），如果想要不受这种影响，需要将我们的回调添加到commonMode中</li></ul><h2 id="物理模拟"><a href="#物理模拟" class="headerlink" title="物理模拟"></a>物理模拟</h2><p>略，很少用</p><h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><ul><li>CoreAnimation会智能将工作分配在cpu和gpu上以达到最优新能</li><li>在系统中，所有的layer的最终合成是被SpringBoard进程管理的</li><li>动画执行过程：<ul><li>App进程：<ul><li>布局：设置图层层级、位置、属性</li><li>显示： 绘制寄宿图，涉及UIView的drawRect和CALayer的drawLayerInContext</li><li>准备：将动画数据准备发送到渲染进程</li><li>提交：打包所有图层和动画数据发送到渲染进程</li></ul></li><li>渲染进程：<ul><li>解码图层数据</li><li>计算OpenGL纹理</li><li>GPU绘制</li></ul></li><li>只有最后的GPU绘制才是GPU处理，前面的都是CPU处理，并且只有布局和显示由开发者自己控制</li></ul></li><li>性能影响：<ul><li>GPU相关操作<ul><li>太多的图层会造成发送给渲染进程的数据量过大，造成cpu压力</li><li>重绘：由重叠的半透明layer引起，因为gpu填充比率有限制，所以需要避免重绘</li><li>离屏绘制：如圆角、为离屏图片分配内存，圆角触发离屏绘制的主要原因是无法在当前屏幕使用的frameBuffer中计算圆角的展示效果，否则会将背景像素也给切割掉，所以只能在额外的frameBuffer中先计算出本图层圆角的效果，然后再贴到当前的frameBuffer中去</li><li>过大的图片：如果图片过大，gpu无法处理，就需要cpu先预先处理</li></ul></li><li>CPU相关操作：<ul><li>如果CPU做了大量操作，则会引起卡顿，丢帧</li><li>布局计算：如果布局很复杂，自然是耗时验证的</li><li>view懒加载：如果view是懒加载的，自然也会降低布局速度</li><li>CG绘制：这个不用说，cpu自己开辟内存绘制，并且发送给给渲染进程，会造成巨大性能开销</li><li>解压图片：对于大图片，会占用一定时间</li><li>layer被发送到render进程之后，cpu会将layer转换为三角纹理，如果layer过于复杂，也会降低性能</li></ul></li><li>IO相关操作：如网络、读取文件等等，可以采取预加载、多线程、缓存机制进行优化</li></ul></li><li>测量性能&#x2F;Instruments<ul><li>Time Profile:测量函数耗时</li><li>Core Animation：CoreAnimation性能</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Core Animation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS核心动画-Part5</title>
    <link href="/2024/01/13/ios-core-animation-p5/"/>
    <url>/2024/01/13/ios-core-animation-p5/</url>
    
    <content type="html"><![CDATA[<h2 id="layer时间"><a href="#layer时间" class="headerlink" title="layer时间"></a>layer时间</h2><ul><li>CAMediaTiming：该协议定义了在一段时间内用于控制时间流逝的属性，如duration、repatCount，CALayer和CAAnimation都实现了该协议，所以时间可以被任意基于layer或者animation控制<ul><li>duration实际是动画重复一次的事件，还有repeatCount控制重复次数</li><li>repatDuration:指定动画重复指定时长</li><li>autoreveres:指定是否自动反向执行</li></ul></li><li>相对时间：animation中，每个aniamtion的时间有自己控制，可以加速、减速、延时<ul><li>beginTime：指定动画开始之前的延时时间，收到speed影响</li><li>speed：时间倍数，默认为1</li><li>timeOffset:让动画快进到某一点，但是不收speed硬性</li></ul></li><li>fillMode：指定动画的开始和结束时的行为<ul><li>removed:默认行为，在到达beginTime时才显示第一帧，并且结束后回到layer当前状态</li><li>backwards：无论是否到达beginTime，立刻显示第一帧，但只有到达beginTime才会执行动画</li><li>forwards：到达beginTime才显示第一帧，动画结束后保持最后一帧状态，直到动画被删除</li><li>both：backwards+forward综合体，立刻显示第一帧，并且结束后保持最后的状态，直到动画移除</li><li>思考：如何既删除动画又保留最终状态？需要我们自己实现delegate，动画结束后手动设置layer的属性值,注意如果不手动设置值，则layer的属性值并不会发生改变！！</li></ul></li><li>层级关系时间：对于layer调整时间将影响到所有子layer，子layer中的时间是以父layer为基准的，但是调整子layer时间并不会影响父layer<ul><li>duration、repeatCount、repatDuartaion并不会影响子layer，但是beginTime、timeOffset、speed会影响</li><li>全局时间：即mach时间，即CACurrentMediaTime，可以认为是绝对可靠的事件基准</li><li>本地时间：每个CALayer和CAAnimation都有自己的本地时间的概念，类似于坐标转换，可以在layer之间通过covertTime来转换</li></ul></li><li>暂停、倒回和跨进：通过设置layer的speed修改动画速度</li><li>手动动画：设置layer的speed为0，并且手动修改timeOffset即可</li></ul><h2 id="动画曲线"><a href="#动画曲线" class="headerlink" title="动画曲线"></a>动画曲线</h2><ul><li>动画速度：即改变量&#x2F;时间间隔</li><li>通过CAMediaTimingFunction的functionWithName创建动画曲线</li><li>通过CATransaction的setAnimationTimingFunction设置动画曲线</li><li>UIView动画在通过options更加方便我们使用动画曲线</li><li>关键帧动画的每个步骤都可以单独应用一个动画曲线</li><li>自定义动画曲线：可以通过functionWithControlPoints构造自己的动画曲线</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Core Animation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS核心动画-Part4</title>
    <link href="/2024/01/13/ios-core-animation-p4/"/>
    <url>/2024/01/13/ios-core-animation-p4/</url>
    
    <content type="html"><![CDATA[<h2 id="隐式动画"><a href="#隐式动画" class="headerlink" title="隐式动画"></a>隐式动画</h2><ul><li>CALayer的属性改变默认是带有自动动画的，比如颜色切换时会发生过渡，这就是所谓的隐式动画</li><li>隐式动画的时长取决于事务，动画类型取决于layer关联的CAAction</li><li>事务会将属性变化打包并做动画，通过CATransaction进行管理</li><li>类似于autorelease pool，事务也是类似stack的设计，当前属性的改变会被添加到最内层的事务，也可以通过begin、commit手动入栈和出栈</li><li>通过setAnimationDuration设置当前事务的时长</li><li>默认的，在每次runloop周期自动开启一次新的事务，所以一般我们不需要手动创建（是不是很像autorelease pool!!)，默认的时长是0.25s</li><li>UIView的animateWithDuration实际上内部就是对CATransaction begin、commit封装</li><li>可以通过setCompletionBlock来设置事务完成之后的回调，如果完成回调中作了动画，那么该动画是默认添加到外部的事务（一般是runloop开启的事务）中的</li><li>之前说，隐式动画的类型取决于layer关联的CAAction，UIView中的关联的layer的隐式动画实际是被禁用了的，也就是说，修改UIView的属性，默认是不带动画的，那么UIView是如何禁用隐式动画的呢？这就需要我们理解隐式动画的机制：<ul><li>当layer属性被修改时，layer会检测实现CALayerDelegate的actionForLayer:forKey方法，如果有，则之间返回结果</li><li>如没有实现delegate的委托，那么layer检查acttions字典</li><li>如果actions字典不存在对应属性，那么检查style字典</li><li>如果style字典不存在对应属性，那么调用兜底的defaultActionForKey</li><li>所以，最终返回一个CAAction，使用该action对属性做动画</li><li>UIView实际上通过实现了delegate，检测当前是否包含在动画块中，如果是，则返回对应CAAction，否则，返回nil，造成默认禁用的效果</li><li>当然，也可以通过调用CATransaction setDisableAction显式禁用所有隐式动画</li><li>这里，我们可以发现，如果想要修改隐式动画行为，对于单独的CALayer，可以实现deleagte，或者设置actions字典；对于UIView来说，要么放在动画块中，要么自定义UIView，重写actionForLayer，本质上，我们只是需要能够获取到何时的CAAction</li></ul></li><li>在做动画的时候，修改layer的属性，值会立刻发生变化，但是实际上渲染并没有立刻发生，动画时CALayer仅是model的角色，真正的呈现需要通过presentationLayer建模，通过presentation我们可以获取屏幕上当前真正展示的属性值，这允许我们在动画期间允许视图响应交互</li></ul><h2 id="显式动画"><a href="#显式动画" class="headerlink" title="显式动画"></a>显式动画</h2><ul><li>显式动画是相对于隐式动画来说，所谓的隐式，我认为理解为默认更合适，由UIKit框架决定，而显式则是开发者自己决定，对于底层渲染并不关心是隐式还是显式</li><li>属性动画：即创建一个CAPropertyAniation子类对象，设置该子类对应的keyPath和value，然通过layer的addAnimation应用该action，即可让keyPath指定的属性做预期动画，可以设置action的delegate，让其在停止时调用对应回调</li><li>通过setValueForKey给action关联特定值，可以在回调中区分出是哪个动画</li><li>CAKeyframeAnimation:是属性动画的子类，特点可以是设置values，或者设置path，让动画以指定的属性步调或者路径进行变化（如果是以path作为值，一般动画的属性是position，并且我们可以通过设置rotationMode来沿着path的切线运动）</li><li>虚拟属性：keyPath并不完全对应于真实属性，如果我们想做旋转动画，我们可能会想到transform属性，但是在某些情况下，可能直接使用transform不如使用虚拟属性transform.rotation更方便，后者只要指定旋转的角度即可，这实际上因为apple通过CAValueFunction内部对我们指定的虚拟属性作了计算实现的</li><li>动画组：之前的属性动画只能针对于单个属性做动画，通过CAAnimationGroup则可以将单独的属性动画组合起来一起做动画</li><li>过渡：属性动画只能针对于属性，如果想针对于layer整体内容（如移除子layer）做动画，则过渡更合适。CATransition通过type和subtype控制过渡效果。其实过渡动画在修改layer的content时默认发生的隐式动画，一般是淡入淡出</li><li>除了过渡实现内容动效，我们还可以自己使用renderInContext进行截图，然后对截图内容自定义属性动画实现自定义过渡效果</li><li>移除动画：调用removeAnimationForKey移除，移除之后，会立刻渲染成当前layer的属性值（注意不是目标值）；如果要让动画被移除之后更新layer的属性值，那么需要设置removedOnCompletion为NO，并设置fillMode</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Core Animation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS核心动画-Part3</title>
    <link href="/2024/01/11/ios-core-animation-p3/"/>
    <url>/2024/01/11/ios-core-animation-p3/</url>
    
    <content type="html"><![CDATA[<h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><ul><li>仿射变换：即旋转、缩放、平移。仿射变换的特定是在变换前后，两条平行直线依然保持平行</li><li>可以使用CGAffineTransformMakeXXX函数来创建一个变换</li><li>UIView中的transform属性对应于CALayer的affineTransform属性</li><li>可以通过CGAffineTransformXXX属性来和另一个transform进行合成新的transform</li><li>也可以使用concat来拼接两个transform</li><li>注意变换的顺序会影响最终的结果，先旋转后平移和先平移后旋转结果不同</li></ul><h2 id="3d-transform"><a href="#3d-transform" class="headerlink" title="3d transform"></a>3d transform</h2><ul><li>CGAffineTransform只是2d变换，CATransform3D则可以做3d变换</li><li>可以使用CATransformMake生成对应变换，iOS上z轴从屏幕向外</li><li>3d transform默认是等距投影而不是透视投影，这意味着远处的边和近处的边是看上去一样长，这不符合人类视觉，所以3d效果不强</li><li>要使用透视效果，需要修改transform3d的m34值，m34默认为0，可以取值为-1&#x2F;d,d越小，透视效果越强，同时越失真，d越大，透视效果越弱</li><li>灭点：所有透视物体最远处的共同消失点，默认是anchorPoint，位于layer中心。所以一般对多个layer做透视同时让他们保持同一个灭点，可以先将layer放到屏幕中线做变化，然后平移到指定位置；更方便的方法是设置父容器的subLayerTransform来让所有子layer共享灭点，这样不用将每个layer先放到中心再做变换</li><li>layer有个doubleSided,表示是否要双面绘制，默认YES，如果设置为NO，则翻转后不显示</li><li>注意在3d transform加透视的情况下，先对外层绕y轴旋转，再对内层绕y轴逆向旋转是不会使得内层回到初始状态的，因为外层变换之后，内层已经被被渲染变形了，再做逆向旋转只是对原来变形的layer做旋转</li><li>可以使用3d transform构建立方体，不常用，略</li></ul><h2 id="专用layer"><a href="#专用layer" class="headerlink" title="专用layer"></a>专用layer</h2><ul><li>CAShapeLayer：通过CGPath绘制指定形状，相比于直接通过CGContext绘制，渲染速度更快，并且可以超出layer之外绘制；通过bezier Path可以绘制任意形状的shape，自然可以绘制自定义圆角</li><li>CATextLayer：功能上比肩UILabel，但速度更快，并且支持富文本，可以将CATextLayer作为自定义View的宿主layer来实现自定义的UILabel</li><li>CATransformLayer：方便3d展示，略</li><li>CAGradientLayer：最常用，展示渐变色</li><li>CAReplicationLayer：对每个子layer接连应用指定次数的变换和色彩偏移，复制出指定数量的子layer，可以利用它实现反射效果</li><li>CAScrollLayer：实现自定义的ScrollView，虽然contentRect可以指定layer可视区域，但是处理滑动并不方便</li><li>CATiledLayer:将大图分解为小片并按需载入，以避免性能压力，实际上CATiledLayer需要我们手动将大图分解为小图，在需要的时候通过回调在drawLayerInContext函数中需要我们实现读取指定小图的逻辑</li><li>CAEmitterLayer：实现例子效果</li><li>CAEAGLLayer：实现opengl绘制，大多用于3d绘制</li><li>AVPlayerLayer：视频播放，是MPMoviePlayer的底层</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Core Animation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS核心动画-Part2</title>
    <link href="/2024/01/09/ios-core-animation-p2/"/>
    <url>/2024/01/09/ios-core-animation-p2/</url>
    
    <content type="html"><![CDATA[<h2 id="layer几何学"><a href="#layer几何学" class="headerlink" title="layer几何学"></a>layer几何学</h2><ul><li>UIView的的属性frame、bounds、center对应layer的frame、bounds、position</li><li>frame代表相对于父view上的坐标，bounds是设定自身的坐标，center和position代表自身的anchorPoint相对于父view的坐标，center和anchorPoint只不过是同样的东西的不同表述罢了</li><li>anchorPoint和position是同样的东西，但是修改其中之一，不影响另一个，但是这样的话frame就得变动了，其计算公式如下： <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objc"> <span class="hljs-comment">// 这里记住，anchorPoint和position只是同一个东西，只是数值不同，按照默认anchorPoint 0.5 0.5去推算就行</span><br>position.x = frame.origin.x + anchorPoint.x * bounds.size.width；  <br>position.y = frame.origin.y + anchorPoint.y * bounds.size.height；<br></code></pre></td></tr></table></figure></li><li>anchorPoint默认位于中间，他是layer进行变换时的锚点，比如同样都是缩放，是从中间开始缩放还是从左上角开始缩放是不同的效果</li><li>view的几种属性，实际上最终改变的是layer的属性，frame实际上是个计算属性，会根据bounds、position、transform计算得到，而改变frame也会改变这几个值，frame始终代表的是轴对齐的一个矩形区域，当旋转后可能frame的宽高和bounds的宽高不再一致，我们一般修改frame来进行布局，但实际上，底层layer使用的是anchorPoint来定位<br><img src="/../images/image-26.png" alt="Alt text"></li><li>修改layer的anchorPoint，会造成view的位置变动，把锚点想象成一个钉子，系统会优先使用锚点定位，然后根据宽高计算出frame，当我们修改锚点时，做旋转变换是以锚点为中心点的</li><li>可以通过CALayer提供的convertXXX函数来进行坐标转换</li><li>layer有zindex决定覆盖顺序，默认是按照子layer的添加顺序展示</li><li>CALayer虽然不关心触摸事件，却提供了containsPoint和hitTest的方法<ul><li>containsPoint: 接受子layer的坐标，由每个子layer判定是否在区域中，所以需要先转换为子view的point</li><li>hitTest:接受父layer中的坐标，返回是哪个子layer被触摸了，但是hitTest依赖于添加的顺序，如果手动修改了zIndex，就检测不正确</li></ul></li><li>CALayer没有UIView的自动布局，但是可以实现CALayerDelegate的layoutSUblayersOfLayer当布局调整时重新设置layer的frame</li></ul><h2 id="layer可以实现的视觉效果"><a href="#layer可以实现的视觉效果" class="headerlink" title="layer可以实现的视觉效果"></a>layer可以实现的视觉效果</h2><ul><li>圆角：cornerRaidus，默认不影响子layer，但可以设置maskTouBounds</li><li>边框：borderWidth和borderColor，内边框</li><li>阴影：shadowColor（阴影色值）、shadowOffset（默认向为0,-3向上偏移）、shadowRadius（控制模糊度），阴影的形状和寄宿图的形状完全一致，我们也可以指定shadowPath来自己绘制阴影形状</li><li>clip会将阴影给裁掉，可以先内部进行裁减，然后添加到外部容器上，再给外部容器设置阴影，因为阴影默认是针对寄宿图的形状的（也就是裁减之后的子view）</li><li>mask：可以将一个layer A设置为另一个layer B的mask属性来将B的内容裁减为A的形状</li><li>放大或者缩小content时，可以选择不同的采样算法，默认是linear，可以选择neareast</li><li>组透明：ios7之前默认是false（即子layer和父layer会独立计算透明度像素然后再叠加），ios7之后（包含ios7）之后是true（即子layer和父layer会作为一个整体计算透明度像素），所以一般无需考虑</li><li>shouldRasterize+rasterizationScale用于将layer光栅化，那么效果也是整体的</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Core Animation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS核心动画-Part1</title>
    <link href="/2024/01/08/ios-core-animation-p1/"/>
    <url>/2024/01/08/ios-core-animation-p1/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Core Animation实际是由Layer Kit演变而来的，是一个强大的符渲染引擎，通过将独立的layer进行组合成树状结构进行渲染</p><h2 id="Layer-tree"><a href="#Layer-tree" class="headerlink" title="Layer tree"></a>Layer tree</h2><ul><li>UIKit中，我们使用的是UIView，UIView可以处理事件、CG绘图和简单的动画，UIView之间组成了树状关系</li><li>CALayer和UIView类似，只是不支持处理事件</li><li>实际上，每个UIView都管理一个CALayer，反之则未必，CALayer才是真正处理渲染的，UIView&#x3D;CALayer+事件处理+动画抽象接口，实际上就是分层和解耦的思想的体现</li><li>但是有时想实现复杂的展示效果，如果阴影、圆角，UIView没有提供相应接口，此时就必须直接操作CALayer</li><li>可以直接创建layer并添加到子layer</li></ul><h2 id="寄宿图"><a href="#寄宿图" class="headerlink" title="寄宿图"></a>寄宿图</h2><ul><li>layer有个contents属性，可以添加一个CGImageRef显示图片，称为寄宿图，类似于UIImageView，可以设置contentGravity设置缩放模式， contentScale用于设置一个点显示多少像素，如果在高分屏上设置低scale，那意味着每个物理点显示的像素数更少，则颗粒感越强</li><li>默认情况下，UIView的内容如果超出边界不会裁减，layer也一样，可以设置maskToBounds属性（UIView叫做clipToBounds）</li><li>contentsRect：可以指定显示寄宿图的区域，是单位坐标</li><li>contentsCenter: TODO,感觉不是很理解,类似于.9图？</li><li>drawRect：<ul><li>可以通过在UIView的方法以代码方式设置寄宿图，像素大小是layer大小*scale，所以如无必要不要实现该方法，造成资源浪费</li><li>实际上UIView将自己layer的CALayerDelegate设置为自己，并在必要的时候触发layer的display方法，如果我们不依赖UIView，可以手动实现CALayerDelegate并自己决定何时调用display</li><li>手动调用layer的display方法 -&gt; delegate 若实现了displayLayer，则调用该函数，否则 -&gt; delegate: drawLaer in context-&gt; uiview: drawInContext</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Core Animation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OC高级编程-GCD</title>
    <link href="/2024/01/06/oc-advance-gcd/"/>
    <url>/2024/01/06/oc-advance-gcd/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分主要介绍iOS 4引入了GCD多线程编程模型</p><h2 id="GCD概要"><a href="#GCD概要" class="headerlink" title="GCD概要"></a>GCD概要</h2><ul><li>概念：是执行异步任务的技术之一，基于线程，但是相比于直接使用线程更加安全和方便，开发者无需关心底层线程的创建</li><li>在gcd之前，cooca提供在NSObject类提供了performSelectorInBackground&#x2F;onMainThread来实现</li><li>多线程的问题：race condition、dead lock、线程爆炸等等</li></ul><h2 id="GCD-API"><a href="#GCD-API" class="headerlink" title="GCD API"></a>GCD API</h2><ul><li>dispatch queue：即任务队列<ul><li>串行队列：任务必须依次执行完毕，单线程，每个queue对应一个线程</li><li>并发队列：任务不必依次执行完毕，可同时执行，多线程,线程数由os管理</li></ul></li><li>创建queue：dispatch_queue_create</li><li>dispatch_release&#x2F;dispatch_retain:自iOS6以来，dispatch对象被纳入了ARC，不需要手动调用</li><li>main queue和global queue：main queue比较特殊，与主线程绑定，global queue都是异步线程，global queue支持设置优先级</li><li>disptach_set_target_queue:该api主要用于修改dispatch_queue_create生成queue的优先级，注意不能修改直接main queue和get_global_queue得到的queue的优先级，同时本应在queue上执行的任务也将放到目标queue上执行<ul><li>一个可能的用法：将两个串行queue放到一个串行queue上执行，避免两个queue并发，实际上就是重新绑定了queue</li></ul></li><li>dispatch_afer:延时执行</li><li>dispatch_group:实现结构化并发，被添加到group中的任务必须全部执行结束，才会触发触发dispatch_group_notify设置的回调</li><li>dispatch_wait:阻塞当前线程，等待group中的所有任务执行完毕</li><li>dispatch_barrier_async:在并发queue中，所有的任务执行是乱序的，但是该函数就行一个栅栏，分割了上面和下面的任务，所以该函数一般是和并发队列一起使用</li><li>dispatch_sync:同步执行，在任务执行结束之前，调用线程会一直阻塞，注意在主线程中调用可能造成死锁（在主线程中执行了sync到main queue的操作，使得主线程wait，永远没有机会被唤醒）</li><li>dipatch_apply:在queue上执行指定次数，并且在执行完毕之前阻塞当前线程</li><li>dispatch_suspend&#x2F;dispatch_resume:挂起和恢复执行的queue</li><li>dispatch信号量：使用disptahc_seamphore和dispatch_semaphore_wait&#x2F;signal来等待和释放信号量，信号量大于0时才能执行，否则阻塞</li><li>dispatch_once:保证只执行一次，一般用于实现单例</li><li>dispatch io:主要用于并发读取和处理文件，略</li></ul><h2 id="GCD实现"><a href="#GCD实现" class="headerlink" title="GCD实现"></a>GCD实现</h2><ul><li>GCD的实现构成：<ul><li>libdispatch：基于pthread抽象出queue</li><li>libc：提供pthread</li><li>xnu内核：workqueue</li></ul></li><li>queue就是通过链表实现的队列，block一般不直接加入queue，然后先封装到dispatch continuation结构体中，然后再加入queue，不管如何，最后实际都是绑定到main queue或者root global queue中</li><li>root global queue按照优先级和是否强制生成线程分为8种，强制生成线程一般用于串行队列（因为每个串行队列都要生成一个线程）<br><img src="/../images/image-25.png" alt="Alt text"></li><li>每个global queue使用一个pthread_workqueue,对应xnu内核的wrokqueue，关系如图：<br><img src="/../images/image-24.png" alt="Alt text"></li><li>具体执行过程：block从queue中被取出，将global queue、workqueue信息和continuation作为参数传递给pthread的work_queue_add函数，pthread则通过系统调用，通知xnu内核增加执行项目，xnu判断是否生成线程，然后执行pthread_work_queue函数，最终执行block，block执行结束后，进行通知group、取下一个block操作</li><li>dispatch source:实际是xnu的kqueue的封装，当系统事件出现时进行回调的技术，比如mach端口发送&#x2F;接受、定时器等等，并且dispatch_source可以设置取消回调</li><li>主队列和主线程：主队列的任务必然在主线程中执行，主线程中不仅可以执行主队列任何，还有可能执行其他关联的任务</li><li>在libdispatch内部，<strong>可以将线程和queue关联起来，比如主线程</strong>，既可以执行main queue任务，也可以执行其他queue任务，那么在执行的时候，就需要先获取原来的queue保存起来，将线程设置为新queue绑定，然后执行完毕之后再恢复与原来queue的绑定</li><li>dispatch_sync实际上会优化为当前线程执行，如果在主线程上执行，那么因为会阻塞主线程，导致block无法执行，也就无法唤醒，造成dead lock</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>OC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OC高级编程-Blocks</title>
    <link href="/2024/01/06/oc-advance-blocks/"/>
    <url>/2024/01/06/oc-advance-blocks/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本章主要介绍iOS4引入的Blocks，对应其他语言的闭包，可以看做是编译器自动生成的带有上下文变量和函数的结构体。</p><h2 id="Blocks概要"><a href="#Blocks概要" class="headerlink" title="Blocks概要"></a>Blocks概要</h2><ul><li>概念：带有自动变量的匿名函数</li></ul><h2 id="Blocks的模式"><a href="#Blocks的模式" class="headerlink" title="Blocks的模式"></a>Blocks的模式</h2><ul><li>语法：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">// 完整写法<br>^返回类型 (参数列表) &#123;表达式&#125;<br>// 返回类型可以省略<br>^(参数列表) &#123;表达式&#125;<br>// 没有参数时可省略参数列表<br>^&#123;表达式&#125;<br></code></pre></td></tr></table></figure></li><li>block类型声明<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">// 实际上，这种写法和c函数指针很相似 int(*ptr)(type...)<br>返回类型 (^变量名)(参数列表类型)<br></code></pre></td></tr></table></figure></li><li>与typedef结合使用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">// 使用typedef可以简化传参<br>typedef 返回类型 (^类型名)(参数列表类型)<br></code></pre></td></tr></table></figure></li><li>block类型变量和其他c变量一样，也可以使用block *指针</li><li>block默认捕获外部变量的值的默认方式是copy，在block内部默认不能修改外部值，如要修改，需要在被捕获的变量前加__block修饰</li><li>block没有实现对c数组的捕获，<strong>不能捕获c数组，需要使用c指针</strong></li></ul><h2 id="Blocks的实现"><a href="#Blocks的实现" class="headerlink" title="Blocks的实现"></a>Blocks的实现</h2><ul><li>block实质：实质就由编译器生成的struct</li><li>为了探究编译器的实现，使用clang –rewrite-objc重写为c++<ul><li>编译器合成了一个xxx_block_impl_idx的结构体，封装了函数和捕获的变量</li><li>block结构体的isa指针描述了block的类型</li><li>id的本质是objc_object的指针的typedef，即  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">typedef struct objc_object &#123;<br>    Class isa;<br>&#125; *id;<br></code></pre></td></tr></table></figure></li><li>Class实际是objc_class的指针的typedef，即  <figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm">typedef struct objc_class&#123;<br>    <span class="hljs-type">Class</span> isa;<br>&#125; *<span class="hljs-type">Class</span>;<br></code></pre></td></tr></table></figure>  和objc_object完全相同。</li><li>假设有个类叫做NyanCat，则NyanCat对象的实际的结构体objc_object中包含了：<ul><li>isa：指向其自己的Class，自己的Class包含了实例方法和实例成员的信息<ul><li>自己的Class中的isa，指向元类的Class，元类的Class的super指向父类元类的Class</li><li>自己的Class的super，指向父类的Class</li></ul></li><li>具体实例成员<br>  如下图所示<br>  <img src="/../images/image-23.png" alt="Alt text"></li><li>总是，就是具体实例+描述信息，仅此而已</li><li>Class的具体实现就是class_t</li></ul></li><li>而block的结构体也包含有isa，可以看做是oc对象（**只要有isa的struct都可以认为是oc对象），其isa则是NSXXXBlock</li></ul></li><li>对于自动变量的捕获，编译器通过在创建block struct传入进行赋值到struct实例中</li><li>__block:实际上__block类似于auto，向编译器表明存储区域。编译器为__block变量创建一个ref结构体，将变量封装到该结构体中，对该变量的访问实际就是对该结构体的访问（类似于Swift的propertyWerapper)<ul><li>在ref中有个forwarding指针，指向自身，需要通过forwarding指针访问值而不直接通过ref</li><li>同一个ref可以被多个block共享，也就是说，block中存放该ref的指针而不存放具体的ref</li></ul></li><li>之前说过，block可以看做是oc对象，block的类可以分为：<ul><li>stack:分配在栈上，捕获变量的block，脱离作用域则被销毁</li><li>global：分配在data区,例如全局block和不捕获变量的block</li><li>malloc：分配在堆，将block和__block进行copy，这也是__block为啥要用一个forwarding，因为当copy后，如果栈上的ref还指向自身，就没法同步变化了</li><li>大多数情况下，block不需要显式copy，编译器会自动copy，如从函数中返回block，调用retainBlock，实际会调用block_copy</li><li>coco框架usingBlock和gcd的api都会帮我们copy，不需要手动调用</li><li>实测，大部分函数返回或者传递的block都会帮我们copy</li><li>对于已经在堆上的block进行copy只会增加引用计数</li><li>在ARC中，多次连续copy不会有问题，copy之后的引用计数就是持有变量的数量</li></ul></li><li>__block变量当block从栈复制到堆时，会跟着一起复制，多个block持有时会增加其引用计数，当block被废弃时，__block也会一起被废弃</li><li>block捕获对象，即增加对象的引用计数，默认是捕获的是__strong引用，编译器会给合成的ref增加合成对应的assign和dispose，实际相当于retain和release<ul><li>ps:书中说如果不对block copy，那么持有的强引用无效，实测还是有效的，不会有任何问题，不需要手动copy</li></ul></li><li>block循环引用：略，使用weak即可，或者使用__block，再执行完毕之后，手动设置为nil（不推荐！！）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>OC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OC高级编程-ARC</title>
    <link href="/2024/01/03/oc-adavance-arc/"/>
    <url>/2024/01/03/oc-adavance-arc/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分主要介绍OC的内存管理实现原理。</p><h2 id="什么是ARC"><a href="#什么是ARC" class="headerlink" title="什么是ARC"></a>什么是ARC</h2><ul><li>ARC，即自动引用计数，是在iOS 5中被引入的。类似于C++中的智能指针</li></ul><h2 id="内存管理-引用计数"><a href="#内存管理-引用计数" class="headerlink" title="内存管理&#x2F;引用计数"></a>内存管理&#x2F;引用计数</h2><ul><li>在很久之前，需要开发者手动管理对OC对象内存，即需要手动retain和手动release，ARC的引入则是将这项任务交给了编译器</li><li>MRC的一般规则：<ul><li>使用以下名称开头的方法意味着调用方生成对象并持有：<ul><li>alloc&#x2F;new&#x2F;copy&#x2F;mutableCopy</li></ul></li><li>非调用方生成的对象，调用方也可以持有<ul><li>例如通过非上述方法生成的对象，调用方可以通过显式retain的方式进行持有</li></ul></li><li>不再需要持有对象时进行释放<ul><li>使用release方法</li></ul></li><li>非自己持有的对象，不能释放，这是保证持有和释放匹配，否则就会造成崩溃</li><li>根据上面的规则，如果某个方法生成对象，并将其给到调用法，应该如何做？<ul><li>如果是以alloc&#x2F;new等开头的方法，方法内部进行retain再返回给调用法，即可满足语义</li><li>如果非alloc&#x2F;new等开头的方法，则需要将其<strong>先加入到autorelease</strong>，再返回给调用方，由调用方进行retain（可选）<ul><li>如果不加入到autorelease，则会立即释放，调用方就没有机会进行retain了</li></ul></li></ul></li></ul></li><li>alloc&#x2F;retain&#x2F;release&#x2F;dealloc的内部实现<ul><li>理解的最好的方式就是看源码，但是Apple并没有开源Foundation框架，所以只能借助于GNUstep框架来近似理解(实际上objc runtime已经开源了，但如果只是为了理解，GNUstep的实现完全够了)</li><li>GNUstep的实现：<ul><li>alloc：计算对象大小，然后分配对应元数据+对象本身需要的内存大小，元数据中保存对象引用计数retain计数<ul><li>注意，alloc时，retain计数的实际值为0，只不过在对外展示时手动+1展示，那么当release时，只要当前retain计数的实际值为0，那么就说明一定是最后一个对象，直接dealloc</li></ul></li><li>retain：将元数据中计数增加</li><li>release：将元数据中计数减少，当减少时retain为0，说明是最后一个对象，执行dealloc</li><li>dealloc：释放创建的内存，注意只需要传元数据地址就行，free只需要内存块的首地址就能正确释放</li></ul></li><li>Apple的实现<ul><li>此处作者通过lldb符号断点的方式大致进行猜测</li><li>在Apple的实现中，引用计数不是保存在对象头部的元数据中，而是单独放到了一个hash表中</li></ul></li><li>两种实现的优缺点比较：<ul><li>放在头部：实现简单，可以统一管理引用计数和对象内存</li><li>放在hash表：对象内存分配时不需要考虑头部（即解耦），hash表中存放了各对象的内存地址，从而可以获取每个对象的内存块（信息更丰富）</li></ul></li></ul></li><li>autorelease的内部实现：<ul><li>autorelease对象会存放到NSAutoreleasePool中，当pool被drain时，其中的对象会自动调用release</li><li>在一次runloop中，会自动创建一个pool，在runloop结束时，会自动drain，所以一般不需要手动创建pool</li><li>但是有时我们想要提前释放一些autorelease对象，比如在循环中大量生成NSString，这些NSString如果是默认被添加到主runloop的pool中，那么必须得等主runloop结束时才会释放，这会造成内存压力。此时我们就可以手动创建pool，将对象创建放到我们pool中，从而可以控制释放时机，降低内存压力</li><li>内部实现：<ul><li>GNUstep的实现：<ul><li>添加到pool：先获取当前正在使用的pool，然后将对象添加到pool中，因为pool类似于一个栈结构，当前使用的pool就是最内层嵌套的pool</li><li>drain：先清空pool，即对pool中的所有对象调用release，最终release内部存储容器</li></ul></li><li>Apple的实现：<ul><li>思想是相似的，不过Apple使用的容器叫做AutoreleasePoolPage，push生成一个page，pop销毁一个page，对象调用autorelease则会添加到当前的page中</li></ul></li><li>问题：pool可以调用autorelease么？答案是不可以，pool的autorelease方法被重载，只要调用就会发生异常(当然，在ARC下我们也无法直接创建pool对象，要关闭ARC，可以在project-build settings中进行设置)</li></ul></li></ul></li></ul><h2 id="ARC规则"><a href="#ARC规则" class="headerlink" title="ARC规则"></a>ARC规则</h2><ul><li><p>在ARC的情况下，编译器会根据我们声明的修饰自动插入合适的retain&#x2F;release&#x2F;autorelease等</p><ul><li>__strong：默认行为，持有引用，可以修饰变量和类成员变量</li><li>__weak：需要显式写出，不持有引用，主要用于解决循环引用问题</li><li>__unsafe_unretained:和__weak一样，不持有引用，但是不安全，不会自动设置为nil（为什么需要这个修饰符呢？有时是为了一些性能优势，有时是为了与C交互不得不使用）</li><li>__autoreleasing：表示会自动加入到pool中，但是一般也不用显式写出，因为：<ul><li>当对象作为返回值时，自动添加到pool中</li><li>当使用weak变量是，如果变量不为nil，则会先将其加入到pool中，防止使用时被销毁</li><li>当使用对象指针是，也会被自动加上该修饰符，比如NSError*<em>，实际就是NSError * (__autorelease</em>),表示这个指针中存放了一个指针p，p引用的对象应该需要被加入到pool中，因为p所引用的error并不是自己创建的，而是别人创建的。所以当将一个对象指针的地址赋给一个双重指针时，需要显示的写出修饰符，不然因为默认修饰符是autorelease而出现不匹配而报错。但其实我们可以传递一个strong修饰的变量给到autorelease修饰的参数，实际上这是编译器帮我们作了一次转换</li></ul></li><li>ARC有效的情况下：<ul><li>如需将ARC的对象给到C结构体成员，需要转换为修改为_unsafe_unretained或者转换为void *</li><li>如需转换id和void *:使用__brigde，但是这种直接转换没有任何内存管理语义<ul><li>__brigde_reatined:将oc对象转换为c对象，实际就是编译器为我们额外插入了一次retain，保证c在使用时该对象还没被释放，<strong>oc作用域还没结束时引用计数会多个1</strong>，oc作用域结束后，引用计数仍然为1，<strong>必须调用CFRelease手动释放</strong></li><li>__bridge_transfer:将c对象转换为oc对象，实际就是编译器先retatin，然后额外进行了release，保证c中看上去已经释放了，完全由oc托管，<strong>转换前后引用计数保持不变</strong>，即将内存管理职责交给了oc</li><li>注意这种转换只适合OC和CoreFoundation中的类，普通的C结构体是不行的（因为根本就没有retain&#x2F;release这些…)</li><li><strong>注意将c对象直接通过bridge转换给到oc的__strong，会发生默认的retain，可能造成内存泄漏（这里说的内存泄漏是指忘记对cf对象调用cfrelease的情况）；而如果直接通过brigde将oc转换为c，则oc作用域结束时，对象会被销毁，会发生bad access</strong>，所以必须正确使用__brigde_xxx和CRXXX才能正确转换避免内存错误</li><li>总结下必须手动调用cfrelease的情况：1.通过__bridge_retined将oc转换为cf 2.通过__bridge将c转换为oc的__strong，释放的目的都是为了防止内存泄漏</li></ul></li></ul></li></ul></li><li><p>属性和修饰符有着对应关系：</p></li></ul><pre><code class="Objective-C">assign -&gt; __unsafe_unretainedcopy -&gt; __strong，并且调用copyretain -&gt; __strongusafe_unretained -&gt; __unsafe_unretainedweak -&gt; __weak</code></pre><p>需要注意，关联的属性和类成员变量必须修饰符相同</p><ul><li>当与C数组结合使用时：<ul><li>当静态数组中存放oc对象的引用时，oc对象会随着数组的释放而释放，静态数组是分配在栈上的，编译器知道何时释放</li><li>当动态数组中存放oc对象的引用时，需要我们手动将数组中的指针赋值为nil，动态数组的实际内存时在堆上的，编译器无法知道何时释放（所以最好不要使用动态数组存放oc对象）</li></ul></li></ul><h2 id="ARC的实现"><a href="#ARC的实现" class="headerlink" title="ARC的实现"></a>ARC的实现</h2><ul><li>__strong:<ul><li>对于alloc这些方法，只是在作用域末尾插入了release</li><li>对于非alloc这些方法获取的对象，理论上会将对象加入到pool中，但实际上，编译器会做以下优化：<ul><li>调用方通过objc_retainAutoreleasedReturnValue(obj)尝试retain，他能够处理没有加入到pool的对象，并在作用域末尾插入release</li><li>被调用函数的内部返回的是objc_autorelaeseReturnValue(obj),该函数会检查调用方是否随后会调用objc_retainAutoreleasedReturnValue，如果是，则不将objc添加到pool，而是直接传递</li><li>通过这两个函数的协作，可以省去将obj添加到pool的成本</li></ul></li></ul></li><li>__weak:<ul><li>首先调用objc_initweak(&amp;weakObj, strongObj)实际就是objc_storeweak(&amp;weakObjc, strongObj),超出作用域之后，调用objc_destroyweak(&amp;weakObj),实际就是objc_storeweak(&amp;weakObj, 0)</li><li>objc_storeweak会将strongObj的地址作为key，weakObj的地址作为值，存到weak表中，若strongObj为0，则从表中删除该weakObj</li><li>大致结构类似strongObj -&gt; [weakObj1, weakObjc2….]</li><li>weak表和引用计数表类似，都是hash表，所以通过该表，在strongObj被销毁时，能快速找到所有的weak变量设置为nil</li><li><strong>oc对象被销毁时，会从weak表中找到对应weak变量设置为nil，然后从weak表中删除该项，最后从引用计数表中删除该项</strong></li><li>在使用weak变量时，编译器会插入objc_loadWeakRetained(obj),取出对应对象，然后插入objc_autorlease,将其添加到pool中，防止在作用域内使用时被释放，注意每使用一次，都会插入一次，那么在作用域内频繁使用weak对象，就会频繁被添加（同一个对象可以被多次添加到pool中）</li><li><strong>所以，最好在取得weak之后，将其赋值给strong变量，防止产生大量的autorelease对象</strong></li><li>有的类重写了retain&#x2F;release,从而不支持weak，比如NSMachPort</li></ul></li><li>__autorleasing:就是插入objc_autorelease(obj)注册到pool</li><li>获取引用计数：_objc_rootRetainCount，但是该函数不可信</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>OC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-互用性</title>
    <link href="/2023/12/31/swift-advance-interop/"/>
    <url>/2023/12/31/swift-advance-interop/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>所谓互用性，也称为互操作性，大白话就是Swift如何和其他编码语言的二进制进行交互调用。Swift的强大之处在于，可以方便的和OC、C混用。</p><h2 id="封装一个用C编写的程序库"><a href="#封装一个用C编写的程序库" class="headerlink" title="封装一个用C编写的程序库"></a>封装一个用C编写的程序库</h2><ul><li>设置包管理器：<ul><li>brew install cmark: 安装cmark</li><li>创建SwiftPM项目目录：swift package init –type executable</li><li>如何找到cmark库<ul><li>需要按照clang moudule格式使用module map封装cmark为module</li><li>需要在Package.swift中定义一个.systemLibaryay target，标志由系统包管理器，如apt、homebrew提供的库，并将其添加到主target的依赖中</li><li>那么创建一个目录，包含shime.h，其中包含cmark.h，module map文件中指定header为shime.h，并link cmark二进制</li><li>然后就可以在Swift中调用了</li></ul></li></ul></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">import</span> PackageDescription<br><span class="hljs-keyword">let</span> package <span class="hljs-operator">=</span> <span class="hljs-type">Package</span>(<br>    name: <span class="hljs-string">&quot;CommonMarkExample&quot;</span>,<br>    dependencies: [],<br>    targets: [<br>        .executableTarget(<br>            name: <span class="hljs-string">&quot;CommonMarkExample&quot;</span>,<br>            dependencies: [<span class="hljs-string">&quot;Ccmark&quot;</span>]),<br>        .systemLibrary(<br>            name: <span class="hljs-string">&quot;Ccmark&quot;</span>,<br>            pkgConfig: <span class="hljs-string">&quot;libcmark&quot;</span>,<br>            providers: [<br>                .brew([<span class="hljs-string">&quot;cmark&quot;</span>]),<br>                .apt([<span class="hljs-string">&quot;cmark&quot;</span>]),<br>        ]),<br>    ]<br>)<br></code></pre></td></tr></table></figure><ul><li>封装CmmonMark程序库<ul><li>Swift在调用是，会将c的数据类型转换为Swift数据类型</li><li>注意在调用后，需要手动free c返回的数据对象</li></ul></li><li>对于不透明指针，Swift使用OpaquePointer</li><li>对于C枚举，Swift使用struct表示，而对于OC的NS_Enum会转换为Swift Enum</li></ul><h2 id="底层类型概览"><a href="#底层类型概览" class="headerlink" title="底层类型概览"></a>底层类型概览</h2><ul><li>含有managed表示内存时自动管理</li><li>含有unsafe表示安全性需要自己保证，不提供内存管理，需要手动管理</li><li>含有buffer表示作用于连续内存上的多个元素而非单一元素</li><li>含有pointer表示具有指针语义</li><li>含有raw表示无类型原始数据，等价于void*</li><li>含有mutable表示允许修改指向的内存</li><li>指针：<ul><li>UnsafePointer等价于const int*，即不能修改指针指向的内存</li><li>const int *p,const修饰指向的内容，指向的内容不可变</li><li>int *const p,const修饰指针，指针不可变，指向的内容可变</li><li>使用可选值代表空指针</li></ul></li></ul><h2 id="闭包用作C的回调函数"><a href="#闭包用作C的回调函数" class="headerlink" title="闭包用作C的回调函数"></a>闭包用作C的回调函数</h2><ul><li>只允许向C函数指针传递不捕获任何外部变量的block或者函数，使用@convention(C)告知编译器，因为C函数指针时静态的，但是Swift闭包本质上可以理解为一个带有上下文和函数的结构体</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-编码和解码</title>
    <link href="/2023/12/31/swift-advance-encode-decode/"/>
    <url>/2023/12/31/swift-advance-encode-decode/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>和别的语言序列化的概念相似，Swift中定义了Codeable协议，其实际就是Decodeable&amp;Encodeable。标准库所有基本类型都实现了Codeable，如果struct和class内部属性都满足Codeable，则编译器可以自动生成其Codeable实现。</p><h2 id="一个最小的例子"><a href="#一个最小的例子" class="headerlink" title="一个最小的例子"></a>一个最小的例子</h2><ul><li>当strcut中的成员都是Codeable时，编译器可以自动生成Codeable实现，我们只要声明Codeable即可</li><li>编码：Swift自带JSONEncoder和PropertyListEncoder，可以将Codeable转换为对应数据，不同的encoder返回的数据格式是不同的</li><li>解码：将编码之后的数据传递给decoder，从而重新创建出实例</li><li>自定义编码格式：如果不自定义，那么编码后的数据格式完全由编码器的默认实现决定，比如Double就是json中的浮点。如果想要让Double编码为字符串，我们可以实现一个自定义的@propertyWrapper，让其符合Encodeable，然后自己实现encode和init(from decoder)方法<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">@propertyWrapper</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CodedAsString</span>: <span class="hljs-title class_">Codable</span> &#123;<br>    <span class="hljs-keyword">var</span> wrappedValue: <span class="hljs-type">Double</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">wrappedValue</span>: <span class="hljs-type">Double</span>) &#123;<br>        <span class="hljs-keyword">self</span>.wrappedValue <span class="hljs-operator">=</span> wrappedValue<br>    &#125;<br>    <br>    <span class="hljs-comment">// 自定义属性解码</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">from</span> <span class="hljs-params">decoder</span>: <span class="hljs-type">Decoder</span>) <span class="hljs-keyword">throws</span> &#123;<br>        <span class="hljs-keyword">let</span> container <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> decoder.singleValueContainer()<br>        <span class="hljs-keyword">let</span> str <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> container.decode(<span class="hljs-type">String</span>.<span class="hljs-keyword">self</span>)<br>        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> value <span class="hljs-operator">=</span> <span class="hljs-type">Double</span>(str) <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 抛出错误</span><br>        &#125;<br>        wrappedValue <span class="hljs-operator">=</span> value<br>    &#125;<br>    <br>    <span class="hljs-comment">// 自定义属性编码</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">encode</span>(<span class="hljs-params">to</span> <span class="hljs-params">encoder</span>: <span class="hljs-type">Encoder</span>) <span class="hljs-keyword">throws</span> &#123;<br>        <span class="hljs-keyword">var</span> container <span class="hljs-operator">=</span> encoder.singleValueContainer()<br>        <span class="hljs-keyword">try</span> container.encode(<span class="hljs-type">String</span>(wrappedValue))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="编码过程"><a href="#编码过程" class="headerlink" title="编码过程"></a>编码过程</h2><ul><li>实际是每个被编码的值调用自身的encode方法，传递对应的Encoder实例进行编码</li><li>容器：先看下Encoder协议<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">/// 一个可以把值编码成某种外部表现形式的类型。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Encoder</span> &#123;<br>    <span class="hljs-comment">/// 编码到当前位置的编码键 (coding key) 路径</span><br>    <span class="hljs-keyword">var</span> codingPath: [<span class="hljs-type">CodingKey</span>] &#123; <span class="hljs-keyword">get</span> &#125;<br>    <span class="hljs-comment">/// 用户为编码设置的上下文信息。</span><br>    <span class="hljs-keyword">var</span> userInfo: [<span class="hljs-type">CodingUserInfoKey</span> : <span class="hljs-keyword">Any</span>] &#123; <span class="hljs-keyword">get</span> &#125;<br>    <span class="hljs-comment">/// 返回一个容器，用于存放多个由给定键索引的值。</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">container</span>&lt;<span class="hljs-type">Key</span>: <span class="hljs-type">CodingKey</span>&gt;(<span class="hljs-params">keyedBy</span> <span class="hljs-params">type</span>: <span class="hljs-type">Key</span>.<span class="hljs-keyword">Type</span>)<br>    -&gt; <span class="hljs-type">KeyedEncodingContainer</span>&lt;<span class="hljs-type">Key</span>&gt;<br>    <span class="hljs-comment">/// 返回一个容器，用于存放多个没有键索引的值。</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">unkeyedContainer</span>() -&gt; <span class="hljs-type">UnkeyedEncodingContainer</span><br>    <span class="hljs-comment">/// 返回一个适合存放单一值的编码容器。</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">singleValueContainer</span>() -&gt; <span class="hljs-type">SingleValueEncodingContainer</span><br>&#125;<br></code></pre></td></tr></table></figure>为每个要编码的值创建一个编码容器，保证每个值不会覆盖彼此，有三种类型的容器：<ul><li>keyed contianer：用于编码键值对，可以看做是个特殊的dict</li><li>unkeyed container：编码值，不需要key，可以懒做是编码结果数组</li><li>single value container：对单一值编码，处理由单个属性定义的类型，如Int<br>每种容器都对应一个协议，约束容器应该如何接受值并进行编码，以single value container举例：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">SingleValueEncodingContainer</span> &#123;<br>    <span class="hljs-comment">/// 编码到当前位置的编码键路径。</span><br>    <span class="hljs-keyword">var</span> codingPath: [<span class="hljs-type">CodingKey</span>] &#123; <span class="hljs-keyword">get</span> &#125;<br>    <span class="hljs-comment">/// 编码空值。</span><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">encodeNil</span>() <span class="hljs-keyword">throws</span><br>    <span class="hljs-comment">/// 编码原始类型的方法</span><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">encode</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">value</span>: <span class="hljs-type">Bool</span>) <span class="hljs-keyword">throws</span><br>    <span class="hljs-comment">/// TL;DR</span><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">encode</span>&lt;<span class="hljs-type">T</span>: <span class="hljs-type">Encodable</span>&gt;(<span class="hljs-keyword">_</span> <span class="hljs-params">value</span>: <span class="hljs-type">T</span>) <span class="hljs-keyword">throws</span><br>&#125; <br></code></pre></td></tr></table></figure>可以看到，如果是单个简单类型的值，直接调用对应函数，如果不属于这个简单类型，那么则调用该对象的encode(to:)递归。其他两种类型的容器也是和single value container有类似的结构，但是具备更多的能力，比如可以创建嵌套容器，具体使用哪个，取决于类型实现者自己。比如数组既可以调用single value container，也可以使用unkeyed container，显然后者更佳。</li></ul></li><li>总结下：编码器提供底层编码能力，被编码的类型自己调用编码器去编码。</li></ul><h2 id="合成的代码"><a href="#合成的代码" class="headerlink" title="合成的代码"></a>合成的代码</h2><ul><li>当编译器自己合成Codeable方法时，其实现时什么<ul><li>首先，会生成一个枚举CodingKeys，用来表示内部的属性，该enum符合CodingKey协议，该协议允许使用String和Int转换</li><li>encode：使用一个keyed container，将属性分别encode并放到container中，最终的结果是递归的</li><li>init方法：同样先获取keyed container，然后递归调用decode获得属性值并最终创建自身</li></ul></li></ul><h2 id="手动遵守协议"><a href="#手动遵守协议" class="headerlink" title="手动遵守协议"></a>手动遵守协议</h2><ul><li>如果不想使用编译器生成的Codeable方法，可以自己实现</li><li>自定义CodingKeys：<ul><li>实现键的重命名：将对应case的rawValue修改为指定值</li><li>不含某个case：编码时将跳过对应属性</li></ul></li><li>自定义encode和init<ul><li>比如处理json字符串中缺失某个字段</li><li>但是这也反应了一个问题，就是对于非正常值的处理，使用编码系统还是不够灵活和普适合，但是，理想情况下是要求server返回正确的数据，但是因为在实际工作中总是有各种各样的case，所以一般还是手动解析更多</li></ul></li></ul><h2 id="常见的编码任务"><a href="#常见的编码任务" class="headerlink" title="常见的编码任务"></a>常见的编码任务</h2><ul><li>编码非自己的类型：可以自定义encode或者封装嵌套实现，但是不能直接通过extension别人的类型为Codeable，或者使用计算属性来动态创建非Codeable的类型</li><li>让类满足Codable：对值来说，很简单，直接符合Codeable，但是对于类来说，不能通过extension的方式追加Codeable（required方法不能添加到extension中，required表示所有子类都要实现，所以required方法能被动态派发，所以必须在编译期间检查创建，而不不能通过事后extension的方式创建）。我们可以通过变通的方法，比如使用可Codeable的类型，然后动态创建出非Codeable的类型</li><li>解码多态的集合：比如数组中包含多个UIView的子类型，但是解码时我们只能将其解码为固定的UIView类型，实际上这种情况我们只能case by case解决，因为要保证类型安全，否则就有可能创建意外类型的对象</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-错误处理</title>
    <link href="/2023/12/30/swift-advance-error-handle/"/>
    <url>/2023/12/30/swift-advance-error-handle/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>错误处理很枯燥，错误处理也很重要，skr~</p><h2 id="错误分类"><a href="#错误分类" class="headerlink" title="错误分类"></a>错误分类</h2><ul><li>预期中的error，如网络连接失败<ul><li>可忽略的eror：如字典中key不存在，一般这种返回可选值更好</li><li>需提供详细信息的error：如网络失败，需要网络失败的类型<br>-非预期的error：如数组越界</li></ul></li></ul><h2 id="Result类型"><a href="#Result类型" class="headerlink" title="Result类型"></a>Result类型</h2><ul><li>实际就是个enum<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;<span class="hljs-title class_">Success</span>, <span class="hljs-title class_">Failure</span>: <span class="hljs-title class_">Error</span>&gt; &#123;<br>    <span class="hljs-keyword">case</span> success(<span class="hljs-type">Success</span>)<br>    <span class="hljs-keyword">case</span> failure(<span class="hljs-type">Failure</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="抛出和捕获"><a href="#抛出和捕获" class="headerlink" title="抛出和捕获"></a>抛出和捕获</h2><ul><li>函数后使用throws表示函数可能抛出错误，调用时需要加try</li><li>任意类型都可以是Error类型，Error类型实际就是个标记类型</li><li>使用do…catch…捕获error</li><li>本质上，抛出error就是创建result，只不过编译器帮我们完成了</li></ul><h2 id="具体类型error和无类型error"><a href="#具体类型error和无类型error" class="headerlink" title="具体类型error和无类型error"></a>具体类型error和无类型error</h2><ul><li>throw属于无类型error，因为我们并不能穷举所有error类型，大多数情况下也没有必要</li><li>Result属于具体类型error</li></ul><h2 id="不可忽而略的error"><a href="#不可忽而略的error" class="headerlink" title="不可忽而略的error"></a>不可忽而略的error</h2><ul><li>相比于Result，当使用throws，编译器强制我们进行处理</li></ul><h2 id="错误转换"><a href="#错误转换" class="headerlink" title="错误转换"></a>错误转换</h2><ul><li>try?可以将throws转换为可选值，但是会丢失error信息</li><li>try!表示如果throw，直接崩掉</li><li>Result提供了api将可throw的代码封装为Result，很简单，就是内部catch</li></ul><h2 id="错误链"><a href="#错误链" class="headerlink" title="错误链"></a>错误链</h2><ul><li>throws链：只要有一个函数throw，那么整个函数都会throw</li><li>result链：略，比较复杂，并且没啥用</li></ul><h2 id="错误和回调"><a href="#错误和回调" class="headerlink" title="错误和回调"></a>错误和回调</h2><ul><li>回调不兼容throws，而是只能使用回调Result结果</li></ul><h2 id="使用defer进行清理"><a href="#使用defer进行清理" class="headerlink" title="使用defer进行清理"></a>使用defer进行清理</h2><ul><li>类似于finally，但可以使用在任何地方</li><li>多个defer执行的顺序取决于声明顺序逆序，可以认为是个栈</li><li>defer发生在return的求值之后，在实际return之前</li></ul><h2 id="Rethrows"><a href="#Rethrows" class="headerlink" title="Rethrows"></a>Rethrows</h2><ul><li>如果将一个函数标记为throws，则任何调用的地方都必须加try</li><li>可以将函数标记为rethrows，这时，只有其参数是throws标记时，他才是throws的</li></ul><h2 id="将错误桥接到OC"><a href="#将错误桥接到OC" class="headerlink" title="将错误桥接到OC"></a>将错误桥接到OC</h2><ul><li>Swift将OC中接受NSError**的函数姿容转换为throws的版本</li><li>Swift的Error将会转换为NSError</li><li>LocalizedError协议：提供本地化信息表示</li><li>RecoverableError：描述用户可恢复的错误</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-并发</title>
    <link href="/2023/12/30/swift-advance-concurrency/"/>
    <url>/2023/12/30/swift-advance-concurrency/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Swift 5.5引入了async&#x2F;await特性，类似于go的go func。本质上是用户级线程，即在线程之上又抽象了自己的任务调度。</p><h2 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async&#x2F;Await"></a>Async&#x2F;Await</h2><ul><li>之前，一般通过回调编写异步代码，缺点就是有可能导致深度嵌套，可读性差，并且，也无法使用Swift的错误处理和defer</li><li>每个await都有可能导致任务被suspend，在await的函数返回之后再执行之后的代码</li><li>Swift的编发模型称为协同式多任务，函数是自愿暂停并且只在await才能暂停</li><li>被暂停的函数<strong>再继续后可能在和原先不同的线程上执行</strong>，所以在函数中执行和线程相关的代码时要小心，如thread local变量需要修改为task local变量</li><li>适合io密集型任务</li><li>支持cancel，但是这个cancel只是标记了一个flag，具体是否结束任务需要自行决定，这也是协作式的一种表现</li><li>每次await都会创建一个异步作业，两个个await之间的代码是同步执行的</li><li>但有时多个作用会被合并，也就是说，虽然await创建了一个新任务，但是实际情况该任务可能和await之前的任务一起是同步执行的，所以await是<strong>潜在</strong>的暂停，不一定是必然暂停</li><li>可将将异步回调通过withCheckedThrowingContinuationg封装为async函数，checked表示运行时会进行检查，确保回调仅调用1次</li><li>withXXXContinuation除了用来封装异步回调，本质上，允许我们手动暂停任务，并在之后恢复</li><li>async方法需要标记为@objc才能被oc通过回调方式调用</li></ul><h2 id="结构化并发"><a href="#结构化并发" class="headerlink" title="结构化并发"></a>结构化并发</h2><ul><li>task是Swift并发模型的基本执行上下文，每个async函数都位于一个task中</li><li>task中遇到await，可能暂停，将控制权交还给调度器，再次调度后可能位于不同的线程上执行</li><li>await调用async函数，被调用函数和调用者属于同一个task，想要创建新任务，需要进行明确的动作<ul><li>子任务：async let，高招属性结构组织，有作用域和生命周期</li><li>非结构化任务：单独的任务，称为独立任务树的根节点，调用Task或者Task.detached创建非结构化任务</li></ul></li><li>任务树中<ul><li>子任务相互之间可以并发运行</li><li>子任务生命周期不能超过父任务，父任务需要等待所有子任务完成才退出</li><li>取消从父任务传递给子任务</li><li>子任务继承父任务优先级和任务本地值</li></ul></li><li>async let：使用该语法创建子任务，会立即执行，没有被await的async let将会在作用域结束后隐式被cancel并且await，只是因为必须保证子任务有机会退出</li><li>任务组在正常退出时，不会隐式cancel和await</li><li>async let即使包含多个异步调用，也只会创建一个任务</li><li>async let是在编译期间确定了子任务数量，如果想要运行时动态添加子任务，则需要任务组</li></ul><h2 id="任务组"><a href="#任务组" class="headerlink" title="任务组"></a>任务组</h2><ul><li>提供动态数量的子任务</li><li>使用withTaskGroup和withThrowingTaskGroup创建任务组</li><li>一些规则：<ul><li>子任务结果按照完成顺序传递</li><li>子任务结果类型需要完全相同</li><li>子任务声明周期不能超过任务组闭包范围</li><li>如果在退出任务组闭包时仍然有未经等待的子任务，运行时会在继续前隐式等待这些任务直到结束并丢弃结果，注意不会自动cancel</li><li>任务组不会限制并发数量</li></ul></li><li>传递给任务组的参数闭包类型是@Sendable修饰的，这个注解表示多任务执行该代码是安全的，即并发安全，即代码中不会引起race condition<ul><li>@Sendable捕获的值自己需要是Sendable的</li><li>Sendable是个空协议，即标记协议</li><li>非public的struct和enum，只要其成员是Sendable，则本身也是Sendable</li><li>Actor默认是Sendable</li><li>对于没有标记为final的class，编译器无法保证是Sendable，但是我们可以通过修饰@uncheckSendable告知编译器，安全性由开发者保证</li><li>虽然Swift闭包默认将捕获作为引用，但@Sendable中需要将捕获变量作为值处理，这也是保证安全性的手段</li><li>目前来说，@Sendable编译器还无法保证完全的安全，还处在不断的完善中</li></ul></li><li>取消是协作式的，即需要任务自己检查取消状态并执行相应逻辑，可以执行Task.checkCancellation让取消时抛出error</li><li>大部分情况下，我们调用系统异步函数时无需自己检查cancel，然是如果我们自己实现一个耗时任务，还是需要的</li><li>如果一个任务被取消，应该抛出error</li><li>当任务组被cancel时，子任务也会被canel</li><li>可以使用withTaskCancellationHandler为取消设置回调函数</li><li>可以使用Task.init开启独立任务，该任务会立即开始，并且称为一个新的任务树的根节点，Task类似于js中的promise或者java中的Future</li><li>通过Task启动的非结构化任务，会继承原上下文的优先级、本地值和actor隔离域，即如果开启Task的任务是运行在actor队列中的，那么Task也是会加到该actor队列中</li><li>若不想Task在当前上下文中执行，可以使用Task.detached创建游离任务，游离任务不会继承当前任务的优先级、本地址和actor隔离</li><li>若要在非async函数中开启任务，则必须借助于Task</li><li>非结构化任务中，不会抛出错误</li></ul><h2 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h2><ul><li>无论是传统的多线程还是最近兴起的协程，都需要处理race condition问题，解决方式包括锁、串行队列等，而Swift并发使用的方案是Actor作为资源隔离机制</li><li>actor是引用类型，和声明class一样。在actor内部访问var属性是没有问题的，访问let属性更没问题（实际上，let可以跨actor也是安全的），对于方法的访问，其<strong>内部采用串行队列加以保护</strong></li><li>actor并不是将整个方法都隔离，在await之间的函数视为原子操作</li><li>actor的方法是可重入的，即一旦actor中的方法因执行async函数而不suspend时，其他方法再次调用actor中的方法时，能够在actor的队列中执行</li><li>因为actor方法是可重入的，所以不要暂停点前后的数据是有可能发生变化的</li><li>同一个任务如果执行多个actor的方法，那么会产生actor跳跃，不可避免产生开销</li><li>@MainActor，是个globalActor，使用该标记让我们的属性或者方法都运行在主线程队列中</li><li>nonisolated：将其标记为非保护</li><li>大多数情况下，@MainActor都是符合预期的，但要分3种情况<ul><li>标记async方法：没问题</li><li>标记非async方法：编译器会执行静态检查，在main actor上下文中直接调用，其他上下文需要await，但是在oc中可能失效</li><li>标记属性：同样是编译期间检查，不能在非main actor上下中访问</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-集合协议类型</title>
    <link href="/2023/12/28/swift-advance-collection-protocol/"/>
    <url>/2023/12/28/swift-advance-collection-protocol/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Swift中的集合，如Array、Dictionary、Set是建立在Swift标准库提供的协议之上的。这部分主要介绍Sequence和Collection协议，他们的关系如图：<br><img src="/../images/image-22.png" alt="Alt text"></p><ul><li>Sequence: 提供迭代方法，但是不保证能够支持多次迭代</li><li>Collection: 继承自Sequence，可以支持多次遍历，允许使用索引访问元素，通过SubSequence提供切片能力</li><li>MutableCollection:允许通过下标修改Collection，但是不允许修改元素数量</li><li>RangeReplaceableCollection: 提供替换集合中连续区间中的元素，进而支持插入、删除</li><li>BidirectionalCollection：提供双向遍历能力</li><li>RandomeAccessCollection：继承自BidirectionalCollection，保证计算索引和移动索引位置都是常数时间操作</li><li>LazySequenceProtocol: 只有在开始遍历是才计算其中元素的序列</li><li>LayzCollectionProtocol：和LazySequenceProtocol类似，只不过额外支持Collection的能力</li></ul><h2 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h2><ul><li>Sequence代表一系列相同类型的值</li><li>支持使用for进行迭代<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Sequence</span> &#123;<br>    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Element</span><br>    <span class="hljs-comment">// 约束迭代器的元素类型和自身元素类型一致</span><br>    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Iterator</span>: <span class="hljs-type">IteratorProtocol</span> <span class="hljs-keyword">where</span> <span class="hljs-type">Iterator</span>.<span class="hljs-type">Element</span> <span class="hljs-operator">==</span> <span class="hljs-type">Element</span><br>    <span class="hljs-comment">// 必要方法，获取迭代器</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeIterator</span>() -&gt; <span class="hljs-type">Iterator</span><br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>迭代器的作用：每次生成一个值并管理迭代状态<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">IteratorProtocol</span> &#123;<br>    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Element</span><br>    <span class="hljs-comment">// 必要方法，next</span><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">next</span>() -&gt; <span class="hljs-type">Element</span>?<br>&#125;<br></code></pre></td></tr></table></figure></li><li>迭代器只允许单向迭代</li><li>当我们自己实现了Sequence时，就可以调用许多便捷方法了，如contains（因为Protocol对方法有默认实现）</li><li>迭代器一般是具有值语义的，即也有例外，比如AnyIterator，其内部就封装了一个类类型的迭代器，所以具有引用语义</li><li>可以通过函数闭包创建AnyIterator，并通过将其传递给AnySequence方便的创建序列，但是性能上会有所损耗</li><li>也可以通过sequence函数来方便的创建Sequence，性能也会有所损耗</li><li>注意Sequence本身并<strong>不保证能够对Sequence多次遍历的结果相同</strong>，要多次遍历，需要使用Collection</li></ul><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><ul><li>支持多次遍历并且每次遍历的结果一致</li><li>支持下标访问</li><li><strong>Collection是有限的</strong>，但是Sequence可以是无限的</li><li>Collection有关联的SubSequence，表示Collection的一个切片</li><li>自己实现Collection，略</li><li>实现的Collection可以遵守ExpressibleByArrayLiteral，这样可以方便的使用数组创建</li><li>Collection中的一些关联类型都有默认的实现，比如Indices的默认类型是DefaultIndices&lt;Self&gt;，有时通过实现自定义的关联类型，有助于性能优化，比如将DefaultIndices替换为Range，从而避免对Self的引用，从而避免在迭代时修改Collection而可能造成的额外的COW</li></ul><h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><ul><li>Index表示Collection中的位置</li><li>每个Collection都有startIndex和endIndex，注意endIndex是最后一个元素的<strong>下一个位置</strong>，也就是说endIndex实际是个终止哨岗</li><li>Index不必是Int，但必须是Comparable的</li><li>使用Index作为下标操作返回的是非可选值，因为Index必须由开发者保证是有效的</li><li>当Collection改变时，Index将会失效</li><li>Collection和其切片类型共享Index</li><li>可以调用Collection的indexAfter方法来步进Index</li><li>自定义集合Index，不一定是整数，只要实现时保证语义即可和对应方法即可</li></ul><h2 id="SubSequence"><a href="#SubSequence" class="headerlink" title="SubSequence"></a>SubSequence</h2><ul><li>Collection中有个关联类型叫做SubSequence，SubSequnce本身也是符合Collection的，默认实现时Slice&lt;Self&gt;</li><li>SubSequence和原Collection共享内部存储</li><li>为啥不叫SubCollection而是叫SubSequence呢？别问，问就是历史遗留问题（之前SubSequence是作为Sequence的关联类型的</li><li>SubSequence适合持有中间结果，因为内存开销低。但是不建议长时间持有SubSequence，可能造成内存泄漏，因为SubSequence持有了原Collection</li><li>可以将SubSequence转换为Collection以创建副本</li><li>SubSequence的默认实现时Slice类型，实际只是封装了Range+Collection</li><li>SubSequence和Collection共享Index，注意下标越界</li></ul><h2 id="专门的Collection类型"><a href="#专门的Collection类型" class="headerlink" title="专门的Collection类型"></a>专门的Collection类型</h2><ul><li>Collection协议不提供从后往前移动Index，不提供插入、删除、替换等改变Collection的操作，为此标准库提供了几种特定类型的Collection以宽展功能<ul><li>BidirectionalCollection: 支持双向遍历</li><li>RandomAccessCollection: 支持高效随机访问</li><li>MutableCollection: 支持下标赋值</li><li>RangeReplaceableCollection: 支持范围替换（进而支持插入、删除）</li></ul></li><li>BidirectionalCollection：通过index(before:)索引前移，这种能力一般来说是保证往后移动index的性能是常量级别的，基于此，该协议还提供reversed、removeLast、suffix等操作，注意reversed并不是真的将集合倒转，而是使用特定的索引从后往前遍历罢了，标准库中的大部分Collection同时也是该协议</li><li>RandomAccessCollection:支持最高效的元素存取，需要保证能够在常数时间内完成索引计算</li><li>MutableCollection: 支持原地元素修改，索引必须针对下标提供setter方法。注意该协议只支持改变元素值，但不支持修改Collection的大小和元素位置，所以满足这个协议的只有Array，而Dict、Set、String都不满足该要求</li><li>RangeReplaceableCollection: 支持添加、删除、范围替换，如String，注意该协议并非对MutableCollection的继承，两者的侧重点不一样</li><li>通过将这些一些进行组合约束，可以确保一些算法是满足语义</li></ul><h2 id="延迟序列"><a href="#延迟序列" class="headerlink" title="延迟序列"></a>延迟序列</h2><ul><li>标准库为延迟求值提供了两个协议LazySequenceProtocol和LazyCollectionProtocol</li><li>使用lazy属性，我们不需要自己实现就可以获取延迟计算的能力</li><li>LazyCollectionProtocol相比于LazySequenceProtocol，可以直接使用索引，只有在获取索引元素时，计算才会发生，而LazySequence只能依次延迟计算每个元素，也就是没有索引功能</li><li>但是使用索引未必就是常量时间的，只不过是将计算延迟罢了</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-协议</title>
    <link href="/2023/12/26/swift-advance-protocol/"/>
    <url>/2023/12/26/swift-advance-protocol/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>之前在了解泛型实现原理时，我们知道Swift的泛型使用协议的PWT来动态派发对协议函数的调用，协议和泛型一般同时出现，否则仅用泛型的功能不够强大</li><li>protocol可以被extension，只有protocol中的方法会被动态派发</li><li>被extension的protocol可以约束协议中的泛型所符合的要求来特殊化协议，称为条件化扩展，eg.<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">// 该扩展协议的含义，所有的元素都要符合Comparable</span><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Sequence</span> <span class="hljs-title class_">where</span> <span class="hljs-title class_">Element</span>: <span class="hljs-title class_">Comparable</span><br></code></pre></td></tr></table></figure></li><li>protocol可以继承</li><li>protocol可以组合</li><li>当protocol的实现依赖于其他协议，被称为条件化实现,eg.<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">// 该扩展协议的含义，当Array中元素符合Equatables时，Array才符合Equatable</span><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Array</span>: <span class="hljs-title class_">Equatable</span> <span class="hljs-title class_">where</span> <span class="hljs-title class_">Element</span>: <span class="hljs-title class_">Equatable</span><br></code></pre></td></tr></table></figure></li><li>protocol可以有多个关联类型，如Element，其表示特定类型的占位符，实现协议的特定类型需要定义该具体的类型</li></ul><h2 id="protcol目击者"><a href="#protcol目击者" class="headerlink" title="protcol目击者"></a>protcol目击者</h2><ul><li>所谓protocol目击者，可以理解为具有具体类型的类型实例方法</li><li>目击者，即witness，个人理解翻译为证明者，即向编译器证明这个类型确实实现了协议所规定的方法，也包含了实现的方法的相关信息，编译器可以通过witness拿到要调用的具体方法</li><li>swift中的协议目击者是编译器生成并自动传递的，在调用协议方法的地方，会转换为对协议目击者方法的调用</li></ul><h2 id="条件化protocol实现"><a href="#条件化protocol实现" class="headerlink" title="条件化protocol实现"></a>条件化protocol实现</h2><ul><li>其本质就是对其中的关联类型提供目击者</li></ul><h2 id="protocol继承"><a href="#protocol继承" class="headerlink" title="protocol继承"></a>protocol继承</h2><ul><li>其本质也是通过协议目击者的组合实现</li></ul><h2 id="使用protocol进行设计"><a href="#使用protocol进行设计" class="headerlink" title="使用protocol进行设计"></a>使用protocol进行设计</h2><ul><li>协议扩展功能extension protcol，可以在协议总添加方法实现调用协议所规定的方法，调用规定的方法是动态派发的</li><li>协议扩展和类型扩展可以重复定义同一个函数<ul><li>通过类型直接调用同名函数，则调用的是类型扩展中的函数</li><li>通过协议扩展中的方法调用同名函数，则调用的是协议扩展中的函数<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">DrawingContext</span> &#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">DrawingContext</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addCircle</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这是协议扩展中的addCircle&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">DrawingContext</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">drawSomething</span>() &#123;<br>        addCircle()<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SVG</span>: <span class="hljs-title class_">DrawingContext</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addCircle</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这是类型扩展中的addCircle&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> svg <span class="hljs-operator">=</span> <span class="hljs-type">SVG</span>()<br><span class="hljs-comment">// 会调用类型扩展中的addCircle</span><br>svg.addCircle()<br><span class="hljs-comment">// 调用协议扩展中的addCircle</span><br>svg.drawSomething()<br></code></pre></td></tr></table></figure></li></ul></li><li>记住：<strong>只有协议中要求的方法才能被动态派发到具体的类型的实现</strong>，而对于协议扩展中实现的方法，则不能动态派发，在编译期间就会被确定，并且是优先静态派发到协议扩展中的方法</li><li>协议的要求的方法可以有默认实现，并且可以被重写</li><li>协议可以被组合：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">typealias</span> <span class="hljs-type">Codable</span> <span class="hljs-operator">=</span> <span class="hljs-type">Decodeable</span> &amp; <span class="hljs-type">Encodable</span><br></code></pre></td></tr></table></figure></li><li>协议可以继承</li></ul><h2 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h2><ul><li>有些protocol需要约束相关类型，可以使用关联类型</li><li>使用associatedtype Element标记一个关联类型，他实际就是一个具体类型的占位符，在实现协议时需要使用typealias Element &#x3D; XXX指定这个占位符的具体类型</li><li>当编译器可以自动推断出关联的具体类型时，可以省略typealias</li><li>关联类型可以指定默认类型</li><li>等等，关联类型和泛型是不是看着很相似？确实如此，他们的区别在于，关联类型是类型设计者显式确定的，但是泛型则是调用者在调用时通过编译器创建的</li></ul><h2 id="Self"><a href="#Self" class="headerlink" title="Self"></a>Self</h2><ul><li>在协议或扩展中，Self是指实现了该协议的类型本身</li></ul><h2 id="再谈实现协议"><a href="#再谈实现协议" class="headerlink" title="再谈实现协议"></a>再谈实现协议</h2><ul><li>建议：不要让不属于你的类型去实现一个不属于你的协议，因为可能不属于你的类型的作者再会自己添加一个协议，这可能导致不符合预期</li></ul><h2 id="存在体"><a href="#存在体" class="headerlink" title="存在体"></a>存在体</h2><ul><li>严格来说，Swift中的协议不是一个特定类型，只能用来约束泛型，但实际上，使用时还是能够以类似a: P的方式声明</li><li>这个实际是编译器为我们处理了，当我们将协议当做类型使用时，<strong>编译器会创建一个包装类型，称为存在体</strong></li><li>所谓存在，就是告知你，确实存在那么一个类型符合该协议</li><li>Swift 5.6之前，使用的语法直接就是xx: P，但是Swift其实并不鼓励直接使用协议作为类型，Swift 5.6就提出了any P更加清晰的表示这是符合某个协议的类型的语义，用来取代这种隐式的表达</li><li>any P可以看做等价于Any<P>，即创建了封装任意符合协议的Any类型，这层封装称为<strong>存在体容器</strong>，由于存在体容器需要记录协议的协议目击者信息，协议方法越多，存在体容器越大</li><li>当我们使用any P的时候，我们的语义是接受<strong>任意符合P的类型</strong>，注意这里是任意，而不是特定！！！和下面的some P区分开</li><li>存在体和泛型，any P有时和T: P作用类似，但是any P的更加灵活，调用时需要借助于PWT，需要处理所有可能的实现协议的类型，所以开销也更大。而T:P编译器会有可能生成特化版本，不需要记住与PWT，性能更佳</li><li><strong>如果协议中存在对Self和关联类型的要求，则无法调用协议中对参数绑定了Self或关联类型的方法</strong>，因为存在体会抹除类型具体信息，编译器不确定传递的存在体的类型是否和实现了协议的类型的类型是一致的<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Equatable</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">==</span> (<span class="hljs-params">lhs</span>: <span class="hljs-keyword">Self</span>, <span class="hljs-params">rhs</span>: <span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-type">Bool</span><br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span>: <span class="hljs-title class_">Equatable</span> &#123;<br><br>&#125;<br><br><span class="hljs-comment">// 错误，编译器不确定lhs和rhs中的Self类型是否一致</span><br><span class="hljs-keyword">let</span> s: <span class="hljs-type">Equatable</span> <span class="hljs-operator">=</span> <span class="hljs-type">S</span>()<br></code></pre></td></tr></table></figure>这里，Equatable就无法被当做存在体类型使用，因为其方法参数中规定了Self的要求。注意，如果是返回值的类型是Self，则是可以的，编译器会将返回值类型再次打包为存在体容器。</li><li>对于Self的要求同样适合关联类型</li><li>协议不能遵守本身，所以也就无法将存在体any P传递给接受一个T:P的泛型参数,这一规则对于init方法和静态方法适用，因为这些函数隐式的接受Self为参数<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">P</span> &#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">test</span>&lt;<span class="hljs-type">T</span>: <span class="hljs-type">P</span>&gt;(<span class="hljs-params">t</span>: <span class="hljs-type">T</span>) &#123;<br>    <span class="hljs-built_in">print</span>(t)<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span>: <span class="hljs-title class_">P</span> &#123;<br>    <br>&#125;<br><br><span class="hljs-comment">// 错误： protocol type &#x27;P&#x27; cannot conform to &#x27;P&#x27;</span><br><span class="hljs-comment">// 也就是P的存在体类型不能符合P本身</span><br><span class="hljs-keyword">let</span> s1: <span class="hljs-type">P</span> <span class="hljs-operator">=</span> <span class="hljs-type">S</span>()<br>test(t: s1)<br><br><span class="hljs-comment">// 正确，传递的是结构体具体类型而非存在体类型</span><br><span class="hljs-keyword">let</span> s2: <span class="hljs-type">S</span> <span class="hljs-operator">=</span> <span class="hljs-type">S</span>()<br>test(t: s2)<br></code></pre></td></tr></table></figure></li><li>有一个特例，Error协议的存在体本身确实是遵守Error协议，但是它能作为参数传递给T: Error泛型参数，这个是编译器的白名单，由于Error是个标记协议，所以这么做不存在问题</li><li>不要过早使用存在类型，存在体类型虽然方便，但是会抹除具体类型信息，并且会导致性能开销，<strong>最好是使用代用约束的泛型</strong></li></ul><h2 id="不透明类型"><a href="#不透明类型" class="headerlink" title="不透明类型"></a>不透明类型</h2><ul><li>some P，是<strong>某个满足P的具体类型</strong>，注意这里不是任意类型，和上面的any P区分开</li><li>和any P不同，any P由于能够接受任意符合P的类型，会抹除掉具体类型的信息，而some P则会保留，只是用户无法获知而已</li><li>some P在Swift UI中大量使用，如some View。这使得深层嵌套的泛型更加容易使用并且隐藏实现细节，比如Swift UI每加一个修饰符，返回的具体类型会增加泛型的嵌套层次，显然不便于书写，同时也暴露了内部实现细节，这里用some View表示我们不care，编译器知道就好</li><li>不透明类型的规则：<ul><li>可以出现在函数的返回类型、属性、变量或者下标中</li><li>通常来说约束时协议，但也可以是具体类型，如some UIView表示任意特定的UIView子类</li><li>返回不透明类型的函数必须在所有return分支中返回相同的类型 （所以这里又不得不提到Swift UI中resultBuilder的伟大，他将分支表达式合并为相同的类型）</li><li>返回不透明类型的函数必须在每次调用时都返回相同的具体类型</li><li>可以通过动态转换还原成具体类型</li></ul></li></ul><h2 id="类型消除器"><a href="#类型消除器" class="headerlink" title="类型消除器"></a>类型消除器</h2><ul><li>在标准库中，我们可以将一个具体的Sequence类型转换为一个AnySequence型，这个AnySequence就是类型消除器，但会引入额外的开销</li><li>手动实现一个类型消除器的思路，实际就是利用泛型，创建一个只暴露内部元素泛型类型的封装类型，对协议方法的调用再内部通过方法转发到到对具体类型的调用<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">// 原始协议</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Restorable</span> &#123;<br>    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">State</span>: <span class="hljs-type">Codable</span><br>    <span class="hljs-keyword">var</span> state: <span class="hljs-type">State</span> &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>&#125;<br>&#125;<br><br><span class="hljs-comment">// 实现了协议并只关心State类型的类型的基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnyRestorableBoxBase</span>&lt;<span class="hljs-title class_">State</span>: <span class="hljs-title class_">Codable</span>&gt;: <span class="hljs-title class_">Restorable</span> &#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">init</span>() &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> state: <span class="hljs-type">State</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123;<span class="hljs-built_in">fatalError</span>()&#125;<br>        <span class="hljs-keyword">set</span> &#123;<span class="hljs-built_in">fatalError</span>()&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 上面的类型的实现子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnyRestorableBox</span>&lt;<span class="hljs-title class_">R</span>: <span class="hljs-title class_">Restorable</span>&gt;: <span class="hljs-title class_">AnyRestorableBoxBase</span>&lt;<span class="hljs-title class_">R</span>.<span class="hljs-title class_">State</span>&gt; &#123;<br>    <span class="hljs-keyword">var</span> r: <span class="hljs-type">R</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">r</span>: <span class="hljs-type">R</span>) &#123;<br>        <span class="hljs-keyword">self</span>.r <span class="hljs-operator">=</span> r<br>    &#125;<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> state: <span class="hljs-type">R</span>.<span class="hljs-type">State</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123; r.state &#125;<br>        <span class="hljs-keyword">set</span> &#123; r.state <span class="hljs-operator">=</span> newValue &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 对外暴露的类型，调用方只需要关心State类型，内部封装了上面类型的子类的实例，对协议方法的调用将被转发，外界无需关心具体类型</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AnyRestorable</span>&lt;<span class="hljs-title class_">State</span>: <span class="hljs-title class_">Codable</span>&gt;: <span class="hljs-title class_">Restorable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> box: <span class="hljs-type">AnyRestorableBoxBase</span>&lt;<span class="hljs-type">State</span>&gt;<br>    <br>    <span class="hljs-keyword">init</span>&lt;<span class="hljs-type">R</span>&gt;(<span class="hljs-params">r</span>: <span class="hljs-type">R</span>) <span class="hljs-keyword">where</span> <span class="hljs-type">R</span>: <span class="hljs-type">Restorable</span>, <span class="hljs-type">R</span>.<span class="hljs-type">State</span> <span class="hljs-operator">==</span> <span class="hljs-type">State</span> &#123;<br>        <span class="hljs-keyword">self</span>.box <span class="hljs-operator">=</span> <span class="hljs-type">AnyRestorableBox</span>(r: r)<br>    &#125;<br>    <br>    <span class="hljs-keyword">var</span> state: <span class="hljs-type">State</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> box.state &#125;<br>        <span class="hljs-keyword">set</span> &#123; box.state <span class="hljs-operator">=</span> newValue&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>当然，类型消除器也可以用any P更加方便的实现，此处略</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-泛型</title>
    <link href="/2023/12/25/swift-advance-generic-type/"/>
    <url>/2023/12/25/swift-advance-generic-type/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>泛型编程的主要目的类型安全和代码重用。泛型可以认为是多态的一种实现方式，所谓多态，就是多个类型可以调用同一个名称的接口。因为泛型只是具体类型不同，接口名称都是相同的，所以可以认为是一种多态的表现。<br>而多态其实还有其他不同的表现形式：</p><ul><li>专属多态（特设多态）：<ul><li>概念：为特定类型的任意集合定义一个共同的接口</li><li>实现1：函数重载，函数名称相同，但传入的参数类型和个数不同</li><li>实现2：协议，多个类型实现同一个协议，这是更结构化的专属多态</li></ul></li><li>子类型多态：<ul><li>概念：一个类型名称表示很多具体类型，这些类具有共同的超类</li><li>实现：同一个函数如果接受父类作为参数，那么也可以传递子类作为参数</li></ul></li><li>参数化多态：<ul><li>概念：指定一个抽象符号表示任意类型</li><li>实现：泛型，接受泛型化参数的函数称为泛型函数，泛型化的参数被称为泛型，也是下面讨论的主要部分</li></ul></li></ul><h2 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h2><ul><li>函数和方法、class、struct和enum都是泛型类型</li></ul><h2 id="泛型和Any"><a href="#泛型和Any" class="headerlink" title="泛型和Any"></a>泛型和Any</h2><ul><li>泛型相比较Any，对于编译器来说能够获得更多的信息，更加安全，但同时也会增大编译产生的体积，因为对于一个具体化的泛型类型，编译器就要生成一个类型</li><li>为每个泛型版本在调用时生成一个特定版本，这称为泛型特化，是C++的默认模板实现，但是对于Swift来说，默认不是，Swift默认是通过额外的间接层将泛型函数调用进行改造以便使其接受任意类型的，但我们可以开启Swift的编译优化选项，使其进行泛型特化</li></ul><h2 id="基于泛型的设计"><a href="#基于泛型的设计" class="headerlink" title="基于泛型的设计"></a>基于泛型的设计</h2><ul><li>主要是抽象出共同的逻辑，将具体类型给泛型化</li></ul><h2 id="泛型的静态派发"><a href="#泛型的静态派发" class="headerlink" title="泛型的静态派发"></a>泛型的静态派发</h2><ul><li>Swift支持函数重载，并且对重载函数的调用确定发生在<strong>编译期间</strong></li><li>Swift只会使用调用侧模块的可用信息来决定调用哪个版本的函数，eg.<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">format</span>&lt;<span class="hljs-type">A</span>&gt;(<span class="hljs-params">value</span>: <span class="hljs-type">A</span>) -&gt; <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-type">String</span>(describing: value)<br>&#125;<br><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">format</span>(<span class="hljs-params">value</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-string">&quot;+<span class="hljs-subst">\(value)</span>+&quot;</span><br>&#125;<br><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">process</span>&lt;<span class="hljs-type">B</span>&gt;(<span class="hljs-params">input</span>: <span class="hljs-type">B</span>) -&gt; <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> formatted <span class="hljs-operator">=</span> format(value: input)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;-<span class="hljs-subst">\(formatted)</span>-&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 这里只会调用泛型版本的函数，而不是更加具体的函数</span><br><span class="hljs-comment">// 因为函数重载发生在编译器，编译器并不确定类型是否是Int，所以只能匹配到更加宽松的版本</span><br>process(input: <span class="hljs-number">1</span>) <span class="hljs-comment">// - 1 -</span><br><br></code></pre></td></tr></table></figure></li><li>协议中的函数则是动态派发的，在运行时才决定调用哪个版本的函数</li></ul><h2 id="泛型的工作方式"><a href="#泛型的工作方式" class="headerlink" title="泛型的工作方式"></a>泛型的工作方式</h2><ul><li>Swift默认是通过间接层来实现一个可以处理任意类型</li><li>间接层需要处理的问题<ul><li>需要知道T的大小</li><li>需要知道如何复制T和销毁T（比如是否需要引用计数）</li><li>需要知道调用重载函数的地址</li></ul></li><li>间接层提供的解决方案<ul><li>Swift使用指针传递函数参数、返回值和变量</li><li>对每个泛型参数，编译器会传递T的类型元数据，包括值目击表VWT，其包含如何对T进行操作，如复制、引用计数</li><li>对T上的每个约束，传递协议目击表PWT，其作用是在运行时决定调用哪个函数，所以泛型机会都是和协议搭配使用的，否则没有PWT功能化大大降低</li></ul></li></ul><h2 id="泛型特化"><a href="#泛型特化" class="headerlink" title="泛型特化"></a>泛型特化</h2><ul><li>之前说过，泛型特化是C++模板的默认实现，但不是Swift的默实现，所以默认是存在一定运行时开销的</li><li>可以Swift -O开启编译优化，但要更好的帮助编译器需要：<ul><li>全模块优化（whole moudle optimize）： 即使开启了优化，默认也只在同一个文件中生效，如果需要整个模块生效，需要开启该选项</li><li>全模块优化还会开启一些额外的优化，如静态派发等等</li><li>将泛型函数标记@inlinable以便其他模块进行导出，这使得编译器容易发现具体类型并进行特化</li></ul></li><li>总体来看，Swift的泛型系统兼具C++的完全特化，又具有Java的只将泛型作为类型检查的能力</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-字符串</title>
    <link href="/2023/12/24/swift-advance-string/"/>
    <url>/2023/12/24/swift-advance-string/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Swift在字符串的实现上尽力去满足Unicode标准，String是Character的值的集合，而Character是人类可读的单个字符，每个Character由多个Unicode标量组成。<br>但是为了实现这种复杂性，Swift会牺牲一些便捷性，比如不能直接通过str[idx+1]访问下一个字符，并且String不支持随机访问</p><h2 id="Unicode，而非固定宽度"><a href="#Unicode，而非固定宽度" class="headerlink" title="Unicode，而非固定宽度"></a>Unicode，而非固定宽度</h2><ul><li>一切都要从Unicode开始说起<ul><li>一开始英文字符由asii码规定，只需要1个字节就可以编码，每个字符的宽度的大小固定</li><li>后来，随着计算机的普及，更多的字符需要被编码，ascii码显然就不够用了</li><li>Unicode就应运而生，他的目标是让天下没有难编码的字符！</li><li>一开始Unicode使用2字节固定宽度进行编码，称为UCS-2，后来不够用，所以现在的Unicode是可变长编码<ul><li>Unicode字符，由一个或者多个Unicode标量组成，每个字符对应一个编码点</li><li>一个Unicode标量可以被编码为多个编码单元</li><li>编码点一般使用U+前缀表示</li><li>Unicode标量在大多数情况下都和编码点相同，在Swift中用Unicode.Scalar表示</li><li>UTF8和UTF16都属于变长编码的编码方式，即每个标量编码的长度并不一致，编码方式中的最小实体称为编码单元，在Swift中用Unicode.UTF8.CodeUnit表示</li><li>单个字符在大多数情况下是由单个标量组成，也可以通过多个标量组成</li><li>总结下：1个可见字符-&gt;1个以上标量 1个标量-&gt;1个以上编码单元，如图所示<br>  <img src="/../images/image-21.png" alt="Alt text"></li></ul></li></ul></li></ul><h2 id="字位簇和标准等价"><a href="#字位簇和标准等价" class="headerlink" title="字位簇和标准等价"></a>字位簇和标准等价</h2><ul><li>标准等价：即一个可见字符可以是单个标量，也可以是多个标量的组合，对于用户来说是等价的，Swift可以正确处理，但对于OC来说，只会按照编码单元去判断</li><li>Unicode为啥要支持两种方式表示同一个字符呢：<ul><li>为了兼容之前的一些编码方式，因为有些预先组合好的字符在别的编码中已经存在了，在Unicode中需要将其视为单个字符</li><li>为了支持以灵活的方式构造展现一个字符</li><li>个人理解，预先组合的字符一定可以表示为多个标量的组合，但反之不一定，因为组合是无穷的</li><li>注意，组合不是任意的，有些标量是可以无限制被添加的，有些则不行</li></ul></li><li>对于emoj，也是Unicode标量组合形成单个字符的典型例子</li><li>那么这些字符是如何被渲染出来的，则是底层字符渲染系统的任务，如果渲染系统无法识别，则会将每个标量单独渲染出来，但是Swift仍然会将语法上有效的标量组合认为是单个字符</li><li>其实OC也有能够支持Unicode标准的api，只不过Swift支持Unicode规范是默认行为</li></ul><h2 id="String和Collection"><a href="#String和Collection" class="headerlink" title="String和Collection"></a>String和Collection</h2><ul><li>String是Character的集合,符合Collection协议</li><li>String是集合，但又不是完全的集合，它不支持随机访问，Swift实现的是BidirectionalCollection，即只能从头或从尾部进行迭代，每次迭代一个字符</li><li>String中的indices代表的是每个字符的索引集合</li><li>String不支持只通过下标修改单个字符，也就是不支持MutableCollection协议。原因说过，因为编码时可变的，替换单个字符需要移动前后的数据。但String实现了RangeReplaceableCollection协议，这允许我们进行范围替换</li></ul><h2 id="String索引"><a href="#String索引" class="headerlink" title="String索引"></a>String索引</h2><ul><li>String不允许直接使用下标索引操作，之前说过，String不能随机访问，所以访问一个字符的时间复杂度是n，所以为了防止我们写出性能糟糕的代码，Swift不支持直接使用下标访问String（个人理解，这牺牲了易用性真的得不偿失…</li><li>String采用String.Index进行索引，其本质是一个字节偏移量。刚开始拿到该字节偏移量的时间复杂度是n，但一旦拿到，则时间复杂度降低为1</li><li>通过将字符串写在#的包围中，可以不必对字符串中的引号进行转义</li></ul><h2 id="Substring"><a href="#Substring" class="headerlink" title="Substring"></a>Substring</h2><ul><li>和所有Collection一样，String有个特定的SubSequence，称为Substring,类似于ArraySlice</li><li>Substring和String的接口几乎一样，这是通过StringProtocol实现的</li></ul><h2 id="编码单元视图"><a href="#编码单元视图" class="headerlink" title="编码单元视图"></a>编码单元视图</h2><ul><li>String允许我们以Unicode标量和特定编码方式的编码单元来查看</li><li>可以直接将utf8的String传递给C函数指针，这是编译器优化过的，如果是utf16，编译器会先进行编码转换，然后传递</li><li>注意，这些视图仍然是不支持随机访问，只支持通过String.Index访问，由于String.Index一般是位于边界的，所以一般从String获取的Index用于视图上不会有啥问题，反之，如果是从视图创建一个String.Index再用于String，则可能崩溃（嘛，不一定在边界了</li></ul><h2 id="String和Foundation"><a href="#String和Foundation" class="headerlink" title="String和Foundation"></a>String和Foundation</h2><ul><li>String和NSString和无缝转换，并且如果引入了Foundation库，String可以使用NSString的api</li><li>NSString的默认编码时UTF16，而String的默认编码时UTF8，所以在调用NSString时会存在一定开销</li><li>Foundation中的CharacterSet，实际上的含义就是Unicode标量的集合，方便我们判断一个字符是否在某个特定集合中（如字母、数字）</li><li>Foundation中的一些关于NSString的api可能还不兼容Swift，需要我们手动转换，比如NSString进行正则匹配，返回的基于标量的NSRange，而swift可能并不认为这个标量在String中能独立存在，所以必须转换会Range再判断</li></ul><h2 id="Unicode属性"><a href="#Unicode属性" class="headerlink" title="Unicode属性"></a>Unicode属性</h2><ul><li>在Swift中，CharacterSet的部分功能放到了Unicode.Scalar.Properties中，比如判断是否为emoji</li><li>一些功能在Charater中也有，比如判断一个字符是否为数字</li></ul><h2 id="String和Character的内部结构"><a href="#String和Character的内部结构" class="headerlink" title="String和Character的内部结构"></a>String和Character的内部结构</h2><ul><li>String也是实现了COW的</li><li>对于长度小于16个编码单元，Swft会进行编译优化，采用内联方式存储</li><li>Character的内部实际就是长度为1的String</li></ul><h2 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h2><ul><li>String和字符串字面量是不同的，String实际上是实现了ExpressibleByStringLiteral的类型</li><li>我们可以为自己的类型实现ExpressibleByStringLiteral</li></ul><h2 id="String插值"><a href="#String插值" class="headerlink" title="String插值"></a>String插值</h2><ul><li>插值使用ExpressibleByStringInterpolation和StringInterpolationProtocol组成，而ExpressibleByStringInterpolation又继承自ExpressibleByStringLiteral</li><li>标准库中实现了一个DefaultStringInterpolation，其符合tringInterpolationProtocol，这使得我们可以直接进行字符串插值</li><li>我们可以自行实现相关协议，为我们自己的类型实现字String插值来转换为对应的对象</li></ul><h2 id="定制字符串描述"><a href="#定制字符串描述" class="headerlink" title="定制字符串描述"></a>定制字符串描述</h2><ul><li>实现CustomStringConvertible和CustomDebugStringConvertible在print时自定义输出内容</li><li>LosslessStringConvertible：继承自CustomStringConvertible，用于将字符串转换会自定义类型，但是很少使用（一般都用codeable进行序列化）</li></ul><h2 id="文本输出流"><a href="#文本输出流" class="headerlink" title="文本输出流"></a>文本输出流</h2><ul><li>print和dump默认是输出到标注输出，但实际上，只要对象支持TextOutputStream协议就可以重定向print和dump到该对象，比如String</li><li>_playgroundPrintHook是个全局变量，可以hook输出的print的内容</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-枚举</title>
    <link href="/2023/12/24/swift-advance-enum/"/>
    <url>/2023/12/24/swift-advance-enum/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>struct和class有时也被称为记录类型，一个记录是任意个属性组成。而枚举称为标签联合或变体类型，它和记录类型也一样强大。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>enum由任意个case组成，每个case有关联值</li><li>Optional和Result实际上都是枚举</li><li>枚举时值类型，和结构体类似，但是没有存储属性，我们可以将关联值视为存储属性</li></ul><h2 id="总和类型和乘积类型"><a href="#总和类型和乘积类型" class="headerlink" title="总和类型和乘积类型"></a>总和类型和乘积类型</h2><ul><li>居留元：简单理解就是一个类型的可能的取值，类型可以理解为取值的集合</li><li>strcut和class中的居留元数量，等于其成员的居留元数量的乘积，因为被称为乘积类型</li><li>enum的居留元数量，等于其所有case的累加</li></ul><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><ul><li>switch通过方便的语法，可以比较成员和提取关联值，这一机制称为模式匹配，类似于<strong>正则匹配</strong></li><li>支持的模式类型<ul><li>通配符，如_,匹配任意值并忽略</li><li>元祖模式，如case (let x, 0, _)</li><li>美爵成员模式， 如.failure(let error)</li><li>值绑定模式，如let x，注意let (x, y) &#x3D; (let x, let y)，但是let x，y则表示绑定x，并且和y进行比较</li><li>可以在绑定模式添加where限定条件，如.success(let status) where 200..&lt;300 ~&#x3D; httpStatus</li><li>如果是在单个case去匹配多个模式，则每个模式中let的数量、变量名和类型均要相同</li><li>可选值模式，let x?，即可选值x不为nil时才匹配并绑定到x</li><li>类型转换模式，let x as Type</li><li>表达式模式，将输入值和模式作为参数传递给定义在标准库中的~&#x3D;操作符进行判断，对于实现了Equatable协议的类型，~&#x3D;的默认行为是转发到&#x3D;&#x3D;</li><li>标准库为范围提供~&#x3D;的重载，可以方便的检查某个值是否在范围内</li><li>可以通过重载~&#x3D;操作符来扩展模式匹配，返回true表示匹配成功</li></ul></li><li>其他情景中的模式匹配：模式匹配并不是enum和switch的专属，我们可以在解构元祖，for循环、catch、if、guard中都可以使用。for case、while case仅在匹配成功的情况下才会执行循环体</li></ul><h2 id="使用enum进行设计"><a href="#使用enum进行设计" class="headerlink" title="使用enum进行设计"></a>使用enum进行设计</h2><ul><li>switch的完备性：即编译器保证所有的分支均能被覆盖到，否则报错</li><li>避免产生非法状态：因为enum的状态有限，每个状态都是单一的，使用enum更加能确保状态的合法性</li><li>enum是实现状态的绝佳选择：比如loading、success、failed，略</li></ul><h2 id="选择enum还是struct"><a href="#选择enum还是struct" class="headerlink" title="选择enum还是struct"></a>选择enum还是struct</h2><ul><li>enum和struct是类似的，有时都能完成相同的事情，比较如下：<ul><li>enum更精确、状态有限、可以使用switch</li><li>struct则可以方便扩展、包含私有成员</li><li>即struct相对来说扩展性更好，更灵活，但enum更加精确，更不容易出错（嘛，凡事皆有代价</li></ul></li></ul><h2 id="enum和protocol的相似之处"><a href="#enum和protocol的相似之处" class="headerlink" title="enum和protocol的相似之处"></a>enum和protocol的相似之处</h2><ul><li>都能表达<strong>某种类型之一</strong>的语义，enum是通过case，而protocol则是通过具体类型</li><li>如果我们侧重于添加成员，则用protocol更好，因为修改enum的case会破坏源码</li></ul><h2 id="使用enum实现递归数据结构"><a href="#使用enum实现递归数据结构" class="headerlink" title="使用enum实现递归数据结构"></a>使用enum实现递归数据结构</h2><ul><li>比如用enum实现树形结构</li><li>用indirect case让某个case表示为引用，indirect只能用在enum上，可以用在case前面，也可以直接加载enum前面</li><li>enum的大小是其最大case的大小+元数据，和c语言中的union及其类似，每个case的大小是其关联值的大小，但如果是indirect的，则是固定大小8（理解为指针嘛</li></ul><h2 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h2><ul><li>enum可以指定原始值类型，即每个case对应一个固定的rawValue，和关联值无关，一般就是一个整数或字符串</li><li>RawRepresentable: 该协议的方法，即init(rawValue:)，RawValue类型为String、整数、浮点类型的enum默认符合，如果需要自定义，可以显示指定enum符合该协议，自己实现init方法，但是注意<strong>rawValue必须唯一！！</strong></li><li>RawRepresentable也可以由struct和class来实现</li><li>注意rawValue并不是enum中存储的，不影响enum的大小，其更加类似于于计算属性</li></ul><h2 id="列举枚举值"><a href="#列举枚举值" class="headerlink" title="列举枚举值"></a>列举枚举值</h2><ul><li>没有关联值的enum，默认是可列举的，我们只需要将其声明为符合CaseIterable，编译器会为我们实现</li><li>CaseIterable也可以用于struct和class，我们自己实现allCases方法即可</li></ul><h2 id="固定和非固定enum"><a href="#固定和非固定enum" class="headerlink" title="固定和非固定enum"></a>固定和非固定enum</h2><ul><li>可能增加case的enum称为非固定的，为了应对以后二进制sdk中新增enum的case，我们一般需要加一个default</li><li>apple的sdk库一般都是弹性库，即可能变化，其中的enum一般都是非固定enum（Optional是个例外</li><li>@unknown default：前面的@unknown告知编译器，这个default只是为了应对为二进制sdk中了可能增加的enum的case，而如果在本次编译时就知道有些case没有处理，仍然要给我报错</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-结构体和类</title>
    <link href="/2023/12/23/swift-advance-struct-and-class/"/>
    <url>/2023/12/23/swift-advance-struct-and-class/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>结构体是值类型，类是引用类型。</p><h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><ul><li>值类型：当赋值时会被copy一份，也就是说，每个值类型变量的数据都是独立的，其变量本身的地址中存储的就是值，具有这种行为的类型称为具有<strong>值语义</strong></li><li>引用类型，变量本身的地址存储的是值的引用（可能是地址，也可能是其他的间接句柄），而非值，具有这种行为的类型称为具有引用语义</li><li>说白了还是和其他语言一样，就是直接存储值还是存储地址的区别</li></ul><h2 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h2><ul><li>对struct中的属性修改，本质是创建了一个新的struct替换了原来的struct</li><li>推荐使用var来声明struct中的属性</li><li>struct中的方法默认不能修改结构体本身，如有必要，添加mutating关键字。属性和下标的stter默认都是mutating的</li><li>调用struct的mutating方法，要求struct本身是var的。如果要调用一个let的struct属性setter，可以将该setter标记为nonmutating set，告知编译器该setter不会修改struct</li><li>inout参数：实际的过程是先copy参数，然后修改参数，最后用修改完的参数覆盖原来的值。编译器有时会将这种行为优化为传递引用，但不要依赖这种行为。并且，如果使用了观察者，则无论在函数中修改了多少次，只会在最终被覆盖的时候得到通知</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li>结构体的生命周期很简单，就是含有结构体实例变量的生命周期一致，一旦离开作用域就会被销毁</li><li>类的生命周期，取决于ARC</li><li>由于结构体不存在引用，所以也就无所谓结构体的循环引用问题</li><li>打破类的循环引用，weak或unowned</li><li>unowened实际的作用就是不持有引用，所以允许我们声明为非可选值，而weak引用必须声明为可选值。但是<strong>unowned不安全</strong>，如果释放之后再访问unowned会崩溃（是runtime崩溃，而不是badaccess崩溃，类似于断言）！！！虽然这里Swift只要unowned引用还存在，对象内存就不会释放，但是会标记为无效，即所谓僵尸内存</li><li>Swift中，类不是唯一的引用类型，actor以及函数（包括闭包表达式&amp;方法）都是引用类型</li><li>捕获列表，实际就是常用的在闭包中使用的[weak self]，但是捕获列表中还可以直接创建变量，例如<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Swift">window<span class="hljs-operator">?</span>.onRotate <span class="hljs-operator">=</span> &#123; [<span class="hljs-keyword">weak</span> view, <span class="hljs-keyword">weak</span> myWindow<span class="hljs-operator">=</span>window, x<span class="hljs-operator">=</span><span class="hljs-number">5</span><span class="hljs-operator">*</span><span class="hljs-number">5</span>] <span class="hljs-keyword">in</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="在struct和class中做选择"><a href="#在struct和class中做选择" class="headerlink" title="在struct和class中做选择"></a>在struct和class中做选择</h2><ul><li>结构体的优点是开销小，不用担心循环引用、多线程、继承问题，缺点不如类具有共享的特性</li><li>类则更加灵活和强大，可以使用类实现结构体的值语义，反之则不行</li></ul><h2 id="具有值语义的类"><a href="#具有值语义的类" class="headerlink" title="具有值语义的类"></a>具有值语义的类</h2><ul><li>我们可以final class，并将其中的属性都声明为let来实现值语义（嘛，这显然没有结构体好用</li></ul><h2 id="具有引用语义的结构体"><a href="#具有引用语义的结构体" class="headerlink" title="具有引用语义的结构体"></a>具有引用语义的结构体</h2><ul><li>可以在struct中使用类属性实现引用语义</li><li>所以在strcut中使用类属性要小心，不然可能会意外修改其值语义</li><li>这种设计可以被用于实现COW，见下</li></ul><h2 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h2><ul><li>即COW，实际的意思就是修改时才发生真正的复制，很常见的优化</li><li>自己实现COW，我们需要知道一般的实现原理：在没有发生修改之前，各变量都持有的值的内部都共享一份引用，如果一旦发生修改内部共享存储的行为（调用了set方法或者其他什么的），就将原来的内部共享存储进行copy，修改该copy属性</li><li>查询Swift的引用类型是否只有一个持有者：isKnownUniquelyReferenced，但是注意该函数不是线程安全的，所以多线程对数组append是非线程安全的，该函数的参数是个inout参数，否则在传递参数的时候肯定会进行一次引用，函数功能就失效了<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">HTTPRequest</span> &#123;<br>    <span class="hljs-comment">// 内部判断是否触发copy以实现COW</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> storageForWriting: <span class="hljs-type">HTTPRequest</span>.<span class="hljs-type">Storage</span> &#123;<br>        <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-operator">!</span><span class="hljs-built_in">isKnownUniquelyReferenced</span>(<span class="hljs-operator">&amp;</span>storage) &#123;<br>            <span class="hljs-keyword">self</span>.storage <span class="hljs-operator">=</span> storage.copy()<br>            &#125;<br>            <span class="hljs-keyword">return</span> storage<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> path: <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123; storage.path &#125;<br>        <span class="hljs-keyword">set</span> &#123; storageForWriting.path <span class="hljs-operator">=</span> newValue &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> headers: [<span class="hljs-type">String</span>: <span class="hljs-type">String</span>] &#123;<br>        <span class="hljs-keyword">get</span> &#123; storage.headers &#125;<br>        <span class="hljs-keyword">set</span> &#123; storageForWriting.headers <span class="hljs-operator">=</span> newValue &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>注意willSet会导致COW性能的破坏，因为如果实现了willSet，则编译器在设置新值之前一定会先创建值，那么会导致值中的共享存储的引用增加，导致判断失效，导致必然发生复制</li><li>在SwiftUI中，由于@Pushlied使用了willSet，所以会造成一些性能问题，每次修改@Published属性，都会导致数组的copy</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-属性</title>
    <link href="/2023/12/23/swift-advance-property/"/>
    <url>/2023/12/23/swift-advance-property/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Swift属性分为存储属性和计算属性，属性可以被看做是一种定义在类型上的变量。</p><h2 id="变更观察者"><a href="#变更观察者" class="headerlink" title="变更观察者"></a>变更观察者</h2><ul><li>为属性和变量实现willSet和didSet方法</li><li>观察方法必须在声明属性时就进行定义，而不能在扩展中添加。注意和OC中KVO不同。KVO是外部用来跟踪对象内部变化的手段</li><li>观察者可以在子类中重写属性以实现观察者</li><li>Swift的观察者是纯编译时特性，而KVO则是OC利用runtime实现的动态特性</li></ul><h2 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h2><ul><li>使用lazy var修饰，只有当第一次使用时才会被创建（仅调用1次）</li><li>扩展中只能声明计算属性，不能声明存储&amp;延迟存储属性</li><li>lazy var是mutating性质的，所以如果访问结构体的延迟存储属性，必须将结构体声明为var，所以通常不要在结构体中声明lazy var</li><li>注意，<strong>lazy var存在线程安全问题，多线程情况下可能会被调用多次！！！</strong>，在oc中，懒加载属性实行可能会在多线程情况下造成崩溃<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-comment">// 如果多线程调用，那么当A线程对_object属性覆盖的时候，可能将会导致B线程的_object被提前释放，如果此时B线程恰好正在对释放之前的地址进行发消息，就会造成崩溃</span><br>- (NSObject *)<span class="hljs-keyword">object</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-number">_</span><span class="hljs-keyword">object</span>) &#123;<br>        <span class="hljs-number">_</span><span class="hljs-keyword">object</span> = [NSObject <span class="hljs-keyword">new</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">_</span><span class="hljs-keyword">object</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>需要谨记，在OC中，读取&amp;设置属性在runtime层面上都不是原子性的，如果存在多线程访问，需要考虑崩溃问题</li></ul><h2 id="属性包装"><a href="#属性包装" class="headerlink" title="属性包装"></a>属性包装</h2><ul><li>和resultBuilder一样，propertyWrapper也是很大程度上就是因为SwiftUI而引入的</li><li>当我们使用propertyWrapper时，其实就是告知编译器向对该属性封装为一个结构体&#x2F;类，对该属性的存取转换为对该结构体&#x2F;类中init和属性计算方法的调用<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">@propertyWrapper</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>&lt;<span class="hljs-title class_">A</span>&gt; &#123;<br>    <span class="hljs-keyword">var</span> wrappedValue: <span class="hljs-type">A</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">wrappedValue</span>: <span class="hljs-type">A</span>) &#123;<br>        <span class="hljs-keyword">self</span>.wrappedValue <span class="hljs-operator">=</span> wrappedValue<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>在SwiftUI中，@State中的管理的值实际是被SwiftUI管理，@Binding的值实际是对应的@State中的值，@Binding并不关心值在哪，值关心setter和ggeter</li><li>投影值，即projectedValue，通过对属性包装调用$而创建</li><li>本质上，@Binding实际也是一个结构体，只不过这个结构体中存储的不是实际的值，而是setter和getter，那么这个setter和getter就是@State的projectValue在创建@Binding时赋值的</li><li>@State&#x2F;@Observedbject -&gt; 投影值 -&gt; @Binding，对@Binding的存取即通过setter&#x2F;getter间接的称为对@State&#x2F;@ObservedObject中属性的存取，就是这么简单~~<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">// 投影值本身，其特殊支出在于存储的东西不是实例而是函数</span><br><span class="hljs-keyword">@propertyWrapper</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Reference</span>&lt;<span class="hljs-title class_">A</span>&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _get: () -&gt; <span class="hljs-type">A</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _set: (<span class="hljs-type">A</span>) -&gt; ()<br>    <br>    <span class="hljs-keyword">var</span> wrappedValue: <span class="hljs-type">A</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            _get()<br>        &#125;<br>        <span class="hljs-keyword">set</span> &#123;<br>            _set(newValue)<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">get</span>: <span class="hljs-keyword">@escaping</span> () -&gt; <span class="hljs-type">A</span>, <span class="hljs-params">set</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">A</span>) -&gt; ()) &#123;<br>        _get <span class="hljs-operator">=</span> <span class="hljs-keyword">get</span><br>        _set <span class="hljs-operator">=</span> <span class="hljs-keyword">set</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义属性包装的投影值</span><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Box</span> &#123;<br>    <span class="hljs-keyword">var</span> projectedValue: <span class="hljs-type">Reference</span>&lt;<span class="hljs-type">A</span>&gt; &#123;<br>        <span class="hljs-type">Reference</span>&lt;<span class="hljs-type">A</span>&gt; &#123; () -&gt; <span class="hljs-type">A</span> <span class="hljs-keyword">in</span><br>            <span class="hljs-keyword">self</span>.wrappedValue<br>        &#125; <span class="hljs-keyword">set</span>: &#123; (i) <span class="hljs-keyword">in</span><br>            <span class="hljs-keyword">self</span>.wrappedValue <span class="hljs-operator">=</span> i<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>有时，我们并不希望将整个wrapperedValu而通过投影值传递，而是希望让传递wrappedValue中的某个属性，那我们不能写成$A.xxx，因为$Type已经是投影类型了，它没有xxx这个属性。方法自然是有的，我们需要为投影类型实现动态成员查找：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">@propertyWrapper</span><br><span class="hljs-keyword">@dynamicMemberLookup</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Reference</span>&lt;<span class="hljs-title class_">A</span>&gt; &#123;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">subscript</span>&lt;<span class="hljs-type">B</span>&gt;(<span class="hljs-params">dynamicMember</span> <span class="hljs-params">keyPath</span>: <span class="hljs-type">WritableKeyPath</span>&lt;<span class="hljs-type">A</span>, <span class="hljs-type">B</span>&gt;)<br>-&gt; <span class="hljs-type">Reference</span>&lt;<span class="hljs-type">B</span>&gt; &#123;<br>    <span class="hljs-type">Reference</span>&lt;<span class="hljs-type">B</span>&gt;(get: &#123;<br>        <span class="hljs-keyword">self</span>.wrappedValue[keyPath: keyPath]<br>    &#125;) &#123;<br>        <span class="hljs-keyword">self</span>.wrappedValue[keyPath: keyPath] <span class="hljs-operator">=</span> <span class="hljs-variable">$0</span><br>    &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>这样，当我们使用$A.xxxx时，就会转换为对Refrerence&lt;A&gt;[dynmiacMembers:\.xxxx]的调用，从而能够获取到对原始实例的存取</li><li>有时，属性只在能够获取到其宿主时才会发挥作用，比如Combine框架中的@Published，它实际上必须要调用宿主的（ObservableObject类型）的objectWillChanged才work，要想实现这种效果，需要通过实现一个特定的subscript方法，这里暂时不详细探究了</li><li>SwiftUI中的@State实际就是必须获取到宿主View的层级才work的</li><li>由于属性包装编译器必须生成存储属性，而enum在case之外是不能放存储属性的，因而enum中不能使用属性包装</li><li>可以在函数中使用属性包装，并且从Swift 5.5开始，也可以将属性包装作为函数参数传递</li></ul><h2 id="键路径"><a href="#键路径" class="headerlink" title="键路径"></a>键路径</h2><ul><li>也就是KeyPath，表示对一个属性为调用的引用，如\Type.xxx，因为Type可能本身有个static的xxx属性，为了区分开，需要加个\。如果可以类型推断，可省略Type，即\.xxx</li><li>KeyPath可以由任意存储属性和计算属性组合，包括可选类型，编译器会自动为为每个类型生成[keyPath:]下标方法</li><li>WriteableKeyPath：可以通过该KeyPath对属性修改，要求原值是可变的</li><li>ReferenceWritableKeyPath：同上，但是针对于引用语义的值</li><li>KeyPath：不可通过该KeyPath对属性修改</li><li>KeyPath还可以用于描述下标操作，如\.[1].name</li><li>KeyPath某种程度上和函数类似，都是给定参数获取值，或者传入参数设置值，但是KeyPath本身可以比较判等，并且无状态，这和函数不同</li><li>编译器可以自动将KeyPath转换为函数，如xx.map(\.name)等价于xx.map{$0.name}，注意这个仅对直接写的时候有效，如果将KeyPath放到变量中是无效的</li><li>KeyPath还可以组合，需要注意类型必须要匹配<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs julia">// KeyPath&lt;Person, <span class="hljs-built_in">String</span>&gt; + KeyPath&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Int</span>&gt; = KeyPath&lt;Person, <span class="hljs-built_in">Int</span>&gt;<br><span class="hljs-keyword">let</span> nameCountKeyPath = nameKeyPath.appending(path: \.count)<br>// Swift.KeyPath&lt;Person, Swift.<span class="hljs-built_in">Int</span>&gt;<br></code></pre></td></tr></table></figure></li><li>可写的KeyPath在SwiftUI中很常见，比如通过其修改环境值，在之前也看到过结合投影类型的动态成员查找，方便实现任意属性的投影</li><li>总结下5种类型的KeyPath，其中WritableKeyPath和ReferenceWritableKeyPath进行区分是必要的，前一个类型的setter要求它的参数是inout的<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-type">AnyKeyPath</span> like (<span class="hljs-keyword">Any</span>) -&gt; <span class="hljs-keyword">Any</span><span class="hljs-operator">?</span><br><span class="hljs-type">PartialKeyPath</span>&lt;<span class="hljs-type">Source</span>&gt; like (<span class="hljs-type">Source</span>) -&gt; <span class="hljs-keyword">Any</span><span class="hljs-operator">?</span><br><span class="hljs-type">KeyPath</span>&lt;<span class="hljs-type">Source</span>, <span class="hljs-type">Target</span>&gt; like (<span class="hljs-type">Source</span>) -&gt; <span class="hljs-type">Target</span><br><span class="hljs-type">WritableKeyPath</span>&lt;<span class="hljs-type">Source</span>, <span class="hljs-type">Target</span>&gt; like (<span class="hljs-type">Source</span>) -&gt; <span class="hljs-type">Target</span> and (<span class="hljs-keyword">inout</span> <span class="hljs-type">Source</span>,     <span class="hljs-type">Target</span>) -&gt; ()<br><span class="hljs-comment">// 这一对函数相似。第二个函数可以用Target来更新Source值且要求 Source 是一个引用类型 </span><br><span class="hljs-type">ReferenceWritableKeyPath</span>&lt;<span class="hljs-type">Source</span>, <span class="hljs-type">Target</span>&gt; like (<span class="hljs-type">Source</span>) -&gt; <span class="hljs-type">Target</span> and (<span class="hljs-type">Source</span>, <span class="hljs-type">Target</span>) -&gt; ()<br></code></pre></td></tr></table></figure></li><li>相比于OC，OC的键路径是通过字符串实现的，并且没有类型约束，魔种程度上类似于AnyKeyPath，但是不安全</li><li>KeyPath目前还存在性能问题，比直接访问要慢（因为毕竟是动态嘛…</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-函数</title>
    <link href="/2023/12/21/swift-advance-function/"/>
    <url>/2023/12/21/swift-advance-function/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>函数在Swift中和类一样，都是头等公民，可以被赋值给变量，可以被传递，可以捕获外部变量。当函数捕获变量时，可以视作函数和被捕获的变量构成了一个类对象（但是函数不可比较）。<br>函数既可以使用func关键字声明，也可以用闭包表达式来声明，eg.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">let</span> f <span class="hljs-operator">=</span> &#123;(i: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">return</span> i <span class="hljs-operator">*</span> <span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><p>闭包表达式与func的主要区别在于闭包是匿名的，只能被赋值给变量或者作为参数传递。<br>在Swift中，函数&#x3D;&#x3D;闭包，没什么不同，只是写的形式可能有区别。</p><h2 id="函数的灵活性"><a href="#函数的灵活性" class="headerlink" title="函数的灵活性"></a>函数的灵活性</h2><ul><li>如何实现复杂的排序规则，在OC中，可以通过NSSortDescriptor，但仅限于NSObject类，在Swift中使用高阶函数可以完成</li><li>(Value) -&gt; (Value) -&gt; ComparisonResult的含义实际上就是(Value) -&gt; ((Value) -&gt; ComparisonResult)，即给定一个值，返回一个闭包<br>看一个例子：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SortDescriptor</span>&lt;<span class="hljs-title class_">Root</span>&gt; &#123;<br>    <span class="hljs-keyword">var</span> areInIncreasingOrder: (<span class="hljs-type">Root</span>, <span class="hljs-type">Root</span>) -&gt; <span class="hljs-type">Bool</span><br>&#125;<br><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">SortDescriptor</span> &#123;<br>    <span class="hljs-keyword">init</span>&lt;<span class="hljs-type">Value</span>&gt;(<span class="hljs-params">key</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Root</span>) -&gt; <span class="hljs-type">Value</span>,<br>                <span class="hljs-params">compare</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Value</span>) -&gt; ((<span class="hljs-type">Value</span>) -&gt; <span class="hljs-type">ComparisonResult</span>)) &#123;<br>        <span class="hljs-comment">// 注意这里$0和$1表示的是areInIncreasingOrder的两个参数</span><br>        <span class="hljs-keyword">self</span>.areInIncreasingOrder <span class="hljs-operator">=</span> &#123;<br>            compare(key(<span class="hljs-variable">$0</span>))(key(<span class="hljs-variable">$1</span>)) <span class="hljs-operator">==</span> .orderedAscending<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> sortByFirstName: <span class="hljs-type">SortDescriptor</span>&lt;<span class="hljs-type">Person</span>&gt; <span class="hljs-operator">=</span> .<span class="hljs-keyword">init</span>(key: &#123;<span class="hljs-variable">$0</span>.first&#125;, compare: <span class="hljs-type">String</span>.localizedStandardCompare)<br></code></pre></td></tr></table></figure>这里String.localizedStandardCompare的类型就是(String) -&gt; (String) -&gt; ComparisonResult，它等价于string1.localizedStandardCompare(string2)<br>通过高阶函数+泛型，我们可以方便的生成普适性的函数&#x2F;闭包，从而达到简洁的效果。（但是有时也会加大理解负担）</li><li>还可以通过将SortDescriptor进行封装组合，形成更加强大复杂的排序方式，比如<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">SortDescriptor</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">then</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">other</span>: <span class="hljs-type">SortDescriptor</span>&lt;<span class="hljs-type">Root</span>&gt;) -&gt; <span class="hljs-type">SortDescriptor</span>&lt;<span class="hljs-type">Root</span>&gt; &#123;<br>        <span class="hljs-type">SortDescriptor</span> &#123; x, y <span class="hljs-keyword">in</span><br>        <span class="hljs-keyword">if</span> areInIncreasingOrder(x,y) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br>        <span class="hljs-keyword">if</span> areInIncreasingOrder(y,x) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>        <span class="hljs-keyword">return</span> other.areInIncreasingOrder(x,y)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>这里使用then将descriptor进行组合，实际类似于java中的builder模式，在最后调用的时候，按照从里到外的顺序调用每个desriptor的areInIncreasingOrder方法</li></ul><h2 id="函数作为代理"><a href="#函数作为代理" class="headerlink" title="函数作为代理"></a>函数作为代理</h2><ul><li>如果只需要一个函数作为回调，那么使用函数而不需要使用代理</li><li><strong>Swift中的闭包捕获的变量类比于OC来说默认是__block的</strong>，既可以影响外部被捕获的值，而不是copy</li></ul><h2 id="inout参数和可变方法"><a href="#inout参数和可变方法" class="headerlink" title="inout参数和可变方法"></a>inout参数和可变方法</h2><ul><li>inout参数实际上并不是直接修改原来的参数，而是先copy，然后修改，再将修改完之后的值copy回去（但是编译器可能优化为传地址，但是不应依赖该行为）</li><li>只能使用var作为inout参数：肯定啊，不然咋修改</li><li>数组下标也可以作为inout参数，实际上，支持set&#x2F;get的所有下标操作都能被作为inout参数</li><li>在嵌套函数中也可以使用inout，但是嵌套函数不能逃逸</li><li>如果参数声明为UnsafeXXXPointer，则&amp;表示取指针而不是inout参数</li></ul><h2 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h2><ul><li>subscript函数</li><li>参数后…表示可变长度参数，可作为数组使用</li></ul><h2 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h2><ul><li>@autoclosure告知编译器，应当将传入的表达式转换为闭包，eg.<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">and</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">l</span>: <span class="hljs-type">Bool</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">r</span>: <span class="hljs-keyword">@autoclosure</span> () -&gt; <span class="hljs-type">Bool</span>) -&gt; <span class="hljs-type">Bool</span> &#123;<br>    <span class="hljs-keyword">guard</span> l <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br>    <span class="hljs-keyword">return</span> r()<br>&#125;<br><br><span class="hljs-keyword">if</span> and(<span class="hljs-operator">!</span>evens.isEmpty, evens[<span class="hljs-number">0</span>] <span class="hljs-operator">&gt;</span> <span class="hljs-number">10</span>) &#123;<br>    <span class="hljs-comment">// 执行操作</span><br>&#125; <br></code></pre></td></tr></table></figure></li><li>#fileId, #function, #line在编译器中表示<strong>调用者</strong>的文件名、函数名和行号</li></ul><h2 id="escaping"><a href="#escaping" class="headerlink" title="@escaping"></a>@escaping</h2><ul><li>表示作为参数传递的闭包可以被保存并在稍后使用</li><li>闭包参数如果是直接参数，默认是非escaping的，但可选值类型、存储属性、封装在元组中的闭包是escaping的</li><li>有时我们确实知道闭包时不会逃逸的，但又不想传递可选值，那么可以使用withoutActuallyEscaping来告知编译器,但是安全性需要自己保证：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Array</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">allSatisfy2</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">predicate</span>: (<span class="hljs-type">Element</span>) -&gt; <span class="hljs-type">Bool</span>) -&gt; <span class="hljs-type">Bool</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">withoutActuallyEscaping</span>(predicate) &#123; escapablePredicate <span class="hljs-keyword">in</span><br>        <span class="hljs-keyword">self</span>.lazy.filter &#123; <span class="hljs-operator">!</span>escapablePredicate(<span class="hljs-variable">$0</span>) &#125;.isEmpty<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="ResultBuilder"><a href="#ResultBuilder" class="headerlink" title="ResultBuilder"></a>ResultBuilder</h2><ul><li>当编译器遇到ResultBuilder注解时，会将被注解函数表达式转换对特定结构体中函数的调用，从而得到最终结果，最典型的例子就是SwiftUI中的ViewBuilder，这可能也是ResultBuilder被引入的动机之一<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">@inlinable</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">alignment</span>: <span class="hljs-type">VerticalAlignment</span> <span class="hljs-operator">=</span> .center, <span class="hljs-params">spacing</span>: <span class="hljs-type">CGFloat</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>, <span class="hljs-meta">@ViewBuilder</span> <span class="hljs-params">content</span>: () -&gt; <span class="hljs-type">Content</span>)<br></code></pre></td></tr></table></figure></li><li>实际上，Swift会将@ViewBuilder注解函数中的表达式转换为调用ViewBuilder结构体中的buildBlock的函数调用，等价于<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">@resultBuilder</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ViewBuilder</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">buildBlock</span>&lt;<span class="hljs-type">C0</span>, <span class="hljs-type">C1</span>, <span class="hljs-type">C2</span>&gt;(<span class="hljs-keyword">_</span> <span class="hljs-params">c0</span>: <span class="hljs-type">C0</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">c1</span>: <span class="hljs-type">C1</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">c2</span>: <span class="hljs-type">C2</span>)<br>    -&gt; <span class="hljs-type">TupleView</span>&lt;(<span class="hljs-type">C0</span>, <span class="hljs-type">C1</span>, <span class="hljs-type">C2</span>)&gt;<br>    <span class="hljs-keyword">where</span> <span class="hljs-type">C0</span>: <span class="hljs-type">View</span>, <span class="hljs-type">C1</span>: <span class="hljs-type">View</span>, <span class="hljs-type">C2</span>: <span class="hljs-type">View</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>注意ViewBuilder前面的注解@resultBuilder，其可以实现一系列不同的buildXXX方法</li><li>注意@resultBuilder注解时Swift 5.4引入的</li><li>最基本的方法是buildBlock和buildExperssion，@resultBuilder要求至少实现一个buildBlock方法</li><li>buildBlock中的参数和类型并不要求一致，但是如果想要函数支持多种类型，使用buildExpression时更加优雅的方式，其作用是在将参数传递给buildXXX之前先应用该函数进行转换</li><li>通过重载buildExpression方法，我们可以实现一些特殊逻辑，比如一般builder函数（即被标记为@XXXBuilder的函数）中是不能调用print方法的，因为print方法返回的是Void。我们可以添加一个将Void转换为需要参数类型的buildExpression来绕过</li><li>@available注解格式<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">@available</span>(版本范围, 可用性, message: 错误消息)<br></code></pre></td></tr></table></figure></li><li>builder还可以通过实现buildIf和buildEither来支持if，if else和switch语句<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-comment">// 支持单个if，因为if语句要么有值，要么值为nil，所以参数是可选值类型</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">buildIf</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">s</span>: <span class="hljs-type">String</span>?) -&gt; <span class="hljs-type">String</span> &#123;<br>    s <span class="hljs-operator">??</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 支持if else的if分支，要求if分支必须返回是String</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">buildEither</span>(<span class="hljs-params">first</span> <span class="hljs-params">component</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> &#123;<br>    component<br>&#125;<br><br><span class="hljs-comment">// 支持if else的else分支，要求else分支必须返回是String</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">buildEither</span>(<span class="hljs-params">second</span> <span class="hljs-params">component</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> &#123;<br>    component<br>&#125;<br><br><span class="hljs-comment">// 实现了if else，switch是实现了，switch也可以看做是if else的嵌套调用，但是实际上switch除了第一个case是buildEither(first:)，其余分支都是buildEdither(second:)</span><br></code></pre></td></tr></table></figure></li><li>builder还可以支持循环<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">buildArray</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">components</span>: [<span class="hljs-type">String</span>]) -&gt; <span class="hljs-type">String</span> &#123;<br>    components.joined(separator: <span class="hljs-string">&quot;&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>buildFindalResult:将会在builder函数的最后的结果被应用</li><li>resultBuilder不支持guard、defer、do…catch等，因为这些语句无法被求值</li><li>总结：通过实现一系列build方法，创建一个XXXBuilder，通过@XXXBuilder将函数&#x2F;闭包转换为对build方法的调用，从而实现自定义DSL的效果</li><li>所以为啥View中的body能返回不同类型的View呢，<strong>实际上View的body就是@ViewBuilder</strong>，但是并不是任何属性都具有该特特性，正常情况下，<strong>某个标记为some View的属性需要返回相同类型的View</strong>，我们可以加上@ViewBuilder注解（因为some View就是某种特定具体类型的View，所以如果返回的类型不同，自然无法编译通过，<strong>通过加上ViewBuilder注解让编译器帮我们将表达式转换为统一的封装类型</strong>就OK了~~）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-可选值</title>
    <link href="/2023/12/20/swift-advance-optional-value/"/>
    <url>/2023/12/20/swift-advance-optional-value/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分主要介绍Swift中可选值的底层原理</p><h2 id="哨岗值"><a href="#哨岗值" class="headerlink" title="哨岗值"></a>哨岗值</h2><ul><li>在许多时候，函数在没有读取到有效值后需要返回给我们一个特定的值，称为哨岗值，比如EOF、-1、null等等</li><li>哨岗值有时是有效的值，比如-1，但有时候这种情况会导致错误的结果，比如OC对nil发消息，如果方法返回的是结构体，则会是一个值全部为0的结构体，这时有可能导致逻辑错误,eg<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ObjectiveC"><span class="hljs-built_in">NSString</span> *someString = ...;<br><span class="hljs-keyword">if</span> ([someString rangeOfString:<span class="hljs-string">@&quot;Swift&quot;</span>].location != <span class="hljs-built_in">NSNotFound</span>) &#123;<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Someone mentioned Swift!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>如果someString是nil，location就会是0而不是NSNotFound（是NSIntegerMax），显然是错误的。</li><li>哨岗值还依赖约定，如果不知道约定，则无法使用。</li><li>Swift通过枚举实现Optional来解决哨岗值的问题,没错，可选值的本质实际就是带有关联值的Swift枚举<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Optional</span>&lt;<span class="hljs-title class_">Wrapped</span>&gt; &#123;<br><span class="hljs-keyword">case</span> none<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">some</span>(<span class="hljs-type">Wrapped</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>Swift中对于可能是哨岗值的返回的都是可选值，从而避免了必须了解哨岗值约定的问题</li><li>语法糖使得使用可选值更加方便：<ul><li>Type? &#x3D; Optional<Type></li><li>nil &#x3D; .none(因为可选值遵守ExpressibleByNilLiteral协议，即可用nil表示)</li><li>在必要时，非可选值会自动封装为可选值，不需要手动调用.some(Type)，比如函数的返回类型标记为可选值类型</li></ul></li><li>可选值匹配：<ul><li>匹配值：switch .some(let v)或者swifth let v?</li><li>匹配nil：switch .none或者switch nil</li></ul></li></ul><h2 id="可选值概览"><a href="#可选值概览" class="headerlink" title="可选值概览"></a>可选值概览</h2><ul><li>if let:可选值绑定,略</li><li>while let:当遇到nil时终止</li><li>双重可选值：即Type??，实际就是Optional(Optional(value))<ul><li>case let v? &#x3D; case let .some(v)，仅匹配值</li></ul></li><li>case实际上的匹配功能很强大，比如 case 0..&lt;10 &#x3D; j可以检查j是否在范围内</li><li>if var&#x2F;while var:可变版本，使得我们在if语句中可以修改变量</li><li>在作用域之外使用解包后的值：使用guard let语句，其else路径必须是要求离开当前作用域，如return或者调用一个Never函数</li><li>返回Never（又称为无人类型）的函数向编译器表明自己绝对不会返回，如fatalError或者dispatchMain;又或者对应的值绝对不会出现，比如将泛型指定为Never</li><li>Never实际在Swift中就是个enum<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Never</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li>Never和Void是不同的，Void实际是空元祖()</li><li>总结，不存在是nil，存在且为空Void，绝对不会发生Never</li><li>在OC中，对nil发消息不会发生，在Swift中，使用可选链实现，如v?.callback(),<strong>可选链的调用结果一定是可选值</strong></li><li>对于可选值成员，默认值是nil，这是Swift中对于成员成员初始化的<strong>唯一例外</strong>。注意这个默认行为支队x?的形式有效，如果写成了Optional<T>就无效了，还是必须初始化</li><li>可选链和赋值：可以使用可选链来对可选值进行赋值，如<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> a: <span class="hljs-type">Int</span>?<br>a<span class="hljs-operator">?+=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>注意不能写成，因为可选值绑定对值类型来说是复制<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> a: <span class="hljs-type">Int</span>? <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">var</span> a <span class="hljs-operator">=</span> a &#123;<br>    <span class="hljs-comment">// 无法改变外层的a</span><br>    a<span class="hljs-operator">+=</span><span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>nil合并操作符：??,略，注意??也是短路操作符</li><li>可选值提供了一个map方法，方便我们在不为nil的请款修改进行转换，注意因为是Optional本身提供的方法，所以调用的时候不能加?,eg.arr.first.map{…}（注意，只要是可选值，就可以调用该map方法，不要求可选值是集合类型！！），但是注意，即使如此，<strong>返回的仍然是可选值类型</strong></li><li>flatMap：如果变换本身返回了可选值类型，那么map得到的结果则是双重可选值，为了去掉一层，可以使用flatMap，注意可选值的类型上也是直接定义了flatMap</li><li>compactMap：可以将变换后为nil的可选值给筛掉</li><li>可选值判等：如果可选值封装的类型符合Equatable，则对应的可选值类型也是Equatable的，所以我们可以方便的判等：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> a: <span class="hljs-type">Int</span>? <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>a <span class="hljs-operator">==</span> <span class="hljs-number">0</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>这里work的原因是swift会在必要时将0升级为可选值</li><li>字典中如果直接设置key的value为nil会移除掉key和value，若要插入值nil，可以使用Optional(nil)</li><li>强制解包的使用：一般不要使用，除非预期是在遇到nil时直接crash</li><li>挂起操作的方式：fatalError直接crash、assert在测试版本不符合条件执行并且crash、precondtion和assert一样只不过在正式版也存在</li><li>隐式解包：标记为Type!的类型<ul><li>情景1：oc返回的类型，并且没有标记nullable和nonnull</li><li>情景2：暂时的为空，不如初始化的过程中</li><li>隐式可选值在使用上既可以假定为非可选值不加？，也可以当做可选值加？</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift进阶-内建集合类型</title>
    <link href="/2023/12/19/swift-advance-built-in-collection/"/>
    <url>/2023/12/19/swift-advance-built-in-collection/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>虽然在工作中已经大量使用了Swift了，但总感觉自己停留在使用的层面。从今天开始，开始复习Swift Adavance，回忆、理解、总结。</p><p>本章重点介绍了Swift内建的几种集合类型，并讨论如何高效使用。</p><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><ul><li>值语义： Swift中所有的内建集合类型都具有值语义，数组当然也不例外。值语义的典型表现是当其被赋值给一个变量时，将发生复制。</li><li>使用let和var来表示数组是不可变数组or可变数组。注意，即使是可变数组，仍然是值类型。这和NSMutableArray完全不同。</li><li>Swift编译器会对值语义集合进行优化，如果被赋值给对个变量，只有通过变量修改值时才会发生实际的copy，但我们不应依赖该行为。</li><li>数组越界会直接崩溃。</li><li>数组为空时，调用removeLast会崩溃，但popLast则不会崩溃，而是返回nil。</li><li>支持map、flatMap、filter等函数式编程。</li><li>使用.lazy将变形延迟发生到最终需要结果的时候，比如需要将结果转换为数组输出。</li><li>map：遍历元素，对每个元素应用func得到新集合。</li><li>filter: 遍历元素，删除掉符合func的元素得到新集合。</li><li>reduce: 遍历元素，对每个元素应用和之前的结果应用func得到结果值。</li><li>flatMap: 如果得到的结果外层是数组，则去掉结果外层数组。</li><li>forEach: 遍历元素，应用func但不返回结果。注意func中写return并不会使得遍历停止。</li><li>数组可以切片，类似于python，结果是ArraySlice。但是，<strong>切片完之后的索引和原始数组共享索引和内存</strong>！</li></ul><h2 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h2><ul><li>字典查找总是返回可选值，这和Array不同。</li><li>思想：Array中的索引一般总是通过某种方式计算得到的，一般都是有效的，无效的索引一般意味着开发者的计算失误。所以崩溃就好。但是Dict的key一般是其他取到得来的，比如server下发，所以返回可选值比较好。</li><li>删除值：将对应key的value设置为nil或者removeValue(forKey:),该方法返回删除的value,注意，这同时会将key也给删掉。</li><li>更新值：简单，设置即可，或者使用updateValue(_:forKey:),该方法会返回old value。</li><li>合并dict：merge(_:uniquingKeysWith:),第二个参数是决定决策对于相同的key使用如何获取value的函数，注意<strong>是获取value，而不是选择value</strong>，因为不仅可以选择某一个value，也可以对这两个value进行操作得到新的value。</li><li>mapValues: 对dict的values作map</li><li>Dict的key必须符合Hashable协议。<ul><li>标准库中所有基本数据类型都是Hashable的，如Int、String</li><li>数组、集合或可选值，如果其元素时Hashable，则他们也是Hashable</li><li>结构体和enum，如果是由Hashable的类型组成（对结构体来说，要求存储属性，对enum来说，要求关联值，若无关联值，则默认是Hashable的，不需要声明），只要我们声明他们是Hashable，则Swift会帮我们合成Hashable的实现</li><li>对于通过&#x3D;&#x3D;比较相等的两个对象，hash值必须相同，反之，hash值相同，不一定是相同的对象，因为hash值有限，但对象数量无限，可能存在hash冲突的可能。</li><li>所以一般不要使用可变对象作为key，否则如果对象改变造成hash改变，则会造成dict存储找不到或存储错误。</li></ul></li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul><li>嘛，就是集合</li><li>可以使用数组字面量初始化Set，因为Set遵守ExpressibleByArrayLiteral。</li><li>补集：substring</li><li>交集：intersection</li><li>并集：formUnion，这是union的可变版本，即改变原集合，所有以form开头的版本都是可变版本。</li></ul><h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><ul><li>就是区间</li><li>x..&lt;y左闭右开: Range，只有此类型可以表示空集，如5..&lt;5</li><li>x…y闭区间: ClosedRange,只有此类型可以表示最大值，如0…Int.max，因为Range需要上界是比自身包含的范围还得+1</li><li>Range和ClosedRange都有Bound泛型，Bound需要符合Comparable</li><li>x…，左闭右无界: PratialRangeFrom，可遍历，需自己break<ul><li>对于PartialRangeFrom遍历时，会从下界开始，调用adavanced(by:1)</li></ul></li><li>…y，左无界右闭：PartialRangeThrough，不可遍历</li><li>..&lt;y，左无界右开: PartialRangeUpTo，不可遍历</li><li>检测包含：contains、overlaps</li><li>Range可以遍历，但不能完全遍历emm…，支持遍历的<strong>Range的Bound</strong>需要实现Strideable协议。</li><li>Range必须是可数的才能遍历</li><li>Swift之前为了区分可数还是不可数，引入两个类型，即CountableRange和CountableClosedRange</li><li>所有的Range都满足RangeExpression协议<ul><li>contains：判断元素是否包含在范围中</li><li>relative：对给定集合，能够计算出该集合的Range。<strong>若该RangeExpression缺少上界或者下界，则返回的结果中使用给定集合的startIndex或endIndex作为上界或者下界</strong>。</li><li>所以数组可以使用Range进行切片，原理就是数组的subscript实现了接受RangeExpression作为参数，从而结合自身的startIndex和endIndex得到一个Range，从而执行切片</li></ul></li><li>RangeSet: 即Range的集合，在表示多个区间时更加高效</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo添加Live2D看板娘</title>
    <link href="/2023/12/03/hexo-add-live2d/"/>
    <url>/2023/12/03/hexo-add-live2d/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在浏览别人的blog时，有时可以看到一个类似于下面这个萌萌哒的玩意，这其实是通过Live2D Widget插件实现的。方法也很简单，follow me~<br><img src="/../images/image-19.png" alt="Alt text"></p><h2 id="Step1-安装live-2d插件"><a href="#Step1-安装live-2d插件" class="headerlink" title="Step1 安装live 2d插件"></a>Step1 安装live 2d插件</h2><p>注意，下面的指令都是在Hexo项目目录中使用的</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-helper-live2d</span><br></code></pre></td></tr></table></figure><h2 id="Step2-下载live-2d模型"><a href="#Step2-下载live-2d模型" class="headerlink" title="Step2 下载live 2d模型"></a>Step2 下载live 2d模型</h2><p>通过下载不同的live 2d模型，就可以获得不同的看板娘啦，直接npm下载，贼方便</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">// 下载的model会存放在node_modules中</span><br>npm install live2d-widget-<span class="hljs-keyword">model</span>-tororo<br></code></pre></td></tr></table></figure><h2 id="Step3-配置-config-yml"><a href="#Step3-配置-config-yml" class="headerlink" title="Step3 配置_config.yml"></a>Step3 配置_config.yml</h2><p>添加如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Live2D看板娘</span><br><span class="hljs-attr">live2d:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">pluginModelPath:</span> <span class="hljs-string">assets/</span><br>  <span class="hljs-attr">model:</span><br>    <span class="hljs-comment">#模板目录，在node_modules里</span><br>    <span class="hljs-attr">use:</span> <span class="hljs-string">live2d-widget-model-tororo</span><br>  <span class="hljs-attr">display:</span><br>    <span class="hljs-attr">position:</span> <span class="hljs-string">right</span><br>    <span class="hljs-attr">width:</span> <span class="hljs-number">300</span> <br>    <span class="hljs-attr">height:</span> <span class="hljs-number">600</span><br>  <span class="hljs-attr">mobile:</span><br>    <span class="hljs-comment"># 在手机端显示</span><br>    <span class="hljs-attr">show:</span> <span class="hljs-literal">false</span>   <br>  <span class="hljs-attr">rect:</span><br>    <span class="hljs-string">opacity:0.7</span><br></code></pre></td></tr></table></figure><h2 id="Step4-查看效果"><a href="#Step4-查看效果" class="headerlink" title="Step4 查看效果"></a>Step4 查看效果</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">hexo g <span class="hljs-meta">&amp;&amp; hexo s</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Live2D</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何让Hexo被Google索引到</title>
    <link href="/2023/12/03/about-hexo-google-index/"/>
    <url>/2023/12/03/about-hexo-google-index/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们写blog的目的是让自己的分享被别人看到，如果Google没有收录自己的网址，那么就没有意义了。 本篇文章主要介绍如何让咱们的blog被Google收录。</p><h2 id="Step1-检查收录"><a href="#Step1-检查收录" class="headerlink" title="Step1 检查收录"></a>Step1 检查收录</h2><p>首先检查咱们的blog有没有被Google索引，在搜索框输入site:xxx.github.io，不出意外的话，Google没有收录：<br><img src="/../images/image-13.png" alt="Alt text"></p><h2 id="Step2-验证网址所有权"><a href="#Step2-验证网址所有权" class="headerlink" title="Step2 验证网址所有权"></a>Step2 验证网址所有权</h2><p>按照提示，点击进入Google Search Console，Google会要求验证这个网址的归属权，这里由于采用的GitHub Page，所以按照第二种网址前缀的方式进行验证：<br><img src="/../images/image-14.png" alt="Alt text"><br>接下来，会看到有几种验证的方式，因为不想添加一个乱七八糟的html到网站目录中（强迫症犯了QAQ），所以我选择HTML标记的方式。这种方式会要求我们在index.html的head标签中添加一个meta标签，按照提示复制该标签。<br><img src="/../images/image-15.png" alt="Alt text"><br>接下来，找到Hexo项目的public文件夹下的index.html，将这个标签复制到head标签的末尾。<br><img src="/../images/image-16.png" alt="Alt text"><br>顺便说下，Hexo在部署的就是public文件夹下的内容。<br>我们直接发布，<strong>注意不要generate</strong>，因为generate会重新生成index.html，会将咱们之前的修改给覆盖掉。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">// 直接发布即可</span><br>hexo d<br></code></pre></td></tr></table></figure><p>发布完成之后，稍等1min左右，等待GitHub Page部署完成，点击验证按钮。Congratulations，验证完成~~~<br><img src="/../images/image-17.png" alt="Alt text"></p><h2 id="Step3-添加sitemap-xml"><a href="#Step3-添加sitemap-xml" class="headerlink" title="Step3 添加sitemap.xml"></a>Step3 添加sitemap.xml</h2><p>到上面其实Google已经允许收录咱们的blog了，但是为了Google的蜘蛛机器人更好的爬取到网站的内容，我们可以在网站根目录下放一个sitemap.xml。<br>进入到Hexo项目目录中，安装插件：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-generator-sitemap <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>安装完毕之后，打开_config.yml，添加如下内容</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"># automatically <span class="hljs-keyword">generate</span> sitemap<br>sitemap:<br>  path: sitemap<span class="hljs-variable">.xml</span><br></code></pre></td></tr></table></figure><p>重新生成部署，不再啰嗦啦，hexo g -d一把梭。<br>等待1min。进入到Google Search Console，提交我们的sitemap.xml，如下图，OK收工。<br>但我们这个时候再搜索还是搜不到的，需要等个几天，到时候再来更新~<br><img src="/../images/image-18.png" alt="Alt text"></p><hr><p>12月9日更新，已经可以被索引到了~<br><img src="/../images/image-20.png" alt="Alt text"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Hexo中图片路径问题</title>
    <link href="/2023/12/03/about-hexo-picture-path/"/>
    <url>/2023/12/03/about-hexo-picture-path/</url>
    
    <content type="html"><![CDATA[<p>在编写Hexo时，通常需要粘贴图片到markdown中。默认粘贴的path和咱们的md文件同级别，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![Alt text](image-9.png)</span><br></pre></td></tr></table></figure><p>虽然本地预览没有问题，但是在generate的时候，存在两个问题：<br>1.Hexo会忽略_post下的图片资源<br>2.Hexo会将md文件中的path转换为域名&#x2F;path，例如<a href="http://xxx.github.io/xxx.png">http://xxx.github.io/xxx.png</a><br>这两个问题都会导致无法正常看到我们blog中的图片。  </p><p>问题解决：<br>1.在source下新建images文件夹，专门用来存放图片<br>2.Hexo中使用images&#x2F;xxx.png来引用该图片</p><p>那么还是有问题，在使用VS Code粘贴图片时，还是默认粘贴到_posts下面，这样每次都要移动图片和修改路径，很麻烦。没错，贴心的VS Code可以自定义粘贴的路径，使用cmd+,打开设置，找到如下界面设置默认的粘贴路径：<br><img src="/../images/image-10.png" alt="Alt text"><br>完成！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo的安装与部署</title>
    <link href="/2023/12/03/hexo-install-and-deploy/"/>
    <url>/2023/12/03/hexo-install-and-deploy/</url>
    
    <content type="html"><![CDATA[<p>一时间还没想好要写哪些东西，万事开头难嘛，既然这样，咱就先记录下烂大街的Hexo安装与部署吧。</p><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>我们可以将我们的blog理解成一个app，Hexo项目就是这个app的框架工程源码，通过Node.js进行编译打包，最终生成产品发布到GitHub上被人查看使用。</p><h1 id="安装Git-注册GitHub账号"><a href="#安装Git-注册GitHub账号" class="headerlink" title="安装Git&amp;注册GitHub账号"></a>安装Git&amp;注册GitHub账号</h1><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>传送门：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a><br>作用：用于管理Hexo生成的文件，对接GitHub</p><h2 id="注册GitHub账号"><a href="#注册GitHub账号" class="headerlink" title="注册GitHub账号"></a>注册GitHub账号</h2><p>传送门：<a href="https://github.com/">https://github.com/</a><br>作用：托管Hexo生成的文件，并提供GitHub Page服务，让blog可以被别人浏览  </p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// 校验安装</span><br>git --<span class="hljs-keyword">version</span><br></code></pre></td></tr></table></figure><h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><p>传送门：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a><br>Node.js是一个跨平台的基于Chrome V8引擎的JavaScript运行环境，它可以让JS脚本可以脱离浏览器执行。这么说如果还是不太理解的话，把他理解成Python就可以<br>为啥需要Node.js呢，有两个原因：</p><ul><li>Hexo是基于Node.js作为构建系统来生成网页</li><li>Hexo可以使用npm来下载安装</li><li>等等，这里npm又是啥？别慌，npm是Node.js的包管理器，理解成pip之于Python。最近的Node.js在安装的时候已经会一起安装npm了</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">// 校验安装<br><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br>npm -v<br></code></pre></td></tr></table></figure><h1 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h1><p>使用npm进行安装：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">// -g参数表示将hexo-<span class="hljs-keyword">cli</span>作为全局(<span class="hljs-meta">global</span>)包安装，hexo-<span class="hljs-keyword">cli</span>中的二进制文件加入到PATH中，方便终端调用hexo命令<br>// 全局安装还可以使得在创建其他Node<span class="hljs-number">.</span><span class="hljs-keyword">js</span>项目的时候也方便引用到<br>npm install hexo-<span class="hljs-keyword">cli</span> -g<br></code></pre></td></tr></table></figure><h1 id="创建Hexo项目"><a href="#创建Hexo项目" class="headerlink" title="创建Hexo项目"></a>创建Hexo项目</h1><p>1.在你喜欢的地方创建一个文件夹，例如桌面上，就叫做hexo_blog吧<br>2.cd到该目录<br>3.执行命令，创建Hexo项目</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 创建Hexo项目</span><br>hexo <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p>4.执行命令，在本地生成网页产物</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// 生成网页产物</span><br>hexo <span class="hljs-keyword">generate</span><br></code></pre></td></tr></table></figure><p>5.执行命令，启动本地服务器查看</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">// 启动本地server</span><br>hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>6.在浏览器中打开 <a href="http://localhost:4000/">http://localhost:4000/</a> 查看效果<br>不出意外的话，恭喜，已经曙光初现了，接下来就是将我们的blog发布到GitHub Page上供别人浏览了</p><h1 id="部署到GitHub-Page"><a href="#部署到GitHub-Page" class="headerlink" title="部署到GitHub Page"></a>部署到GitHub Page</h1><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>之前我们创建了GitHub账号，我们新建一个仓库<br><img src="/../images/image.png" alt="Alt text"><br><img src="/../images/image-1.png" alt="Alt text"></p><h2 id="配置SSH密钥"><a href="#配置SSH密钥" class="headerlink" title="配置SSH密钥"></a>配置SSH密钥</h2><p>等等，啥是SSH，啥是密钥？我们要把本地的Hexo产物文件push到GitHub，是通过ssh的方式。那GitHub肯定需要鉴权把。鉴权我们可以使用账号密码，但是如果每次push都要输入账号密码，那想想都很痛苦。<br>那有没有更加轻松的方式呢？GitHub很贴心的为你想好啦，我们只要把我们的设备添加到GitHub的信任名单中，那就不用每次都输入账号密码了，so easy!<br>那么，GitHub是怎么信任咱们的设备呢，它需要一个凭证，这个凭证就是SSH密钥。通过SSH密钥能够唯一标识请求来自于这台设备。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 生成ssh密钥，引号中的内容是注释，可以写我们自己的邮箱账号<br><span class="hljs-regexp">//</span> 一路回车即可，记录下保存密钥的文件，例如~<span class="hljs-regexp">/.ssh/i</span>d_rsa，对应的公钥就是~<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub<br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;your email@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>查看公钥并复制到剪切板中，然后按找到下面的位置将公钥粘贴进去<br><img src="/../images/image-2.png" alt="Alt text"><br><img src="/../images/image-3.png" alt="Alt text"><br><img src="/../images/image-4.png" alt="Alt text"><br><img src="/../images/image-5.png" alt="Alt text"><br>测试下添加是否成功</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// 当出现提示时回车即可</span><br>ssh -T <span class="hljs-symbol">git@</span>github.com<br></code></pre></td></tr></table></figure><h2 id="配置Git个人信息"><a href="#配置Git个人信息" class="headerlink" title="配置Git个人信息"></a>配置Git个人信息</h2><p>上面的ssh密钥只是前提条件，GitHub在我们push文件时还会根据邮箱和用户名做校验，因而需要设置下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;此处填你的用户名&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;此处填你的邮箱&quot;</span><br></code></pre></td></tr></table></figure><h2 id="将Hexo部署到GitHub-Page"><a href="#将Hexo部署到GitHub-Page" class="headerlink" title="将Hexo部署到GitHub Page"></a>将Hexo部署到GitHub Page</h2><p>首先，回到我们之前在GitHub上创建的仓库，复制我们仓库的ssh地址<br><img src="/../images/image-6.png" alt="Alt text"><br>打开我们创建的Hexo项目中的_config.yml文件(推荐Visual Studio Code，后续写blog也很方便)，找到如下入位置进行修改<br><img src="/../images/image-12.png" alt="Alt text"><br><img src="/../images/image-11.png" alt="Alt text"></p><p><strong>敲黑板！！注意branch不要填入master，要填入main。</strong> 分支填错会就看不到了页面了，GitHub Page使用默认分支部署。不知道啥时候开始，GitHub为了zzzq把默认分支的名称从master修改为main了QAQ  </p><p>我们还需要安装一个hexo部署到git的插件来完成最终部署，进入到我们之前创建的Hexo项目目录中，执行：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span> 这里<span class="hljs-params">--save</span>是将该插件添加到Hexo项目的依赖中，记录到package.json<br>npm install hexo-deployer-git <span class="hljs-params">--save</span><br></code></pre></td></tr></table></figure><p>最后一步，激动人心的时刻就要到了，执行</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g -d</span><br></code></pre></td></tr></table></figure><p>完成之后，访问user_name.github.io（user_name替换成你自己的GitHub账号名称），我们就可以看到我们的blog啦，完结撒花~~~~</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇正式的blog</title>
    <link href="/2023/12/03/first_blog/"/>
    <url>/2023/12/03/first_blog/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到我的blog，从今天起，开始正式坚持写blog，记录下工作生活中遇到的一些问题，同时也希望分享一些有价值的经验。<br>作为一个曾经幻想着推动人类文明进步的孩子，到现在休息日只想躺着的废柴，终究还是被现实磨平了棱角。<br>那至少，希望用技术创造一些有价值的东西吧。<br>emmm，虽然也很难就是了，但梦想还是要有的嘛，万一呢</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hello</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
